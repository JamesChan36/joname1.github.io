{"meta":{"exported_on":1495863848922,"version":"004"},"data":{"posts":[{"id":9,"uuid":"3fe8bcbb-75a2-4261-8bec-671ae7aa49ad","title":"Bootstrap详解：栅格系统","slug":"bootstrap-grid","markdown":"Bootstrap3使用了四种栅格选项来形成栅格系统，这四种选项在官网上的介绍很多人不理解，这里跟大家详解一下四种栅格选项之间的区别，其实区别只有一条就是适合不同尺寸的屏幕设备。我们看class前缀这一项，我们姑且以前缀命名这四种栅格选项，他们分别是col-xs ,col-sm,col-md,col-lg，我们懂英文的就知道，lg是large的缩写，md是mid的缩写，sm是small的缩写，xs是extra small的缩写。这样命名就体现了这几种class适应的屏幕宽度不同。下面我们分别介绍这几种class的特点。 \n\n## 1、col-xs类\n用法是<code>&lt;div class=\"col-xs-*\"&gt;</code>。它星号代表1~12的数字。我们知道栅格系统总共有12列，我们在这里使用数字几就代表着该div占用几列的宽度。假如我们在给超级小屏幕开发界面，那么我们使用该类，该类没有任何行为，不管屏幕小到多少，都不会改变div的布局。\n\n## 2、col-sm类\n用法是<code>&lt;div class=\"col-sm-*\"&gt;</code>。星号的意义同上，但是该类适合屏幕宽度为`750px`的设备，如果在屏幕宽度小于750px的设别上，该div就会水平堆叠。\n这是在`大于750px`屏幕上的样式：\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgo0fcs11eg114i150n8mtgdga.jpg)\n这是在`小于750px`屏幕上的样式：\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgnv4oa1o2ni62183v8l61npea.jpg)\n\n\n## 3、col-md类\n用法是<code>&lt;div class=\"col-md-*\"&gt;</code>。该类适合`970px`以上屏幕。通上面讲的道理一样，假如使用屏幕尺寸小于`970px`的设备查看网页，div就会垂直堆叠。\n这是在`大于970px`屏幕上的样式：\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgo0fcs11eg114i150n8mtgdga.jpg)\n这是在`小于970px`屏幕上的样式：\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgnv4oa1o2ni62183v8l61npea.jpg)\n\n\n## 4、col-lg类\n用法是<code>&lt;div class=\"col-lg-*\"&gt;</code>。该类适合`1170px`以上屏幕。通上面讲的道理一样，假如使用屏幕尺寸小于`1170px`的设备查看网页，div就会垂直堆叠。\n这是在`大于1170px`屏幕上的样式：\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgo0fcs11eg114i150n8mtgdga.jpg)\n这是在`小于1170px`屏幕上的样式：\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgnv4oa1o2ni62183v8l61npea.jpg)\n\n如何组合使用这几个类?\n我们使用<code>&lt;div class=\"col-sm-10 col-md-8\"&gt;</code>这样的方式来表示：在中等屏幕设备上该div占用8列的宽度；在小屏幕上该div占用10列的宽度。","html":"<p>Bootstrap3使用了四种栅格选项来形成栅格系统，这四种选项在官网上的介绍很多人不理解，这里跟大家详解一下四种栅格选项之间的区别，其实区别只有一条就是适合不同尺寸的屏幕设备。我们看class前缀这一项，我们姑且以前缀命名这四种栅格选项，他们分别是col-xs ,col-sm,col-md,col-lg，我们懂英文的就知道，lg是large的缩写，md是mid的缩写，sm是small的缩写，xs是extra small的缩写。这样命名就体现了这几种class适应的屏幕宽度不同。下面我们分别介绍这几种class的特点。 </p>\n\n<h2 id=\"1colxs\">1、col-xs类</h2>\n\n<p>用法是<code>&lt;div class=\"col-xs-*\"&gt;</code>。它星号代表1~12的数字。我们知道栅格系统总共有12列，我们在这里使用数字几就代表着该div占用几列的宽度。假如我们在给超级小屏幕开发界面，那么我们使用该类，该类没有任何行为，不管屏幕小到多少，都不会改变div的布局。</p>\n\n<h2 id=\"2colsm\">2、col-sm类</h2>\n\n<p>用法是<code>&lt;div class=\"col-sm-*\"&gt;</code>。星号的意义同上，但是该类适合屏幕宽度为<code>750px</code>的设备，如果在屏幕宽度小于750px的设别上，该div就会水平堆叠。\n这是在<code>大于750px</code>屏幕上的样式：\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgo0fcs11eg114i150n8mtgdga.jpg\" alt=\"\" />\n这是在<code>小于750px</code>屏幕上的样式：\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgnv4oa1o2ni62183v8l61npea.jpg\" alt=\"\" /></p>\n\n<h2 id=\"3colmd\">3、col-md类</h2>\n\n<p>用法是<code>&lt;div class=\"col-md-*\"&gt;</code>。该类适合<code>970px</code>以上屏幕。通上面讲的道理一样，假如使用屏幕尺寸小于<code>970px</code>的设备查看网页，div就会垂直堆叠。\n这是在<code>大于970px</code>屏幕上的样式：\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgo0fcs11eg114i150n8mtgdga.jpg\" alt=\"\" />\n这是在<code>小于970px</code>屏幕上的样式：\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgnv4oa1o2ni62183v8l61npea.jpg\" alt=\"\" /></p>\n\n<h2 id=\"4collg\">4、col-lg类</h2>\n\n<p>用法是<code>&lt;div class=\"col-lg-*\"&gt;</code>。该类适合<code>1170px</code>以上屏幕。通上面讲的道理一样，假如使用屏幕尺寸小于<code>1170px</code>的设备查看网页，div就会垂直堆叠。\n这是在<code>大于1170px</code>屏幕上的样式：\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgo0fcs11eg114i150n8mtgdga.jpg\" alt=\"\" />\n这是在<code>小于1170px</code>屏幕上的样式：\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ahgnv4oa1o2ni62183v8l61npea.jpg\" alt=\"\" /></p>\n\n<p>如何组合使用这几个类?\n我们使用<code>&lt;div class=\"col-sm-10 col-md-8\"&gt;</code>这样的方式来表示：在中等屏幕设备上该div占用8列的宽度；在小屏幕上该div占用10列的宽度。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495695455318,"created_by":1,"updated_at":1495699882293,"updated_by":1,"published_at":1472891820000,"published_by":1},{"id":10,"uuid":"38ea7e39-46cd-456e-87e9-34bddb3f95a9","title":"使用 gulp 搭建CommonJs & ES6 模块化环境","slug":"gulp-commonjs-es6","markdown":"# 1. Browserify简介\n> \"Browserify lets you require('modules') in the browser by bundling up all of your dependencies.\" - Browserify.org\n\n上面的描述是摘自 browserify 官网；用通俗的话讲就是：browserify 是一个浏览器端代码模块化工具，可以处理模块之间的依赖关系，让服务器端的 CommonJS 格式的模块可以运行在浏览器端。\n\n\n![](https://cloud.githubusercontent.com/assets/3995814/11768221/b22531fe-a200-11e5-8e98-8e36d8471bf8.png)\n\nbrowserify的原理：\n\n* 处理代码依赖，将模块打包到一起\n\n打包为单个文件存在的问题：\n\n* 暂时用不到的代码也会被打包，体积大，首次加载速度慢\n\n* 只要一个模块更新，整个文件缓存失效\n\n注：暂时用不到的代码指不同的页面有不同的 JS 文件，不需要在当前页面引用其他页面的代码即为暂时用不到的代码\n\nBrowserify的解决方案：\n\n* entry point：入口点技术，每个入口点打包一个文件，两个入口点的相同依赖模块单独打包为common.js\n\n### 安装与配置\n安装 browserify\n\n``npm install -g browserify``\n\n引入 browserify\n\n``import  browserify from 'browserify'``\n\n基本配置\n```js\nglup.taks('browserify', function() {\n  browserify({\n     //先处理依赖，入口文件\n     entries: ['./foo.js','./main.js'],\n     //进行转化\n     transform: []\n  })\n   .bundle() // 多个文件打包成一个文件\n   .pipe(source()) // browserify的输出不能直接用做gulp输入，所以需要source进行处理 \n   .pipe(gulp.dest('./'));  \n})\n```\n### 安装一些依赖插件\n```bash\nnpm install --save-dev vinyl-source-stream vinyl-buffer gulp-sourcemaps\n```\n\n``vinyl-source-stream``: browserify的输出不能直接用着gulp的输入，vinly-source-stream 主要是做一个转化\n\n``vinyl-buffer``: 用于将vinyl流转化为buffered vinyl文件（gulp-sourcemaps及大部分Gulp插件都需要这种格式）\n\n``gulp-sourcemaps``: Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置，便于调试\n\n``Watchify``: 加速 browserify 编译\n\n# 2. 编写 CommonJS 模块\n\n### 目录结构\n```\n|-- dist/\n   |-----bundle.js\n|-- src/\n   |-----foo.js\n   |-----main.js\n|--gulpfile.babel.js\n|--package.json\n```\n\n### 新建两个模块文件 foo.js, main.js\n``$ touch foo.js main.js``\n\n### 让我使用 CommonJs 规范来写一些代码\n> CommonJS 规范是为了解决 JavaScript的作用域问题而定义的模块形式，可以使每个模块在它自身的命名空间中执行。\n> 该规范的主要内容是，模块必须通过module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。\n\n```js\n// foo.js\n// 定义foo.js模块，通过 module.exports 导出对外的变量或接口\nlet variable = 8;\nlet sum = (a, b = 6) => (a + b);\nlet square = (b) => {\n    return b * b;\n};\nmodule.exports.variable = variable;\nmodule.exports.sum = sum;\nmodule.exports.square = square;\n\n// mian.js\n// 通过 require() 来导入 foo.js 模块\nvar bar = require('./foo')\nconsole.log(bar);  // Object\nconsole.log(bar.variable); // 8\nconsole.log(bar.sum(1)); // 7\nconsole.log(bar.square(5)); // 25\n```\n> 上面我们使用 ES6 的语法写了两个模块，分别是 foo.js 和 main.js; 在 foo.js 中通过 module.exports 导出对外的变量或接口;在 main.js 中通过 require() 来导入 foo.js 模块，那我们就可以在 mian.js 模块中使用 foo.js 中的变量和接口了。这就是一个最基本的 CommonJs 示例了\n\n### 配置 browserify\n通过第一小节的学习，我们知道要在浏览器中运行 CommonJs 风格的模块代码，就需要借助 browserify 来作为转换工具，下面我们在 gulp.babel.js 中来配置 browserify：\n```js\n// set browserify task\ngulp.task('browserify',()=> {\n    browserify({\n        entries: ['src/js/main.js','src/js/foo.js'],\n        debug: true, // 告知Browserify在运行同时生成内联sourcemap用于调试\n    })\n        .transform(\"babelify\", {presets: [\"es2015\"]})\n        .bundle()\n        .pipe(source('bundle.js'))\n        .pipe(buffer()) // 缓存文件内容\n        .pipe(sourcemaps.init({loadMaps: true})) // 从 browserify 文件载入 map\n        .pipe(sourcemaps.write('.')) // 写入 .map 文件\n        .pipe(gulp.dest('dist/js'))\n        .pipe(notify({ message: 'browserify task complete' }));\n})\n```\n\n运行\n``gulp-browserify``\n\n![](https://cloud.githubusercontent.com/assets/3995814/11768266/592159dc-a202-11e5-8be3-2d4ddaefe5c3.png)\n\n### 打开浏览器，查看运行结果(见上面main.js文件的注释)\n\n# 编写 ES6 Module 模块\n\n上面的代码主要是 CommonJs 模块化的写法，我们再来看看最近火热的 ES6 提供的 Module；让我们使用 ES6 Module 来改写上面的代码：\n```js\n// foo.js\n// 定义foo.js模块，通过 exports 导出对外的变量或接口\nlet variable = 8;\nlet sum = (a, b = 6) => (a + b);\nlet square = (b) => {\n    return b * b;\n};\nexport { variable, sum, square };\n\n// main.js\n// 测试一：\n// 通过 import 来导入 foo.js 模块\nimport {variable, sum, square} from './foo';\nconsole.log(variable); // 8\nconsole.log(sum(1)); // 7\nconsole.log(square(5)); // 25\n\n// 测试二：\n// 直接引用整个 foo 模块\nimport bar from './foo';\nconsole.log(bar); // 输出值是undefined，后面做解释\n\n// 测试三：\n// 通过 ES6 的语法加载整个 foo模块\nimport * as bar from './foo'\nconsole.log(bar); // Object\n```\n\n## 总结 CommonJs 和 ES6 Module\n\n### CommonJs\n* 根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在一个文件定义的变量（包括函数和类），都是私有的，对其他文件是不可见的\n* 通过 module.exports 对象，定义对外接口，其他文件加载该模块，实际上就是读取 module.exports 变量\n* 通过 require 命令加载模块文件，然后返回该模块的exports对象\n### ES6 Module\n* 通过 export 命令用于规定模块的对外接口\n* 通过 import 命令用于加载其他模块提供的功能\n### ES6 Module 与 CommonJs 的区别\n* 在ES6中使用 import 取代 require\n* 在ES6中使用 export 取代 module.exports\n* ES6 在编译时就能确定模块的依赖关系，以及输入和输出的变量，而 CommonJs 只能在运行时确定模块的依赖关系以及输入和输出的变量。\n- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”\n- 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，输入时采用静态命令的形式。即在输入时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”\n注：上面提到 ES6 加载模块时是采用指定加载某个输出值的形式，如果你要想加载整个模块，你可以这么做：\n``import * as customName from './moduleFileName';``","html":"<h1 id=\"1browserify\">1. Browserify简介</h1>\n\n<blockquote>\n  <p>\"Browserify lets you require('modules') in the browser by bundling up all of your dependencies.\" - Browserify.org</p>\n</blockquote>\n\n<p>上面的描述是摘自 browserify 官网；用通俗的话讲就是：browserify 是一个浏览器端代码模块化工具，可以处理模块之间的依赖关系，让服务器端的 CommonJS 格式的模块可以运行在浏览器端。</p>\n\n<p><img src=\"https://cloud.githubusercontent.com/assets/3995814/11768221/b22531fe-a200-11e5-8e98-8e36d8471bf8.png\" alt=\"\" /></p>\n\n<p>browserify的原理：</p>\n\n<ul>\n<li>处理代码依赖，将模块打包到一起</li>\n</ul>\n\n<p>打包为单个文件存在的问题：</p>\n\n<ul>\n<li><p>暂时用不到的代码也会被打包，体积大，首次加载速度慢</p></li>\n<li><p>只要一个模块更新，整个文件缓存失效</p></li>\n</ul>\n\n<p>注：暂时用不到的代码指不同的页面有不同的 JS 文件，不需要在当前页面引用其他页面的代码即为暂时用不到的代码</p>\n\n<p>Browserify的解决方案：</p>\n\n<ul>\n<li>entry point：入口点技术，每个入口点打包一个文件，两个入口点的相同依赖模块单独打包为common.js</li>\n</ul>\n\n<h3 id=\"\">安装与配置</h3>\n\n<p>安装 browserify</p>\n\n<p><code>npm install -g browserify</code></p>\n\n<p>引入 browserify</p>\n\n<p><code>import  browserify from 'browserify'</code></p>\n\n<p>基本配置</p>\n\n<pre><code class=\"language-js\">glup.taks('browserify', function() {  \n  browserify({\n     //先处理依赖，入口文件\n     entries: ['./foo.js','./main.js'],\n     //进行转化\n     transform: []\n  })\n   .bundle() // 多个文件打包成一个文件\n   .pipe(source()) // browserify的输出不能直接用做gulp输入，所以需要source进行处理 \n   .pipe(gulp.dest('./'));  \n})\n</code></pre>\n\n<h3 id=\"\">安装一些依赖插件</h3>\n\n<pre><code class=\"language-bash\">npm install --save-dev vinyl-source-stream vinyl-buffer gulp-sourcemaps  \n</code></pre>\n\n<p><code>vinyl-source-stream</code>: browserify的输出不能直接用着gulp的输入，vinly-source-stream 主要是做一个转化</p>\n\n<p><code>vinyl-buffer</code>: 用于将vinyl流转化为buffered vinyl文件（gulp-sourcemaps及大部分Gulp插件都需要这种格式）</p>\n\n<p><code>gulp-sourcemaps</code>: Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置，便于调试</p>\n\n<p><code>Watchify</code>: 加速 browserify 编译</p>\n\n<h1 id=\"2commonjs\">2. 编写 CommonJS 模块</h1>\n\n<h3 id=\"\">目录结构</h3>\n\n<pre><code>|-- dist/\n   |-----bundle.js\n|-- src/\n   |-----foo.js\n   |-----main.js\n|--gulpfile.babel.js\n|--package.json\n</code></pre>\n\n<h3 id=\"foojsmainjs\">新建两个模块文件 foo.js, main.js</h3>\n\n<p><code>$ touch foo.js main.js</code></p>\n\n<h3 id=\"commonjs\">让我使用 CommonJs 规范来写一些代码</h3>\n\n<blockquote>\n  <p>CommonJS 规范是为了解决 JavaScript的作用域问题而定义的模块形式，可以使每个模块在它自身的命名空间中执行。\n  该规范的主要内容是，模块必须通过module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。</p>\n</blockquote>\n\n<pre><code class=\"language-js\">// foo.js\n// 定义foo.js模块，通过 module.exports 导出对外的变量或接口\nlet variable = 8;  \nlet sum = (a, b = 6) =&gt; (a + b);  \nlet square = (b) =&gt; {  \n    return b * b;\n};\nmodule.exports.variable = variable;  \nmodule.exports.sum = sum;  \nmodule.exports.square = square;\n\n// mian.js\n// 通过 require() 来导入 foo.js 模块\nvar bar = require('./foo')  \nconsole.log(bar);  // Object  \nconsole.log(bar.variable); // 8  \nconsole.log(bar.sum(1)); // 7  \nconsole.log(bar.square(5)); // 25  \n</code></pre>\n\n<blockquote>\n  <p>上面我们使用 ES6 的语法写了两个模块，分别是 foo.js 和 main.js; 在 foo.js 中通过 module.exports 导出对外的变量或接口;在 main.js 中通过 require() 来导入 foo.js 模块，那我们就可以在 mian.js 模块中使用 foo.js 中的变量和接口了。这就是一个最基本的 CommonJs 示例了</p>\n</blockquote>\n\n<h3 id=\"browserify\">配置 browserify</h3>\n\n<p>通过第一小节的学习，我们知道要在浏览器中运行 CommonJs 风格的模块代码，就需要借助 browserify 来作为转换工具，下面我们在 gulp.babel.js 中来配置 browserify：</p>\n\n<pre><code class=\"language-js\">// set browserify task\ngulp.task('browserify',()=&gt; {  \n    browserify({\n        entries: ['src/js/main.js','src/js/foo.js'],\n        debug: true, // 告知Browserify在运行同时生成内联sourcemap用于调试\n    })\n        .transform(\"babelify\", {presets: [\"es2015\"]})\n        .bundle()\n        .pipe(source('bundle.js'))\n        .pipe(buffer()) // 缓存文件内容\n        .pipe(sourcemaps.init({loadMaps: true})) // 从 browserify 文件载入 map\n        .pipe(sourcemaps.write('.')) // 写入 .map 文件\n        .pipe(gulp.dest('dist/js'))\n        .pipe(notify({ message: 'browserify task complete' }));\n})\n</code></pre>\n\n<p>运行\n<code>gulp-browserify</code></p>\n\n<p><img src=\"https://cloud.githubusercontent.com/assets/3995814/11768266/592159dc-a202-11e5-8be3-2d4ddaefe5c3.png\" alt=\"\" /></p>\n\n<h3 id=\"mainjs\">打开浏览器，查看运行结果(见上面main.js文件的注释)</h3>\n\n<h1 id=\"es6module\">编写 ES6 Module 模块</h1>\n\n<p>上面的代码主要是 CommonJs 模块化的写法，我们再来看看最近火热的 ES6 提供的 Module；让我们使用 ES6 Module 来改写上面的代码：</p>\n\n<pre><code class=\"language-js\">// foo.js\n// 定义foo.js模块，通过 exports 导出对外的变量或接口\nlet variable = 8;  \nlet sum = (a, b = 6) =&gt; (a + b);  \nlet square = (b) =&gt; {  \n    return b * b;\n};\nexport { variable, sum, square };\n\n// main.js\n// 测试一：\n// 通过 import 来导入 foo.js 模块\nimport {variable, sum, square} from './foo';  \nconsole.log(variable); // 8  \nconsole.log(sum(1)); // 7  \nconsole.log(square(5)); // 25\n\n// 测试二：\n// 直接引用整个 foo 模块\nimport bar from './foo';  \nconsole.log(bar); // 输出值是undefined，后面做解释\n\n// 测试三：\n// 通过 ES6 的语法加载整个 foo模块\nimport * as bar from './foo'  \nconsole.log(bar); // Object  \n</code></pre>\n\n<h2 id=\"commonjses6module\">总结 CommonJs 和 ES6 Module</h2>\n\n<h3 id=\"commonjs\">CommonJs</h3>\n\n<ul>\n<li>根据 CommonJS 规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在一个文件定义的变量（包括函数和类），都是私有的，对其他文件是不可见的</li>\n<li>通过 module.exports 对象，定义对外接口，其他文件加载该模块，实际上就是读取 module.exports 变量</li>\n<li>通过 require 命令加载模块文件，然后返回该模块的exports对象</li>\n</ul>\n\n<h3 id=\"es6module\">ES6 Module</h3>\n\n<ul>\n<li>通过 export 命令用于规定模块的对外接口</li>\n<li>通过 import 命令用于加载其他模块提供的功能</li>\n</ul>\n\n<h3 id=\"es6modulecommonjs\">ES6 Module 与 CommonJs 的区别</h3>\n\n<ul>\n<li>在ES6中使用 import 取代 require</li>\n<li>在ES6中使用 export 取代 module.exports</li>\n<li>ES6 在编译时就能确定模块的依赖关系，以及输入和输出的变量，而 CommonJs 只能在运行时确定模块的依赖关系以及输入和输出的变量。</li>\n<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”</li>\n<li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，输入时采用静态命令的形式。即在输入时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”\n注：上面提到 ES6 加载模块时是采用指定加载某个输出值的形式，如果你要想加载整个模块，你可以这么做：\n<code>import * as customName from './moduleFileName';</code></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495695591241,"created_by":1,"updated_at":1495699872680,"updated_by":1,"published_at":1473065700000,"published_by":1},{"id":11,"uuid":"87523478-5d70-4640-98b0-a072eeb52aee","title":"使用 gulp 压缩图片","slug":"gulp-img","markdown":"压缩 图片文件可降低文件大小，提高图片加载速度。\n\n找到规律转换为 gulp 代码\n\n\n---\n找到 `images/` 目录下的所有文件，压缩它们，将压缩后的文件存放在 `dist/images/` 目录下。\n\ngulp 代码\n---------\n\n**一、安装 gulp-imagemin** 模块\n\n提示：你需要使用命令行的 `cd` 切换至对应目录再进行安装操作和 gulp 启动操作。\n\n在命令行输入\n\n```bash\nnpm install gulp-imagemin\n```\n\n安装成功后你会看到如下信息：(安装时间可能会比较长)\n\n```bash\ngulp-imagemin@2.2.1 node_modules/gulp-imagemin\n├── object-assign@2.0.0\n├── pretty-bytes@1.0.3 (get-stdin@4.0.1)\n├── chalk@1.0.0 (escape-string-regexp@1.0.3, ansi-styles@2.0.1, supports-color@1.3.1, has-ansi@1.0.3, strip-ansi@2.0.1)\n├── through2-concurrent@0.3.1 (through2@0.6.3)\n├── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, lodash._reevaluate@3.0.0, lodash._reescape@3.0.0, lodash._reinterpolate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, vinyl@0.4.6, through2@0.6.3, multipipe@0.1.2, lodash.template@3.3.2, dateformat@1.0.11)\n└── imagemin@3.1.0 (get-stdin@3.0.2, optional@0.1.3, vinyl@0.4.6, through2@0.6.3, stream-combiner@0.2.1, concat-stream@1.4.7, meow@2.1.0, vinyl-fs@0.3.13, imagemin-svgo@4.1.2, imagemin-optipng@4.2.0, imagemin-jpegtran@4.1.0, imagemin-pngquant@4.0.0, imagemin-gifsicle@4.1.0)\n```\n\n**二、创建 `gulpfile.js` 文件编写代码**\n\n在对应目录创建 `gulpfile.js` 文件并写入如下内容：\n\n```js\n// 获取 gulp\nvar gulp = require('gulp');\n\n// 获取 gulp-imagemin 模块\nvar imagemin = require('gulp-imagemin')\n\n// 压缩图片任务\n// 在命令行输入 gulp images 启动此任务\ngulp.task('images', function () {\n    // 1. 找到图片\n    gulp.src('images/*.*')\n    // 2. 压缩图片\n        .pipe(imagemin({\n            progressive: true\n        }))\n    // 3. 另存图片\n        .pipe(gulp.dest('dist/images'))\n});\n\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {\n    // 监听文件修改，当文件被修改则执行 images 任务\n    gulp.watch('images/*.*)', ['images'])\n});\n\n// 使用 gulp.task('default') 定义默认任务\n// 在命令行使用 gulp 启动 images 任务和 auto 任务\ngulp.task('default', ['images', 'auto'])\n```\n\n你可以访问 [gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin) 以查看更多用法。\n\n------\n\n**三、在 `images/` 目录下存放图片**\n\n在 `gulpfile.js` 对应目录创建 `images` 文件夹，并在 `images/` 目录下存放图片。\n\n--------\n\n**四、运行 gulp 查看效果**\n\n在命令行输入 `gulp` +回车\n\n你将看到命令行出现如下提示\n\n```\ngulp\n[18:10:42] Using gulpfile ~/Documents/code/gulp-book/demo/chapter4/gulpfile.js\n[18:10:42] Starting 'images'...\n[18:10:42] Finished 'images' after 5.72 ms\n[18:10:42] Starting 'auto'...\n[18:10:42] Finished 'auto' after 6.39 ms\n[18:10:42] Starting 'default'...\n[18:10:42] Finished 'default' after 5.91 μs\n[18:10:42] gulp-imagemin: Minified 3 images (saved 25.83 kB - 5.2%)\n```","html":"<p>压缩 图片文件可降低文件大小，提高图片加载速度。</p>\n\n<p>找到规律转换为 gulp 代码</p>\n\n<hr />\n\n<p>找到 <code>images/</code> 目录下的所有文件，压缩它们，将压缩后的文件存放在 <code>dist/images/</code> 目录下。</p>\n\n<h2 id=\"gulp\">gulp 代码  </h2>\n\n<p><strong>一、安装 gulp-imagemin</strong> 模块</p>\n\n<p>提示：你需要使用命令行的 <code>cd</code> 切换至对应目录再进行安装操作和 gulp 启动操作。</p>\n\n<p>在命令行输入</p>\n\n<pre><code class=\"language-bash\">npm install gulp-imagemin  \n</code></pre>\n\n<p>安装成功后你会看到如下信息：(安装时间可能会比较长)</p>\n\n<pre><code class=\"language-bash\">gulp-imagemin@2.2.1 node_modules/gulp-imagemin  \n├── object-assign@2.0.0\n├── pretty-bytes@1.0.3 (get-stdin@4.0.1)\n├── chalk@1.0.0 (escape-string-regexp@1.0.3, ansi-styles@2.0.1, supports-color@1.3.1, has-ansi@1.0.3, strip-ansi@2.0.1)\n├── through2-concurrent@0.3.1 (through2@0.6.3)\n├── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, lodash._reevaluate@3.0.0, lodash._reescape@3.0.0, lodash._reinterpolate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, vinyl@0.4.6, through2@0.6.3, multipipe@0.1.2, lodash.template@3.3.2, dateformat@1.0.11)\n└── imagemin@3.1.0 (get-stdin@3.0.2, optional@0.1.3, vinyl@0.4.6, through2@0.6.3, stream-combiner@0.2.1, concat-stream@1.4.7, meow@2.1.0, vinyl-fs@0.3.13, imagemin-svgo@4.1.2, imagemin-optipng@4.2.0, imagemin-jpegtran@4.1.0, imagemin-pngquant@4.0.0, imagemin-gifsicle@4.1.0)\n</code></pre>\n\n<p><strong>二、创建 <code>gulpfile.js</code> 文件编写代码</strong></p>\n\n<p>在对应目录创建 <code>gulpfile.js</code> 文件并写入如下内容：</p>\n\n<pre><code class=\"language-js\">// 获取 gulp\nvar gulp = require('gulp');\n\n// 获取 gulp-imagemin 模块\nvar imagemin = require('gulp-imagemin')\n\n// 压缩图片任务\n// 在命令行输入 gulp images 启动此任务\ngulp.task('images', function () {  \n    // 1. 找到图片\n    gulp.src('images/*.*')\n    // 2. 压缩图片\n        .pipe(imagemin({\n            progressive: true\n        }))\n    // 3. 另存图片\n        .pipe(gulp.dest('dist/images'))\n});\n\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {  \n    // 监听文件修改，当文件被修改则执行 images 任务\n    gulp.watch('images/*.*)', ['images'])\n});\n\n// 使用 gulp.task('default') 定义默认任务\n// 在命令行使用 gulp 启动 images 任务和 auto 任务\ngulp.task('default', ['images', 'auto'])  \n</code></pre>\n\n<p>你可以访问 <a href=\"https://github.com/sindresorhus/gulp-imagemin\">gulp-imagemin</a> 以查看更多用法。</p>\n\n<hr />\n\n<p><strong>三、在 <code>images/</code> 目录下存放图片</strong></p>\n\n<p>在 <code>gulpfile.js</code> 对应目录创建 <code>images</code> 文件夹，并在 <code>images/</code> 目录下存放图片。</p>\n\n<hr />\n\n<p><strong>四、运行 gulp 查看效果</strong></p>\n\n<p>在命令行输入 <code>gulp</code> +回车</p>\n\n<p>你将看到命令行出现如下提示</p>\n\n<pre><code>gulp  \n[18:10:42] Using gulpfile ~/Documents/code/gulp-book/demo/chapter4/gulpfile.js\n[18:10:42] Starting 'images'...\n[18:10:42] Finished 'images' after 5.72 ms\n[18:10:42] Starting 'auto'...\n[18:10:42] Finished 'auto' after 6.39 ms\n[18:10:42] Starting 'default'...\n[18:10:42] Finished 'default' after 5.91 μs\n[18:10:42] gulp-imagemin: Minified 3 images (saved 25.83 kB - 5.2%)\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495699240147,"created_by":1,"updated_at":1495699840843,"updated_by":1,"published_at":1473421980000,"published_by":1},{"id":12,"uuid":"cb67370f-d535-4186-aa9e-af84586c09e6","title":"使用 gulp 压缩 CSS","slug":"gulp-css","markdown":"\n压缩 css 代码可降低 css 文件大小，提高页面打开速度。\n\n我们接着将规律转换为 gulp 代码\n\n---\n找到 `css/` 目录下的所有 css 文件，压缩它们，将压缩后的文件存放在 `dist/css/` 目录下。\n\ngulp 代码\n---------\n\n当熟悉`使用 gulp 压缩 JS`的方法后，配置压缩 CSS 的 gulp 代码就变得很轻松。\n\n\n**一、安装 gulp-minify-css** 模块\n\n提示：你需要使用命令行的 `cd` 切换到对应目录后进行安装操作。\n\n在命令行输入\n\n```\nnpm install gulp-minify-css\n```\n\n安装成功后你会看到如下信息：(安装时间可能会比较长)\n\n```\ngulp-minify-css@1.0.0 node_modules/gulp-minify-css\n├── object-assign@2.0.0\n├── vinyl-sourcemaps-apply@0.1.4 (source-map@0.1.43)\n├── clean-css@3.1.8 (commander@2.6.0, source-map@0.1.43)\n├── through2@0.6.3 (xtend@4.0.0, readable-stream@1.0.33)\n├── vinyl-bufferstream@1.0.1 (bufferstreams@1.0.1)\n└── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, lodash._reescape@3.0.0, lodash._reinterpolate@3.0.0, lodash._reevaluate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, multipipe@0.1.2, vinyl@0.4.6, chalk@1.0.0, lodash.template@3.3.2, dateformat@1.0.11)\n```\n\n**二、参照`使用 gulp 压缩 JS`创建 `gulpfile.js` 文件编写代码**\n\n在对应目录创建 `gulpfile.js` 文件并写入如下内容：\n\n```js\n// 获取 gulp\nvar gulp = require('gulp')\n\n// 获取 minify-css 模块（用于压缩 CSS）\nvar minifyCSS = require('gulp-minify-css')\n\n// 压缩 css 文件\n// 在命令行使用 gulp css 启动此任务\ngulp.task('css', function () {\n    // 1. 找到文件\n    gulp.src('css/*.css')\n    // 2. 压缩文件\n        .pipe(minifyCSS())\n    // 3. 另存为压缩文件\n        .pipe(gulp.dest('dist/css'))\n})\n\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {\n    // 监听文件修改，当文件被修改则执行 css 任务\n    gulp.watch('css/*.css', ['css'])\n});\n\n// 使用 gulp.task('default') 定义默认任务\n// 在命令行使用 gulp 启动 css 任务和 auto 任务\ngulp.task('default', ['css', 'auto'])\n```\n\n你可以访问 [gulp-minify-css](https://github.com/jonathanepollack/gulp-minify-css) 以查看更多用法。\n\n------\n\n**三、创建 css 文件**\n\n在 `gulpfile.js` 对应目录创建 `css` 文件夹，并在 `css/` 目录下创建 `a.css` 文件。\n\n```css\n/* a.css */\nbody a{\n    color:pink;\n}\n```\n\n--------\n\n**四、运行 gulp 查看效果**\n\n在命令行输入 `gulp` +回车\n\n你将看到命令行出现如下提示\n\n```\ngulp\n[17:01:19] Using gulpfile ~/Documents/code/gulp-book/demo/chapter3/gulpfile.js\n[17:01:19] Starting 'css'...\n[17:01:19] Finished 'css' after 6.21 ms\n[17:01:19] Starting 'auto'...\n[17:01:19] Finished 'auto' after 5.42 ms\n[17:01:19] Starting 'default'...\n[17:01:19] Finished 'default' after 5.71 μs\n```\n\ngulp 会创建 `dist/css` 目录，并创建 `a.css` 文件，此文件存放压缩后的 css 代码。","html":"<p>压缩 css 代码可降低 css 文件大小，提高页面打开速度。</p>\n\n<p>我们接着将规律转换为 gulp 代码</p>\n\n<hr />\n\n<p>找到 <code>css/</code> 目录下的所有 css 文件，压缩它们，将压缩后的文件存放在 <code>dist/css/</code> 目录下。</p>\n\n<h2 id=\"gulp\">gulp 代码  </h2>\n\n<p>当熟悉<code>使用 gulp 压缩 JS</code>的方法后，配置压缩 CSS 的 gulp 代码就变得很轻松。</p>\n\n<p><strong>一、安装 gulp-minify-css</strong> 模块</p>\n\n<p>提示：你需要使用命令行的 <code>cd</code> 切换到对应目录后进行安装操作。</p>\n\n<p>在命令行输入</p>\n\n<pre><code>npm install gulp-minify-css  \n</code></pre>\n\n<p>安装成功后你会看到如下信息：(安装时间可能会比较长)</p>\n\n<pre><code>gulp-minify-css@1.0.0 node_modules/gulp-minify-css  \n├── object-assign@2.0.0\n├── vinyl-sourcemaps-apply@0.1.4 (source-map@0.1.43)\n├── clean-css@3.1.8 (commander@2.6.0, source-map@0.1.43)\n├── through2@0.6.3 (xtend@4.0.0, readable-stream@1.0.33)\n├── vinyl-bufferstream@1.0.1 (bufferstreams@1.0.1)\n└── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, lodash._reescape@3.0.0, lodash._reinterpolate@3.0.0, lodash._reevaluate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, multipipe@0.1.2, vinyl@0.4.6, chalk@1.0.0, lodash.template@3.3.2, dateformat@1.0.11)\n</code></pre>\n\n<p><strong>二、参照<code>使用 gulp 压缩 JS</code>创建 <code>gulpfile.js</code> 文件编写代码</strong></p>\n\n<p>在对应目录创建 <code>gulpfile.js</code> 文件并写入如下内容：</p>\n\n<pre><code class=\"language-js\">// 获取 gulp\nvar gulp = require('gulp')\n\n// 获取 minify-css 模块（用于压缩 CSS）\nvar minifyCSS = require('gulp-minify-css')\n\n// 压缩 css 文件\n// 在命令行使用 gulp css 启动此任务\ngulp.task('css', function () {  \n    // 1. 找到文件\n    gulp.src('css/*.css')\n    // 2. 压缩文件\n        .pipe(minifyCSS())\n    // 3. 另存为压缩文件\n        .pipe(gulp.dest('dist/css'))\n})\n\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {  \n    // 监听文件修改，当文件被修改则执行 css 任务\n    gulp.watch('css/*.css', ['css'])\n});\n\n// 使用 gulp.task('default') 定义默认任务\n// 在命令行使用 gulp 启动 css 任务和 auto 任务\ngulp.task('default', ['css', 'auto'])  \n</code></pre>\n\n<p>你可以访问 <a href=\"https://github.com/jonathanepollack/gulp-minify-css\">gulp-minify-css</a> 以查看更多用法。</p>\n\n<hr />\n\n<p><strong>三、创建 css 文件</strong></p>\n\n<p>在 <code>gulpfile.js</code> 对应目录创建 <code>css</code> 文件夹，并在 <code>css/</code> 目录下创建 <code>a.css</code> 文件。</p>\n\n<pre><code class=\"language-css\">/* a.css */\nbody a{  \n    color:pink;\n}\n</code></pre>\n\n<hr />\n\n<p><strong>四、运行 gulp 查看效果</strong></p>\n\n<p>在命令行输入 <code>gulp</code> +回车</p>\n\n<p>你将看到命令行出现如下提示</p>\n\n<pre><code>gulp  \n[17:01:19] Using gulpfile ~/Documents/code/gulp-book/demo/chapter3/gulpfile.js\n[17:01:19] Starting 'css'...\n[17:01:19] Finished 'css' after 6.21 ms\n[17:01:19] Starting 'auto'...\n[17:01:19] Finished 'auto' after 5.42 ms\n[17:01:19] Starting 'default'...\n[17:01:19] Finished 'default' after 5.71 μs\n</code></pre>\n\n<p>gulp 会创建 <code>dist/css</code> 目录，并创建 <code>a.css</code> 文件，此文件存放压缩后的 css 代码。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495699488378,"created_by":1,"updated_at":1495699849892,"updated_by":1,"published_at":1473249240000,"published_by":1},{"id":13,"uuid":"88c1b8e9-e6dd-4a88-b3e4-ce2fe27d2f6b","title":"使用 gulp 压缩 JS","slug":"gulp-js","markdown":"压缩 js 代码可降低 js 文件大小，提高页面打开速度。在不利用 gulp 时我们需要通过各种工具手动完成压缩工作。\n\n所有的 gulp 代码编写都可以看做是将规律转化为代码的过程。\n\n\n---\n\n找到 `js/` 目录下的所有 js 文件，压缩它们，将压缩后的文件存放在 `dist/js/` 目录下。\n\ngulp 代码\n----\n\n**建议**：你可以只阅读下面的代码与注释或同时阅读代码解释\n\ngulp 的所有配置代码都写在 `gulpfile.js` 文件。\n\n**一、新建一个 `gulpfile.js` 文件**\n```\nchapter2\n└── gulpfile.js\n```\n\n---------\n\n**二、在 `gulpfile.js` 中编写代码**\n\n```js\n// 获取 gulp\nvar gulp = require('gulp')\n```\n\n> `require()` 是 node （CommonJS）中获取模块的语法。\n> \n> 在 gulp 中你只需要理解 `require()` 可以获取模块。\n\n---------\n\n**三、获取 `gulp-uglify` 组件**\n\n```js\n// 获取 uglify 模块（用于压缩 JS）\nvar uglify = require('gulp-uglify')\n```\n\n---------\n\n**四、创建压缩任务**\n\n```js\n// 压缩 js 文件\n// 在命令行使用 gulp script 启动此任务\ngulp.task('script', function() {\n    // 1. 找到文件\n    gulp.src('js/*.js')\n    // 2. 压缩文件\n        .pipe(uglify())\n    // 3. 另存压缩后的文件\n        .pipe(gulp.dest('dist/js'))\n})\n```\n\n- `gulp.task(name, fn)` - 定义任务，第一个参数是任务名，第二个参数是任务内容。\n- `gulp.src(path)` - 选择文件，传入参数是文件路径。\n- `gulp.dest(path)` - 输出文件\n- `gulp.pipe()` - 管道，你可以暂时将 pipe 理解为将操作加入执行队列\n\n参考：[gulp API文档](http://www.gulpjs.com.cn/docs/api/)\n\n---------\n\n**五、跳转至 `gulpfile.js` 所在目录**\n\n打开命令行使用 `cd` 命令跳转至 `gulpfile.js` 文件所在目录。\n\n例如我的 `gulpfile.js` 文件保存在 `C:\\gulp-book\\demo\\chapter2\\gulpfile.js`。\n\n那么就需要在命令行输入\n```\ncd C:\\gulp-book\\demo\\chapter2\n```\n\n> Mac 用户可使用 `cd Documents/gulp-book/demo/chapter2/` 跳转\n\n---------\n\n**六、使用命令行运行 script 任务**\n\n在控制台输入 `gulp 任务名` 可运行任务，此处我们输入 `gulp script` 回车。\n\n注意：输入 `gulp script` 后命令行将会提示错误信息\n```\n// 在命令行输入\ngulp script\n\nError: Cannot find module 'gulp-uglify'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n```\n\n`Cannot find module 'gulp-uglify'` 没有找到 `gulp-uglify` 模块。\n\n----------\n\n**七、安装 `gulp-uglify` 模块**\n\n因为我们并没有安装 `gulp-uglify` 模块到本地，所以找不到此模块。\n\n使用 npm 安装 `gulp-uglify` 到本地\n\n```\nnpm install gulp-uglify\n```\n\n安装成功后你会看到如下信息：\n```\ngulp-uglify@1.1.0 node_modules/gulp-uglify\n├── deepmerge@0.2.7\n├── uglify-js@2.4.16 (uglify-to-browserify@1.0.2, async@0.2.10, source-map@0.1.34, optimist@0.3.7)\n├── vinyl-sourcemaps-apply@0.1.4 (source-map@0.1.43)\n├── through2@0.6.3 (xtend@4.0.0, readable-stream@1.0.33)\n└── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, object-assign@2.0.0, lodash._reinterpolate@3.0.0, lodash._reescape@3.0.0, lodash._reevaluate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, chalk@1.0.0, lodash.template@3.3.2, vinyl@0.4.6, multipipe@0.1.2, dateformat@1.0.11)\nchapter2 $\n```\n\n在你的文件夹中会新增一个 `node_modules` 文件夹，这里面存放着 npm 安装的模块。\n\n目录结构：\n```\n├── gulpfile.js\n└── node_modules\n    └── gulp-uglify\n```\n\n接着输入 `gulp script` 执行任务\n\n```\ngulp script\n[13:34:57] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js\n[13:34:57] Starting 'script'...\n[13:34:57] Finished 'script' after 6.13 ms\n```\n\n------------\n\n**八、编写 js 文件**\n\n我们发现 gulp 没有进行任何压缩操作。因为没有js这个目录，也没有 js 目录下的 `.js` 后缀文件。\n\n创建 `a.js` 文件，并编写如下内容\n\n```\n// a.js\nfunction demo (msg) {\n    alert('--------\\r\\n' + msg + '\\r\\n--------')\n}\n\ndemo('Hi')\n```\n\n目录结构：\n```\n├── gulpfile.js\n├──  js\n│   └── a.js\n└── node_modules\n    └── gulp-uglify\n```\n\n接着在命令行输入 `gulp script` 执行任务\n\ngulp 会在命令行当前目录下创建 `dist/js/` 文件夹，并创建压缩后的 `a.js` 文件。\n\n目录结构：\n```\n├── gulpfile.js\n├──  js\n│   └── a.js\n├──  dist\n│   └── js\n│       └── a.js\n└── node_modules\n    └── gulp-uglify\n```\n\n[dist/js/a.js](https://github.com/nimojs/gulp-book/blob/master/demo/chapter2/dist/js/a.js)\n```js\nfunction demo(n){alert(\"--------\\r\\n\"+n+\"\\r\\n--------\")}demo(\"Hi\");\n```\n\n---------\n\n**九、检测代码修改自动执行任务**\n\n`js/a.js`一旦有修改 就必须重新在命令行输入 `gulp script` ，这很麻烦。\n\n可以使用 `gulp.watch(src, fn)` 检测指定目录下文件的修改后执行任务。\n\n在 `gulpfile.js` 中编写如下代码：\n```\n// 监听文件修改，当文件被修改则执行 script 任务\ngulp.watch('js/*.js', ['script']);\n```\n\n但是没有命令可以运行 `gulp.watch()`，需要将 `gulp.watch()` 包含在一个任务中。\n\n```\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {\n    // 监听文件修改，当文件被修改则执行 script 任务\n    gulp.watch('js/*.js', ['script'])\n})\n```\n\n接着在命令行输入 `gulp auto`，自动监听 `js/*.js` 文件的修改后压缩js。\n\n```\n$gulp auto\n[21:09:45] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js\n[21:09:45] Starting 'auto'...\n[21:09:45] Finished 'auto' after 9.19 ms\n```\n\n此时修改 `js/a.js` 中的代码并保存。命令行将会出现提示，表示检测到文件修改并压缩文件。\n\n```\n[21:11:01] Starting 'script'...\n[21:11:01] Finished 'script' after 2.85 ms\n```\n至此，我们完成了 gulp 压缩 js 文件的自动化代码编写。\n\n**注意：**使用 `gulp.watch` 后你的命令行会进入“运行”状态，此时你不可以在命令行进行其他操作。可通过 `Ctrl + C` 停止 gulp。\n\n> Mac 下使用 `control + C` 停止 gulp\n\n**十、使用 gulp.task('default', fn) 定义默认任务**\n\n增加如下代码\n\n```js\ngulp.task('default', ['script', 'auto']);\n```\n\n此时你可以在命令行直接输入 `gulp` +回车，运行 `script` 和 `auto` 任务。\n\n最终代码如下：\n\n```js\n// 获取 gulp\nvar gulp = require('gulp')\n\n// 获取 uglify 模块（用于压缩 JS）\nvar uglify = require('gulp-uglify')\n\n// 压缩 js 文件\n// 在命令行使用 gulp script 启动此任务\ngulp.task('script', function() {\n    // 1. 找到文件\n    gulp.src('js/*.js')\n    // 2. 压缩文件\n        .pipe(uglify())\n    // 3. 另存压缩后的文件\n        .pipe(gulp.dest('dist/js'))\n})\n\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {\n    // 监听文件修改，当文件被修改则执行 script 任务\n    gulp.watch('js/*.js', ['script'])\n})\n\n\n// 使用 gulp.task('default') 定义默认任务\n// 在命令行使用 gulp 启动 script 任务和 auto 任务\ngulp.task('default', ['script', 'auto'])\n```\n\n去除注释后，你会发现只需要 11 行代码就可以让 gulp 自动监听 js 文件的修改后压缩代码。但是还有还有一些性能问题和缺少容错性，将在后面的章节详细说明。\n\n\n你可以访问 [gulp-uglify](https://github.com/terinjokes/gulp-uglify) 以查看更多用法。","html":"<p>压缩 js 代码可降低 js 文件大小，提高页面打开速度。在不利用 gulp 时我们需要通过各种工具手动完成压缩工作。</p>\n\n<p>所有的 gulp 代码编写都可以看做是将规律转化为代码的过程。</p>\n\n<hr />\n\n<p>找到 <code>js/</code> 目录下的所有 js 文件，压缩它们，将压缩后的文件存放在 <code>dist/js/</code> 目录下。</p>\n\n<h2 id=\"gulp\">gulp 代码  </h2>\n\n<p><strong>建议</strong>：你可以只阅读下面的代码与注释或同时阅读代码解释</p>\n\n<p>gulp 的所有配置代码都写在 <code>gulpfile.js</code> 文件。</p>\n\n<p><strong>一、新建一个 <code>gulpfile.js</code> 文件</strong></p>\n\n<pre><code>chapter2  \n└── gulpfile.js\n</code></pre>\n\n<hr />\n\n<p><strong>二、在 <code>gulpfile.js</code> 中编写代码</strong></p>\n\n<pre><code class=\"language-js\">// 获取 gulp\nvar gulp = require('gulp')  \n</code></pre>\n\n<blockquote>\n  <p><code>require()</code> 是 node （CommonJS）中获取模块的语法。</p>\n  \n  <p>在 gulp 中你只需要理解 <code>require()</code> 可以获取模块。</p>\n</blockquote>\n\n<hr />\n\n<p><strong>三、获取 <code>gulp-uglify</code> 组件</strong></p>\n\n<pre><code class=\"language-js\">// 获取 uglify 模块（用于压缩 JS）\nvar uglify = require('gulp-uglify')  \n</code></pre>\n\n<hr />\n\n<p><strong>四、创建压缩任务</strong></p>\n\n<pre><code class=\"language-js\">// 压缩 js 文件\n// 在命令行使用 gulp script 启动此任务\ngulp.task('script', function() {  \n    // 1. 找到文件\n    gulp.src('js/*.js')\n    // 2. 压缩文件\n        .pipe(uglify())\n    // 3. 另存压缩后的文件\n        .pipe(gulp.dest('dist/js'))\n})\n</code></pre>\n\n<ul>\n<li><code>gulp.task(name, fn)</code> - 定义任务，第一个参数是任务名，第二个参数是任务内容。</li>\n<li><code>gulp.src(path)</code> - 选择文件，传入参数是文件路径。</li>\n<li><code>gulp.dest(path)</code> - 输出文件</li>\n<li><code>gulp.pipe()</code> - 管道，你可以暂时将 pipe 理解为将操作加入执行队列</li>\n</ul>\n\n<p>参考：<a href=\"http://www.gulpjs.com.cn/docs/api/\">gulp API文档</a></p>\n\n<hr />\n\n<p><strong>五、跳转至 <code>gulpfile.js</code> 所在目录</strong></p>\n\n<p>打开命令行使用 <code>cd</code> 命令跳转至 <code>gulpfile.js</code> 文件所在目录。</p>\n\n<p>例如我的 <code>gulpfile.js</code> 文件保存在 <code>C:\\gulp-book\\demo\\chapter2\\gulpfile.js</code>。</p>\n\n<p>那么就需要在命令行输入</p>\n\n<pre><code>cd C:\\gulp-book\\demo\\chapter2  \n</code></pre>\n\n<blockquote>\n  <p>Mac 用户可使用 <code>cd Documents/gulp-book/demo/chapter2/</code> 跳转</p>\n</blockquote>\n\n<hr />\n\n<p><strong>六、使用命令行运行 script 任务</strong></p>\n\n<p>在控制台输入 <code>gulp 任务名</code> 可运行任务，此处我们输入 <code>gulp script</code> 回车。</p>\n\n<p>注意：输入 <code>gulp script</code> 后命令行将会提示错误信息</p>\n\n<pre><code>// 在命令行输入\ngulp script\n\nError: Cannot find module 'gulp-uglify'  \n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n</code></pre>\n\n<p><code>Cannot find module 'gulp-uglify'</code> 没有找到 <code>gulp-uglify</code> 模块。</p>\n\n<hr />\n\n<p><strong>七、安装 <code>gulp-uglify</code> 模块</strong></p>\n\n<p>因为我们并没有安装 <code>gulp-uglify</code> 模块到本地，所以找不到此模块。</p>\n\n<p>使用 npm 安装 <code>gulp-uglify</code> 到本地</p>\n\n<pre><code>npm install gulp-uglify  \n</code></pre>\n\n<p>安装成功后你会看到如下信息：</p>\n\n<pre><code>gulp-uglify@1.1.0 node_modules/gulp-uglify  \n├── deepmerge@0.2.7\n├── uglify-js@2.4.16 (uglify-to-browserify@1.0.2, async@0.2.10, source-map@0.1.34, optimist@0.3.7)\n├── vinyl-sourcemaps-apply@0.1.4 (source-map@0.1.43)\n├── through2@0.6.3 (xtend@4.0.0, readable-stream@1.0.33)\n└── gulp-util@3.0.4 (array-differ@1.0.0, beeper@1.0.0, array-uniq@1.0.2, object-assign@2.0.0, lodash._reinterpolate@3.0.0, lodash._reescape@3.0.0, lodash._reevaluate@3.0.0, replace-ext@0.0.1, minimist@1.1.1, chalk@1.0.0, lodash.template@3.3.2, vinyl@0.4.6, multipipe@0.1.2, dateformat@1.0.11)\nchapter2 $  \n</code></pre>\n\n<p>在你的文件夹中会新增一个 <code>node_modules</code> 文件夹，这里面存放着 npm 安装的模块。</p>\n\n<p>目录结构：</p>\n\n<pre><code>├── gulpfile.js\n└── node_modules\n    └── gulp-uglify\n</code></pre>\n\n<p>接着输入 <code>gulp script</code> 执行任务</p>\n\n<pre><code>gulp script  \n[13:34:57] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js\n[13:34:57] Starting 'script'...\n[13:34:57] Finished 'script' after 6.13 ms\n</code></pre>\n\n<hr />\n\n<p><strong>八、编写 js 文件</strong></p>\n\n<p>我们发现 gulp 没有进行任何压缩操作。因为没有js这个目录，也没有 js 目录下的 <code>.js</code> 后缀文件。</p>\n\n<p>创建 <code>a.js</code> 文件，并编写如下内容</p>\n\n<pre><code>// a.js\nfunction demo (msg) {  \n    alert('--------\\r\\n' + msg + '\\r\\n--------')\n}\n\ndemo('Hi')  \n</code></pre>\n\n<p>目录结构：</p>\n\n<pre><code>├── gulpfile.js\n├──  js\n│   └── a.js\n└── node_modules\n    └── gulp-uglify\n</code></pre>\n\n<p>接着在命令行输入 <code>gulp script</code> 执行任务</p>\n\n<p>gulp 会在命令行当前目录下创建 <code>dist/js/</code> 文件夹，并创建压缩后的 <code>a.js</code> 文件。</p>\n\n<p>目录结构：</p>\n\n<pre><code>├── gulpfile.js\n├──  js\n│   └── a.js\n├──  dist\n│   └── js\n│       └── a.js\n└── node_modules\n    └── gulp-uglify\n</code></pre>\n\n<p><a href=\"https://github.com/nimojs/gulp-book/blob/master/demo/chapter2/dist/js/a.js\">dist/js/a.js</a></p>\n\n<pre><code class=\"language-js\">function demo(n){alert(\"--------\\r\\n\"+n+\"\\r\\n--------\")}demo(\"Hi\");  \n</code></pre>\n\n<hr />\n\n<p><strong>九、检测代码修改自动执行任务</strong></p>\n\n<p><code>js/a.js</code>一旦有修改 就必须重新在命令行输入 <code>gulp script</code> ，这很麻烦。</p>\n\n<p>可以使用 <code>gulp.watch(src, fn)</code> 检测指定目录下文件的修改后执行任务。</p>\n\n<p>在 <code>gulpfile.js</code> 中编写如下代码：</p>\n\n<pre><code>// 监听文件修改，当文件被修改则执行 script 任务\ngulp.watch('js/*.js', ['script']);  \n</code></pre>\n\n<p>但是没有命令可以运行 <code>gulp.watch()</code>，需要将 <code>gulp.watch()</code> 包含在一个任务中。</p>\n\n<pre><code>// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {  \n    // 监听文件修改，当文件被修改则执行 script 任务\n    gulp.watch('js/*.js', ['script'])\n})\n</code></pre>\n\n<p>接着在命令行输入 <code>gulp auto</code>，自动监听 <code>js/*.js</code> 文件的修改后压缩js。</p>\n\n<pre><code>$gulp auto\n[21:09:45] Using gulpfile ~/Documents/code/gulp-book/demo/chapter2/gulpfile.js\n[21:09:45] Starting 'auto'...\n[21:09:45] Finished 'auto' after 9.19 ms\n</code></pre>\n\n<p>此时修改 <code>js/a.js</code> 中的代码并保存。命令行将会出现提示，表示检测到文件修改并压缩文件。</p>\n\n<pre><code>[21:11:01] Starting 'script'...\n[21:11:01] Finished 'script' after 2.85 ms\n</code></pre>\n\n<p>至此，我们完成了 gulp 压缩 js 文件的自动化代码编写。</p>\n\n<p><strong>注意：</strong>使用 <code>gulp.watch</code> 后你的命令行会进入“运行”状态，此时你不可以在命令行进行其他操作。可通过 <code>Ctrl + C</code> 停止 gulp。</p>\n\n<blockquote>\n  <p>Mac 下使用 <code>control + C</code> 停止 gulp</p>\n</blockquote>\n\n<p><strong>十、使用 gulp.task('default', fn) 定义默认任务</strong></p>\n\n<p>增加如下代码</p>\n\n<pre><code class=\"language-js\">gulp.task('default', ['script', 'auto']);  \n</code></pre>\n\n<p>此时你可以在命令行直接输入 <code>gulp</code> +回车，运行 <code>script</code> 和 <code>auto</code> 任务。</p>\n\n<p>最终代码如下：</p>\n\n<pre><code class=\"language-js\">// 获取 gulp\nvar gulp = require('gulp')\n\n// 获取 uglify 模块（用于压缩 JS）\nvar uglify = require('gulp-uglify')\n\n// 压缩 js 文件\n// 在命令行使用 gulp script 启动此任务\ngulp.task('script', function() {  \n    // 1. 找到文件\n    gulp.src('js/*.js')\n    // 2. 压缩文件\n        .pipe(uglify())\n    // 3. 另存压缩后的文件\n        .pipe(gulp.dest('dist/js'))\n})\n\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {  \n    // 监听文件修改，当文件被修改则执行 script 任务\n    gulp.watch('js/*.js', ['script'])\n})\n\n\n// 使用 gulp.task('default') 定义默认任务\n// 在命令行使用 gulp 启动 script 任务和 auto 任务\ngulp.task('default', ['script', 'auto'])  \n</code></pre>\n\n<p>去除注释后，你会发现只需要 11 行代码就可以让 gulp 自动监听 js 文件的修改后压缩代码。但是还有还有一些性能问题和缺少容错性，将在后面的章节详细说明。</p>\n\n<p>你可以访问 <a href=\"https://github.com/terinjokes/gulp-uglify\">gulp-uglify</a> 以查看更多用法。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495699658299,"created_by":1,"updated_at":1495699865833,"updated_by":1,"published_at":1473162660000,"published_by":1},{"id":14,"uuid":"6c8263e4-4f45-4286-9f82-27b790c4d794","title":"使用 gulp 编译 LESS","slug":"gulp-less","markdown":"> Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护。\n\n安装\n---\n\n```\nnpm install gulp-less\n```\n\n基本用法\n-------\n\n```js\n// 获取 gulp\nvar gulp = require('gulp')\n// 获取 gulp-less 模块\nvar less = require('gulp-less')\n\n// 编译less\n// 在命令行输入 gulp less 启动此任务\ngulp.task('less', function () {\n    // 1. 找到 less 文件\n    gulp.src('less/**.less')\n    // 2. 编译为css\n        .pipe(less())\n    // 3. 另存文件\n        .pipe(gulp.dest('dist/css'))\n});\n\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {\n    // 监听文件修改，当文件被修改则执行 less 任务\n    gulp.watch('less/**.less', ['less'])\n})\n\n// 使用 gulp.task('default') 定义默认任务\n// 在命令行使用 gulp 启动 less 任务和 auto 任务\ngulp.task('default', ['less', 'auto'])\n```\n\n你可以访问 [gulp-less](https://github.com/plus3network/gulp-less) 以查看更多用法。\n\nLESS 代码和编译后的CSS代码\n----------\n\nless/a.less\n\n```css\n.less{\n  a{\n        color:pink;\n    }\n}\n```\nless/import.less\n\n\n```css\n@import \"a.less\";\n.import{\n  a{\n    color:red;\n    }\n}\n```\nless/a.css\n\n```css\n.less a {\n  color: pink;\n}\n```\nless/import.css\n\n```css\n.less a {\n  color: pink;\n}\n.import a{\n  color: red;\n}\n```\n","html":"<blockquote>\n  <p>Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护。</p>\n</blockquote>\n\n<h2 id=\"\">安装</h2>\n\n<pre><code>npm install gulp-less  \n</code></pre>\n\n<h2 id=\"\">基本用法</h2>\n\n<pre><code class=\"language-js\">// 获取 gulp\nvar gulp = require('gulp')  \n// 获取 gulp-less 模块\nvar less = require('gulp-less')\n\n// 编译less\n// 在命令行输入 gulp less 启动此任务\ngulp.task('less', function () {  \n    // 1. 找到 less 文件\n    gulp.src('less/**.less')\n    // 2. 编译为css\n        .pipe(less())\n    // 3. 另存文件\n        .pipe(gulp.dest('dist/css'))\n});\n\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {  \n    // 监听文件修改，当文件被修改则执行 less 任务\n    gulp.watch('less/**.less', ['less'])\n})\n\n// 使用 gulp.task('default') 定义默认任务\n// 在命令行使用 gulp 启动 less 任务和 auto 任务\ngulp.task('default', ['less', 'auto'])  \n</code></pre>\n\n<p>你可以访问 <a href=\"https://github.com/plus3network/gulp-less\">gulp-less</a> 以查看更多用法。</p>\n\n<h2 id=\"lesscss\">LESS 代码和编译后的CSS代码  </h2>\n\n<p>less/a.less</p>\n\n<pre><code class=\"language-css\">.less{\n  a{\n        color:pink;\n    }\n}\n</code></pre>\n\n<p>less/import.less</p>\n\n<pre><code class=\"language-css\">@import \"a.less\";\n.import{\n  a{\n    color:red;\n    }\n}\n</code></pre>\n\n<p>less/a.css</p>\n\n<pre><code class=\"language-css\">.less a {\n  color: pink;\n}\n</code></pre>\n\n<p>less/import.css</p>\n\n<pre><code class=\"language-css\">.less a {\n  color: pink;\n}\n.import a{\n  color: red;\n}\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495699713923,"created_by":1,"updated_at":1495699833386,"updated_by":1,"published_at":1473422100000,"published_by":1},{"id":15,"uuid":"ae201707-3fb6-44ab-bb0a-a0c80d5bfd21","title":"使用 gulp 编译 Sass","slug":"gulp-sass","markdown":"## gulp-sass\n\n本章使用的是 ruby-sass 如果你不方便安装 ruby 或编译速度慢，建议使用`gulp-sass`\n\n----------\n\n> Sass 是一种 CSS 的开发工具，提供了许多便利的写法，大大节省了开发者的时间，使得 CSS 的开发，变得简单和可维护。\n\n本章使用 `ruby-sass` 编译 css,若你没有安装 ruby 和 sass 请移步`使用ruby.taobao安装 Sass`\n\n\n安装\n---\n\n```\nnpm install gulp-ruby-sass\n```\n\n基本用法\n-------\n\n```js\n// 获取 gulp\nvar gulp = require('gulp')\n// 获取 gulp-ruby-sass 模块\nvar sass = require('gulp-ruby-sass')\n\n// 编译sass\n// 在命令行输入 gulp sass 启动此任务\ngulp.task('sass', function() {\n    return sass('sass/') \n    .on('error', function (err) {\n      console.error('Error!', err.message);\n   })\n    .pipe(gulp.dest('dist/css'))\n});\n\n\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {\n    // 监听文件修改，当文件被修改则执行 images 任务\n    gulp.watch('sass/**/*.scss', ['sass'])\n});\n\n// 使用 gulp.task('default') 定义默认任务\n// 在命令行使用 gulp 启动 sass 任务和 auto 任务\ngulp.task('default', ['sass', 'auto'])\n```\n\n\nSass 代码和编译后的 CSS 代码\n----------\n\nsass/a.scss\n\n```css\n.sass{\n    a{\n        color:pink;\n    }\n}\n```\n\nsass/import.scss\n\n\n```css\n@import \"a.scss\";\n.import{\n  a{\n    color:red;\n    }\n}\n```\n\nsass/a.css\n\n```css\n.sass a {\n  color: pink;\n}\n```\n\nsass/import.css\n\n```css\n.sass a {\n  color: pink;\n}\n.import a{\n  color: red;\n}\n```","html":"<h2 id=\"gulpsass\">gulp-sass</h2>\n\n<p>本章使用的是 ruby-sass 如果你不方便安装 ruby 或编译速度慢，建议使用<code>gulp-sass</code></p>\n\n<hr />\n\n<blockquote>\n  <p>Sass 是一种 CSS 的开发工具，提供了许多便利的写法，大大节省了开发者的时间，使得 CSS 的开发，变得简单和可维护。</p>\n</blockquote>\n\n<p>本章使用 <code>ruby-sass</code> 编译 css,若你没有安装 ruby 和 sass 请移步<code>使用ruby.taobao安装 Sass</code></p>\n\n<h2 id=\"\">安装</h2>\n\n<pre><code>npm install gulp-ruby-sass  \n</code></pre>\n\n<h2 id=\"\">基本用法</h2>\n\n<pre><code class=\"language-js\">// 获取 gulp\nvar gulp = require('gulp')  \n// 获取 gulp-ruby-sass 模块\nvar sass = require('gulp-ruby-sass')\n\n// 编译sass\n// 在命令行输入 gulp sass 启动此任务\ngulp.task('sass', function() {  \n    return sass('sass/') \n    .on('error', function (err) {\n      console.error('Error!', err.message);\n   })\n    .pipe(gulp.dest('dist/css'))\n});\n\n\n// 在命令行使用 gulp auto 启动此任务\ngulp.task('auto', function () {  \n    // 监听文件修改，当文件被修改则执行 images 任务\n    gulp.watch('sass/**/*.scss', ['sass'])\n});\n\n// 使用 gulp.task('default') 定义默认任务\n// 在命令行使用 gulp 启动 sass 任务和 auto 任务\ngulp.task('default', ['sass', 'auto'])  \n</code></pre>\n\n<h2 id=\"sasscss\">Sass 代码和编译后的 CSS 代码  </h2>\n\n<p>sass/a.scss</p>\n\n<pre><code class=\"language-css\">.sass{\n    a{\n        color:pink;\n    }\n}\n</code></pre>\n\n<p>sass/import.scss</p>\n\n<pre><code class=\"language-css\">@import \"a.scss\";\n.import{\n  a{\n    color:red;\n    }\n}\n</code></pre>\n\n<p>sass/a.css</p>\n\n<pre><code class=\"language-css\">.sass a {\n  color: pink;\n}\n</code></pre>\n\n<p>sass/import.css</p>\n\n<pre><code class=\"language-css\">.sass a {\n  color: pink;\n}\n.import a{\n  color: red;\n}\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495699758767,"created_by":1,"updated_at":1495699821677,"updated_by":1,"published_at":1473508500000,"published_by":1},{"id":16,"uuid":"3eae0db5-e42e-4d1d-a801-f1feea8e57f4","title":"使用gulp自动合成雪碧图","slug":"gulp-sprite","markdown":"\n相信做前端的同学都做过这样的事情，为优化图片，减少请求会把拿到切好的图标图片，通过ps（或者其他工具）把图片合并到一张图里面，再通过css定位把对于的样式写出来引用的html里面。对于一些图片较多的项目，这个过程可能要花费我们一天的时间，来实现这步。今天我给大家带来一个工具，将这一步缩短到几秒钟就能完成，究竟是什么工具这么神奇呢，他就是gulp的一个插件gulp.spritesmith。下面一张图来说明他能做什么。\n\n![](http://p1.bpimg.com/567571/e55bcb8c0182dab2.png)\n看到这个图片介绍，相信大家已经对gulp.spritesmith能做到什么一目了然了，其他的不多说，下面说直接开撸：\n\n## 安装gulp.spritesmith\n```js\nnpm install gulp.spritesmith --save-dev\n```\n\n## 编写Gulpfile.js\n```js\n/引入gulp\nvar gulp=require(\"gulp\"),\n    spritesmith=require('gulp.spritesmith');\n\ngulp.task('default', function () {\n    return gulp.src('images/*.png')//需要合并的图片地址\n        .pipe(spritesmith({\n            imgName: 'sprite.png',//保存合并后图片的地址\n            cssName: 'css/sprite.css',//保存合并后对于css样式的地址\n            padding:5,//合并时两个图片的间距\n            algorithm: 'binary-tree',//注释1\n            cssTemplate:\"css/handlebarsStr.css\"//注释2\n        }))\n        .pipe(gulp.dest('dist/'));\n});\n```\n## 注释一：\n\nAlgorithm 有四个可选值分别为top-down、left-right、diagonal、alt-diagonal、binary-tree\n\n对应如下：\n![](http://p1.bpimg.com/567571/3e5e6867f51ea2a3.png)\n\n\n## 注释二：\n\ncssTemplate 是生成css的模板文件可以是字符串也可以是函数。是字符串是对于相对于的模板地址 对于模板文件样式格式是：\n```css\n{{#sprites}}\n.icon-{{name}}{\n    background-image: url(\"{{escaped_image}}\");\n    background-position: {{px.offset_x}} {{px.offset_y}};\n    width: {{px.width}};\n    height: {{px.height}};\n}\n{{/sprites}}\n```\n\n如果是函数的话，这可以这样写：\n```js\n//引入gulp\nvar gulp=require(\"gulp\"),\n    spritesmith=require('gulp.spritesmith');\n\ngulp.task('default', function () {\n\n    return gulp.src('images/*.png')//需要合并的图片地址\n        .pipe(spritesmith({\n            imgName: 'sprite.png',//保存合并后图片的地址\n            cssName: 'css/sprite.css',//保存合并后对于css样式的地址\n            padding:5,//合并时两个图片的间距\n            algorithm: 'binary-tree',//注释1\n            cssTemplate: function (data) {\n                var arr=[];\n                data.sprites.forEach(function (sprite) {\n                    arr.push(\".icon-\"+sprite.name+\n                    \"{\" +\n                    \"background-image: url('\"+sprite.escaped_image+\"');\"+\n                    \"background-position: \"+sprite.px.offset_x+\"px \"+sprite.px.offset_y+\"px;\"+\n                    \"width:\"+sprite.px.width+\";\"+\n                    \"height:\"+sprite.px.height+\";\"+\n                    \"}\\n\");\n                });\n                return arr.join(\"\");\n            }\n\n        }))\n        .pipe(gulp.dest('dist/'));\n});\n```\n以上就是实现将css代码中的切片图片合并成雪碧图的实现，有问题的大家可以留言","html":"<p>相信做前端的同学都做过这样的事情，为优化图片，减少请求会把拿到切好的图标图片，通过ps（或者其他工具）把图片合并到一张图里面，再通过css定位把对于的样式写出来引用的html里面。对于一些图片较多的项目，这个过程可能要花费我们一天的时间，来实现这步。今天我给大家带来一个工具，将这一步缩短到几秒钟就能完成，究竟是什么工具这么神奇呢，他就是gulp的一个插件gulp.spritesmith。下面一张图来说明他能做什么。</p>\n\n<p><img src=\"http://p1.bpimg.com/567571/e55bcb8c0182dab2.png\" alt=\"\" />\n看到这个图片介绍，相信大家已经对gulp.spritesmith能做到什么一目了然了，其他的不多说，下面说直接开撸：</p>\n\n<h2 id=\"gulpspritesmith\">安装gulp.spritesmith</h2>\n\n<pre><code class=\"language-js\">npm install gulp.spritesmith --save-dev  \n</code></pre>\n\n<h2 id=\"gulpfilejs\">编写Gulpfile.js</h2>\n\n<pre><code class=\"language-js\">/引入gulp\nvar gulp=require(\"gulp\"),  \n    spritesmith=require('gulp.spritesmith');\n\ngulp.task('default', function () {  \n    return gulp.src('images/*.png')//需要合并的图片地址\n        .pipe(spritesmith({\n            imgName: 'sprite.png',//保存合并后图片的地址\n            cssName: 'css/sprite.css',//保存合并后对于css样式的地址\n            padding:5,//合并时两个图片的间距\n            algorithm: 'binary-tree',//注释1\n            cssTemplate:\"css/handlebarsStr.css\"//注释2\n        }))\n        .pipe(gulp.dest('dist/'));\n});\n</code></pre>\n\n<h2 id=\"\">注释一：</h2>\n\n<p>Algorithm 有四个可选值分别为top-down、left-right、diagonal、alt-diagonal、binary-tree</p>\n\n<p>对应如下：\n<img src=\"http://p1.bpimg.com/567571/3e5e6867f51ea2a3.png\" alt=\"\" /></p>\n\n<h2 id=\"\">注释二：</h2>\n\n<p>cssTemplate 是生成css的模板文件可以是字符串也可以是函数。是字符串是对于相对于的模板地址 对于模板文件样式格式是：  </p>\n\n<pre><code class=\"language-css\">{{#sprites}}\n.icon-{{name}}{\n    background-image: url(\"{{escaped_image}}\");\n    background-position: {{px.offset_x}} {{px.offset_y}};\n    width: {{px.width}};\n    height: {{px.height}};\n}\n{{/sprites}}\n</code></pre>\n\n<p>如果是函数的话，这可以这样写：</p>\n\n<pre><code class=\"language-js\">//引入gulp\nvar gulp=require(\"gulp\"),  \n    spritesmith=require('gulp.spritesmith');\n\ngulp.task('default', function () {\n\n    return gulp.src('images/*.png')//需要合并的图片地址\n        .pipe(spritesmith({\n            imgName: 'sprite.png',//保存合并后图片的地址\n            cssName: 'css/sprite.css',//保存合并后对于css样式的地址\n            padding:5,//合并时两个图片的间距\n            algorithm: 'binary-tree',//注释1\n            cssTemplate: function (data) {\n                var arr=[];\n                data.sprites.forEach(function (sprite) {\n                    arr.push(\".icon-\"+sprite.name+\n                    \"{\" +\n                    \"background-image: url('\"+sprite.escaped_image+\"');\"+\n                    \"background-position: \"+sprite.px.offset_x+\"px \"+sprite.px.offset_y+\"px;\"+\n                    \"width:\"+sprite.px.width+\";\"+\n                    \"height:\"+sprite.px.height+\";\"+\n                    \"}\\n\");\n                });\n                return arr.join(\"\");\n            }\n\n        }))\n        .pipe(gulp.dest('dist/'));\n});\n</code></pre>\n\n<p>以上就是实现将css代码中的切片图片合并成雪碧图的实现，有问题的大家可以留言</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495699893226,"created_by":1,"updated_at":1495699934976,"updated_by":1,"published_at":1473583260000,"published_by":1},{"id":17,"uuid":"5c6bc378-5a59-4204-94a6-b6081bc532f2","title":"Gulp入门指南","slug":"gulp-basic","markdown":"是时候抛弃繁重的Grunt了。Gulp是一个直观的、配置的、基于流的任务发布系统，而且它更高效。\n\n\n![](http://p1.bpimg.com/567571/0440708ae3690092.jpg)\n\n为什么我会感兴趣呢？好问题。Gulp通过配置写代码不仅使得它编写任务简单，而且更加方便阅读和维护。\n\nGulp运用node.js的流，这使得它构建任务很快，因为没有磁盘文件的读写操作，如果你想了解更多关于流的知识，你可以看看[这个](https://github.com/substack/stream-handbook)。Gulp允许你输入源文件，然后在一系列的管道插件中处理，最后输出，不像Grunt你需要为每个插件配置输入和输出。下面就让我们通过一个sass编译的例子来看看Gulp和Grunt的差异吧。\n\n**Grunt:**\n\n```javascript\nsass: {\n  dist: {\n    options: {\n      style: 'expanded'\n    },\n    files: {\n      'dist/assets/css/main.css': 'src/styles/main.scss',\n    }\n  }\n},\n\nautoprefixer: {\n  dist: {\n    options: {\n      browsers: [\n        'last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'\n      ]\n    },\n    src: 'dist/assets/css/main.css',\n    dest: 'dist/assets/css/main.css'\n  }\n},\n\ngrunt.registerTask('styles', ['sass', 'autoprefixer']);\n```\n\nGrunt要求每个插件配置要相互独立、要分别为每个插件配置输入源和输出路径。如，我们在sass插件里面配置了一个输入文件，然后保存输出。接着我们需要配置Autoprefixer的输入为Sass的输出，然后再输出了一个文件。让我们来看看Gulp是怎么做的：\n\n**Gulp:**\n\n```javascript\ngulp.task('sass', function() {\n  return gulp.src('src/styles/main.scss')\n    .pipe(sass({ style: 'compressed' }))\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/assets/css'))\n});\n```\n\n在Gulp中我们只配置一次输入文件，然后依次通过Sass插件处理，再传给`Autoprefixer`插件处理，然后我们得到输出文件。整个过程没有读取和写入不必要的文件，效率大大提高。\n\n因此，你感兴趣了么？让我们从安装Gulp，创建基本的任务配置文件`gulpfile`开始吧。\n\n**安装gulp**\n\n在我们开始配置任务之前，我们先要安装gulp:\n\n```bash\nnpm install gulp -g\n```\n\n这样gulp就以全局的方式安装了，你可以在任何node命令行里面调用`gulp CLI`。然后我们需要在本地的某个项目里面使用`gulp`。使用`cd`命令进入到项目目录，运行下面的命令（先确保项目目录存在`package.json`文件）：\n\n```bash\nnpm install gulp --save-dev\n```\n\n这会把gulp安装到本地项目，并且把依赖的包写入到`package.json`文件的`devDependencies`里面\n\n**安装gulp插件**\n\n我们将会安装下列插件来开始我们的任务：\n\n- Sass 编译 ([gulp-ruby-sass](https://github.com/sindresorhus/gulp-ruby-sass))\n- 添加浏览器前缀Autoprefixer([gulp-autoprefixer](https://github.com/Metrime/gulp-autoprefixer))\n- CSS压缩（[gulp-minify-css](https://github.com/jonathanepollack/gulp-minify-css)）\n- JS语法检查 ([gulp-jshint](https://github.com/wearefractal/gulp-jshint))\n- 文件合并 ([gulp-concat](https://github.com/wearefractal/gulp-concat))\n- JS压Uglify ([gulp-uglify](https://github.com/terinjokes/gulp-uglify))\n- 图片压缩([gulp-imagemin](https://github.com/sindresorhus/gulp-imagemin))\n- LiveReload ([gulp-livereload](https://github.com/vohof/gulp-livereload))\n- 图片缓存，只压缩修改过的图片([gulp-cache](https://github.com/jgable/gulp-cache/))\n- 修改提醒([gulp-notify](https://github.com/mikaelbr/gulp-notify))\n- 文件清理 ([del](https://www.npmjs.org/package/del))\n\n运行下面的命令安装这些插件：\n\n```bash\nnpm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev\n```\n\n这将会安装所有的依赖插件，并写入到package.json的devDependencies里面。所有的gulp插件列表可以[在这里](http://gratimax.net/search-gulp-plugins/)看到。\n\n**加载插件**\n\n我们需要创建一个`gulpfile.js`，然后使用这些插件：\n\n```javascript\nvar gulp = require('gulp'),\n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    minifycss = require('gulp-minify-css'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n```\n\n我们也可以像grunt那样自动加载插件：[auto load](https://github.com/jackfranklin/gulp-load-plugins)\n\n**创建任务**\n\n*编译sass、加前缀、压缩*\n\n```javascript\ngulp.task('styles', function() {\n  return gulp.src('src/styles/main.scss')\n    .pipe(sass({ style: 'expanded' }))\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(minifycss())\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(notify({ message: '样式任务完成' }));\n});\n```\n\n> sass({ style: 'expanded' }：编译后保留原格式\n\n\n```javascript\ngulp.task('styles', function() { ... )};\n```\n\n`gulp.task`API是用来创建任务的。然后通过命令`gulp styles`运行这个任务。\n\n\t\n```javascript\nreturn gulp.src('src/styles/main.scss')\n```\n\n`gulp.src`API用来配置输入的源文件。也可以用模式匹配，如`/**/*.scss`匹配所有文件夹下面后缀为`.scss`的文件作为输入。通过返回流使得它是异步的，确保在提醒任务完成的时候任务是完成了的。\n\n```javascript\n.pipe(sass({ style: 'expanded' }))\n```\n\n通过`.pipe()`把源文件流入一个插件的管道中。然后我们可以去插件的官网看看这个插件的详细用法。\n\n```javascript\n.pipe(gulp.dest('dist/assets/css'));\n```\n\n`gulp.dest`API是用来告知输出文件的路径的。一个任务可以有多个输出，如一个用来输出原来的版本（即源文件），一个输出处理后的版本（即输出文件）。你可以在上面的`styles`任务中看到。\n\n建议去看[gulp api文档](https://github.com/gulpjs/gulp/blob/master/docs/API.md)，这样会更加清楚。\n\n**js语法检查、合并和压缩任务**\n\n```javascript\ngulp.task('scripts', function() {\n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n```\n\n这里用的`JSHin`t插件，我们使用了默认的`JSHint Reporter`，可能适用于大多数人，想了解更多可以去[jshint官网](http://www.jshint.com/docs/reporters/)看\n\n**图片压缩任务**\n\n```javascript\ngulp.task('images', function() {\n  return gulp.src('src/images/**/*')\n    .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n    .pipe(gulp.dest('dist/assets/img'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n```\n\n这里我们只用了`imagemin`插件，但是可以做的更好，我们可以缓存修改过的图片，或者只对修改过的图片进行再次的压缩操作，因此我们可以使用[gulp-cahce](https://github.com/jgable/gulp-cache)插件，因此我们需要将这行代码：\n\n```javascript\n.pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n```\n\n改成：レ`人\n\n```javascript\n.pipe(cache(imagemin({ optimizationLevel: 5, progressive: true, interlaced: true })))\n```\n\n此时，只有新的图片或者改变过的图片才会被压缩。\n\n**文件清理**\n\n在再次发布之前，我们最好把目标文件的文件先清理掉，然后重新构建：\n\n```javascript\ngulp.task('clean', function(cb) {\n\t    del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img'], cb)\n\t});\n```\n\n**默认任务**\n\n我们可以通过`$ gulp`启动默认任务，然后在默认任务中调用其他任务：\n\n```javascript\ngulp.task('default', ['clean'], function() {\n\tgulp.start('styles', 'scripts', 'images');\n});\n```\n\n\n看到`gulp.task`里面的数组了吧？这里定义了任务的依赖，也就是说`default`任务依赖`clean`任务。在这个例子中，执行`gulp.start`之前会先运行`clean`任务。Gulp里面的任务同时进行，没有明确的顺序哪个先完成，所以我们要确保`clean`任务执行完之后再执行`gulp.start`里面的任务。\n\n> 虽然不建议在执行依赖任务数组的时候使用`gulp.start`，但是在这里我们没有办法确保`clean`任务执行完毕后再执行其它任务，因此这里使用`gulp.start`貌似是最好的选择。\n\n\n**Watch任务**\n\n当文件发生变化的时候，我们可能需要重新执行任务，因此我们需要配置一个监听文件变化的任务：\n\n```javascript\ngulp.task('watch', function() {\n\n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n\n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n\n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n\n});\n```\n\n我们通过`gulp.watch`API来监听文件的变化，然后执行相关的依赖任务。现在我们可以执行`$ gulp watch`命令来执行我们的`watch`任务，监听`.scss`、`.js`或者图片文件的变化执行相应的任务。\n\n**LiveReload任务**\n\n当我们代码修改的时候，Gulp也可以主动帮我们刷新页面，此时我们需要配置`LiveReload`服务，并修改我们的`watch`任务：\n\n```javascript\ngulp.task('watch', function() {\n\n  // Create LiveReload server\n  livereload.listen();\n\n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n\n});\n```\n\n要让这个任务生效，我们还需要安装并开启浏览器LiveReload插件，我们也可以[手动添加代码片段](http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-)。\n\n**整合这些任务**\n\n把上面的这些任务综合起来，就构成了一个完整的`gulpfile`:\n\n```javascript\n// gulpfile.js\n// Load plugins\nvar gulp = require('gulp'),\n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    minifycss = require('gulp-minify-css'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n \n// Styles\ngulp.task('styles', function() {\n  return gulp.src('src/styles/main.scss')\n    .pipe(sass({ style: 'expanded', }))\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(minifycss())\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(notify({ message: 'Styles task complete' }));\n});\n \n// Scripts\ngulp.task('scripts', function() {\n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n \n// Images\ngulp.task('images', function() {\n  return gulp.src('src/images/**/*')\n    .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))\n    .pipe(gulp.dest('dist/images'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n \n// Clean\ngulp.task('clean', function(cb) {\n    del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img'], cb)\n});\n \n// Default task\ngulp.task('default', ['clean'], function() {\n    gulp.start('styles', 'scripts', 'images');\n});\n \n// Watch\ngulp.task('watch', function() {\n \n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n \n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n \n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n \n  // Create LiveReload server\n  livereload.listen();\n \n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n \n});\n```\n\n如有任何问题，可以在下面评论。:)","html":"<p>是时候抛弃繁重的Grunt了。Gulp是一个直观的、配置的、基于流的任务发布系统，而且它更高效。</p>\n\n<p><img src=\"http://p1.bpimg.com/567571/0440708ae3690092.jpg\" alt=\"\" /></p>\n\n<p>为什么我会感兴趣呢？好问题。Gulp通过配置写代码不仅使得它编写任务简单，而且更加方便阅读和维护。</p>\n\n<p>Gulp运用node.js的流，这使得它构建任务很快，因为没有磁盘文件的读写操作，如果你想了解更多关于流的知识，你可以看看<a href=\"https://github.com/substack/stream-handbook\">这个</a>。Gulp允许你输入源文件，然后在一系列的管道插件中处理，最后输出，不像Grunt你需要为每个插件配置输入和输出。下面就让我们通过一个sass编译的例子来看看Gulp和Grunt的差异吧。</p>\n\n<p><strong>Grunt:</strong></p>\n\n<pre><code class=\"language-javascript\">sass: {  \n  dist: {\n    options: {\n      style: 'expanded'\n    },\n    files: {\n      'dist/assets/css/main.css': 'src/styles/main.scss',\n    }\n  }\n},\n\nautoprefixer: {  \n  dist: {\n    options: {\n      browsers: [\n        'last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'\n      ]\n    },\n    src: 'dist/assets/css/main.css',\n    dest: 'dist/assets/css/main.css'\n  }\n},\n\ngrunt.registerTask('styles', ['sass', 'autoprefixer']);  \n</code></pre>\n\n<p>Grunt要求每个插件配置要相互独立、要分别为每个插件配置输入源和输出路径。如，我们在sass插件里面配置了一个输入文件，然后保存输出。接着我们需要配置Autoprefixer的输入为Sass的输出，然后再输出了一个文件。让我们来看看Gulp是怎么做的：</p>\n\n<p><strong>Gulp:</strong></p>\n\n<pre><code class=\"language-javascript\">gulp.task('sass', function() {  \n  return gulp.src('src/styles/main.scss')\n    .pipe(sass({ style: 'compressed' }))\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/assets/css'))\n});\n</code></pre>\n\n<p>在Gulp中我们只配置一次输入文件，然后依次通过Sass插件处理，再传给<code>Autoprefixer</code>插件处理，然后我们得到输出文件。整个过程没有读取和写入不必要的文件，效率大大提高。</p>\n\n<p>因此，你感兴趣了么？让我们从安装Gulp，创建基本的任务配置文件<code>gulpfile</code>开始吧。</p>\n\n<p><strong>安装gulp</strong></p>\n\n<p>在我们开始配置任务之前，我们先要安装gulp:</p>\n\n<pre><code class=\"language-bash\">npm install gulp -g  \n</code></pre>\n\n<p>这样gulp就以全局的方式安装了，你可以在任何node命令行里面调用<code>gulp CLI</code>。然后我们需要在本地的某个项目里面使用<code>gulp</code>。使用<code>cd</code>命令进入到项目目录，运行下面的命令（先确保项目目录存在<code>package.json</code>文件）：</p>\n\n<pre><code class=\"language-bash\">npm install gulp --save-dev  \n</code></pre>\n\n<p>这会把gulp安装到本地项目，并且把依赖的包写入到<code>package.json</code>文件的<code>devDependencies</code>里面</p>\n\n<p><strong>安装gulp插件</strong></p>\n\n<p>我们将会安装下列插件来开始我们的任务：</p>\n\n<ul>\n<li>Sass 编译 (<a href=\"https://github.com/sindresorhus/gulp-ruby-sass\">gulp-ruby-sass</a>)</li>\n<li>添加浏览器前缀Autoprefixer(<a href=\"https://github.com/Metrime/gulp-autoprefixer\">gulp-autoprefixer</a>)</li>\n<li>CSS压缩（<a href=\"https://github.com/jonathanepollack/gulp-minify-css\">gulp-minify-css</a>）</li>\n<li>JS语法检查 (<a href=\"https://github.com/wearefractal/gulp-jshint\">gulp-jshint</a>)</li>\n<li>文件合并 (<a href=\"https://github.com/wearefractal/gulp-concat\">gulp-concat</a>)</li>\n<li>JS压Uglify (<a href=\"https://github.com/terinjokes/gulp-uglify\">gulp-uglify</a>)</li>\n<li>图片压缩(<a href=\"https://github.com/sindresorhus/gulp-imagemin\">gulp-imagemin</a>)</li>\n<li>LiveReload (<a href=\"https://github.com/vohof/gulp-livereload\">gulp-livereload</a>)</li>\n<li>图片缓存，只压缩修改过的图片(<a href=\"https://github.com/jgable/gulp-cache/\">gulp-cache</a>)</li>\n<li>修改提醒(<a href=\"https://github.com/mikaelbr/gulp-notify\">gulp-notify</a>)</li>\n<li>文件清理 (<a href=\"https://www.npmjs.org/package/del\">del</a>)</li>\n</ul>\n\n<p>运行下面的命令安装这些插件：</p>\n\n<pre><code class=\"language-bash\">npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev  \n</code></pre>\n\n<p>这将会安装所有的依赖插件，并写入到package.json的devDependencies里面。所有的gulp插件列表可以<a href=\"http://gratimax.net/search-gulp-plugins/\">在这里</a>看到。</p>\n\n<p><strong>加载插件</strong></p>\n\n<p>我们需要创建一个<code>gulpfile.js</code>，然后使用这些插件：</p>\n\n<pre><code class=\"language-javascript\">var gulp = require('gulp'),  \n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    minifycss = require('gulp-minify-css'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n</code></pre>\n\n<p>我们也可以像grunt那样自动加载插件：<a href=\"https://github.com/jackfranklin/gulp-load-plugins\">auto load</a></p>\n\n<p><strong>创建任务</strong></p>\n\n<p><em>编译sass、加前缀、压缩</em></p>\n\n<pre><code class=\"language-javascript\">gulp.task('styles', function() {  \n  return gulp.src('src/styles/main.scss')\n    .pipe(sass({ style: 'expanded' }))\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(minifycss())\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(notify({ message: '样式任务完成' }));\n});\n</code></pre>\n\n<blockquote>\n  <p>sass({ style: 'expanded' }：编译后保留原格式</p>\n</blockquote>\n\n<pre><code class=\"language-javascript\">gulp.task('styles', function() { ... )};  \n</code></pre>\n\n<p><code>gulp.task</code>API是用来创建任务的。然后通过命令<code>gulp styles</code>运行这个任务。</p>\n\n<pre><code class=\"language-javascript\">return gulp.src('src/styles/main.scss')  \n</code></pre>\n\n<p><code>gulp.src</code>API用来配置输入的源文件。也可以用模式匹配，如<code>/**/*.scss</code>匹配所有文件夹下面后缀为<code>.scss</code>的文件作为输入。通过返回流使得它是异步的，确保在提醒任务完成的时候任务是完成了的。</p>\n\n<pre><code class=\"language-javascript\">.pipe(sass({ style: 'expanded' }))\n</code></pre>\n\n<p>通过<code>.pipe()</code>把源文件流入一个插件的管道中。然后我们可以去插件的官网看看这个插件的详细用法。</p>\n\n<pre><code class=\"language-javascript\">.pipe(gulp.dest('dist/assets/css'));\n</code></pre>\n\n<p><code>gulp.dest</code>API是用来告知输出文件的路径的。一个任务可以有多个输出，如一个用来输出原来的版本（即源文件），一个输出处理后的版本（即输出文件）。你可以在上面的<code>styles</code>任务中看到。</p>\n\n<p>建议去看<a href=\"https://github.com/gulpjs/gulp/blob/master/docs/API.md\">gulp api文档</a>，这样会更加清楚。</p>\n\n<p><strong>js语法检查、合并和压缩任务</strong></p>\n\n<pre><code class=\"language-javascript\">gulp.task('scripts', function() {  \n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/assets/js'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n</code></pre>\n\n<p>这里用的<code>JSHin</code>t插件，我们使用了默认的<code>JSHint Reporter</code>，可能适用于大多数人，想了解更多可以去<a href=\"http://www.jshint.com/docs/reporters/\">jshint官网</a>看</p>\n\n<p><strong>图片压缩任务</strong></p>\n\n<pre><code class=\"language-javascript\">gulp.task('images', function() {  \n  return gulp.src('src/images/**/*')\n    .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n    .pipe(gulp.dest('dist/assets/img'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n</code></pre>\n\n<p>这里我们只用了<code>imagemin</code>插件，但是可以做的更好，我们可以缓存修改过的图片，或者只对修改过的图片进行再次的压缩操作，因此我们可以使用<a href=\"https://github.com/jgable/gulp-cache\">gulp-cahce</a>插件，因此我们需要将这行代码：</p>\n\n<pre><code class=\"language-javascript\">.pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))\n</code></pre>\n\n<p>改成：レ`人</p>\n\n<p><pre><code class=\"language-javascript\">gulp.task('styles', function() {  \n  return gulp.src('src/styles/main.scss')\n    .pipe(sass({ style: 'expanded' }))\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(rename({suffix: '.min'}))\n    .pipe(minifycss())\n    .pipe(gulp.dest('dist/assets/css'))\n    .pipe(notify({ message: '样式任务完成' }));\n});\n</code></pre></p>\n\n<p>此时，只有新的图片或者改变过的图片才会被压缩。</p>\n\n<p><strong>文件清理</strong></p>\n\n<p>在再次发布之前，我们最好把目标文件的文件先清理掉，然后重新构建：</p>\n\n<p><pre><code class=\"language-javascript\">gulp.task('styles', function() { ... )};  \n</code></pre></p>\n\n<p><strong>默认任务</strong></p>\n\n<p>我们可以通过<code>$ gulp</code>启动默认任务，然后在默认任务中调用其他任务：</p>\n\n<p><code>gulp.task</code></p>\n\n<p>看到<code>gulp.task</code>里面的数组了吧？这里定义了任务的依赖，也就是说<code>default</code>任务依赖<code>clean</code>任务。在这个例子中，执行<code>gulp.start</code>之前会先运行<code>clean</code>任务。Gulp里面的任务同时进行，没有明确的顺序哪个先完成，所以我们要确保<code>clean</code>任务执行完之后再执行<code>gulp.start</code>里面的任务。</p>\n\n<blockquote>\n  <p>虽然不建议在执行依赖任务数组的时候使用<code>gulp.start</code>，但是在这里我们没有办法确保<code>clean</code>任务执行完毕后再执行其它任务，因此这里使用<code>gulp.start</code>貌似是最好的选择。</p>\n</blockquote>\n\n<p><strong>Watch任务</strong></p>\n\n<p>当文件发生变化的时候，我们可能需要重新执行任务，因此我们需要配置一个监听文件变化的任务：</p>\n\n<p><code>gulp styles</code></p>\n\n<p>我们通过<code>gulp.watch</code>API来监听文件的变化，然后执行相关的依赖任务。现在我们可以执行<code>$ gulp watch</code>命令来执行我们的<code>watch</code>任务，监听<code>.scss</code>、<code>.js</code>或者图片文件的变化执行相应的任务。</p>\n\n<p><strong>LiveReload任务</strong></p>\n\n<p>当我们代码修改的时候，Gulp也可以主动帮我们刷新页面，此时我们需要配置<code>LiveReload</code>服务，并修改我们的<code>watch</code>任务：</p>\n\n<p><pre><code class=\"language-javascript\">return gulp.src('src/styles/main.scss')  \n</code></pre></p>\n\n<p>要让这个任务生效，我们还需要安装并开启浏览器LiveReload插件，我们也可以<a href=\"http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-\">手动添加代码片段</a>。</p>\n\n<p><strong>整合这些任务</strong></p>\n\n<p>把上面的这些任务综合起来，就构成了一个完整的<code>gulpfile</code>:</p>\n\n<pre><code class=\"language-javascript\">// gulpfile.js\n// Load plugins\nvar gulp = require('gulp'),  \n    sass = require('gulp-ruby-sass'),\n    autoprefixer = require('gulp-autoprefixer'),\n    minifycss = require('gulp-minify-css'),\n    jshint = require('gulp-jshint'),\n    uglify = require('gulp-uglify'),\n    imagemin = require('gulp-imagemin'),\n    rename = require('gulp-rename'),\n    concat = require('gulp-concat'),\n    notify = require('gulp-notify'),\n    cache = require('gulp-cache'),\n    livereload = require('gulp-livereload'),\n    del = require('del');\n\n// Styles\ngulp.task('styles', function() {  \n  return gulp.src('src/styles/main.scss')\n    .pipe(sass({ style: 'expanded', }))\n    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(minifycss())\n    .pipe(gulp.dest('dist/styles'))\n    .pipe(notify({ message: 'Styles task complete' }));\n});\n\n// Scripts\ngulp.task('scripts', function() {  \n  return gulp.src('src/scripts/**/*.js')\n    .pipe(jshint('.jshintrc'))\n    .pipe(jshint.reporter('default'))\n    .pipe(concat('main.js'))\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(rename({ suffix: '.min' }))\n    .pipe(uglify())\n    .pipe(gulp.dest('dist/scripts'))\n    .pipe(notify({ message: 'Scripts task complete' }));\n});\n\n// Images\ngulp.task('images', function() {  \n  return gulp.src('src/images/**/*')\n    .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))\n    .pipe(gulp.dest('dist/images'))\n    .pipe(notify({ message: 'Images task complete' }));\n});\n\n// Clean\ngulp.task('clean', function(cb) {  \n    del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img'], cb)\n});\n\n// Default task\ngulp.task('default', ['clean'], function() {  \n    gulp.start('styles', 'scripts', 'images');\n});\n\n// Watch\ngulp.task('watch', function() {\n\n  // Watch .scss files\n  gulp.watch('src/styles/**/*.scss', ['styles']);\n\n  // Watch .js files\n  gulp.watch('src/scripts/**/*.js', ['scripts']);\n\n  // Watch image files\n  gulp.watch('src/images/**/*', ['images']);\n\n  // Create LiveReload server\n  livereload.listen();\n\n  // Watch any files in dist/, reload on change\n  gulp.watch(['dist/**']).on('change', livereload.changed);\n\n});\n</code></pre>\n\n<p>如有任何问题，可以在下面评论。:)</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495699954510,"created_by":1,"updated_at":1495700006266,"updated_by":1,"published_at":1475645040000,"published_by":1},{"id":18,"uuid":"6c6557ac-1c43-4dea-8d63-f2c2d6001800","title":"极路由Shadowsocks家庭无痛翻墙插件","slug":"hiwifi-ss","markdown":"\n## 1、准备工作\n* ①. 首先你得有一台极路由，型号随意，要求系统版本必须低于``1.0``，否则安装会出错。\n* ②. 然后你得有一个Shadowsocks帐号，可以自己在服务器上搭建，也可以购买，我这里不提供、也不出售。\n* ③. 然后需要开启开发者权限，具体请参考官方的《[开发者模式功能开放公告](http://bbs.hiwifi.com/thread-74899-1-1.html)》。\n<!--more-->\n\n## 2、安装SS\n* ①. 使用putty连接路由器：[下载地址](http://pan.baidu.com/s/1jGivsOm)\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1af3br9sfect8rckt56l6hg5a.png)\n点击open,会出现命令框：\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1af3bs0itgv05361e7u10h71rb4a.png)\n提示使用`root帐号`连接路由，密码是你的后台登陆密码。\n* ②. 输入安装SS命令，按回车键： \n``cd /tmp && curl -k -o 01.sh http://mytv-10005639.file.myqcloud.com/01.sh && sh 01.sh && rm 01.sh``\n\n## 3、配置SS\n* ①. 登陆极路由后台开启Shadowsocks插件:\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1af3c0jfl1afp1ehd19m713c58baa.jpg)\n* ②. 在表单中填写你的SS帐号密码和加密方式，选择智能模式，保存，只要提示``运行中 已加速``就表示已经成功连上SS了。\n\n#### 注意：\n* ①.请关闭极路由的`自动更新`功能，要不每次路由器升级后，会删除SS插件。\n* ②.若Shadowsocks选项显示的是：``{ \"msg\": \"请求的接口不存在.\", \"code\": 560 }``,请重启路由器。\n这个时候，连接极路由的所有设备，理论上都可以无痛翻墙了。\n\n## 4、更新gfwlist列表\n* ①. SSH登录极路由：``ssh root@192.168.199.1 -p 1022`` 使用root帐号连接路由，端口为1022，密码为后台登陆密码。\n* ②. 输入更新命令，按回车键：``cd /etc/gw-redsocks/gw-shadowsocks && wget http://mytv-10005639.file.myqcloud.com/gfwlist.txt && cat gfwlist.txt >> gw-shadowsocks.dnslist && /etc/init.d/dnsmasq restart``","html":"<h2 id=\"1\">1、准备工作</h2>\n\n<ul>\n<li>①. 首先你得有一台极路由，型号随意，要求系统版本必须低于<code>1.0</code>，否则安装会出错。</li>\n<li>②. 然后你得有一个Shadowsocks帐号，可以自己在服务器上搭建，也可以购买，我这里不提供、也不出售。</li>\n<li>③. 然后需要开启开发者权限，具体请参考官方的《<a href=\"http://bbs.hiwifi.com/thread-74899-1-1.html\">开发者模式功能开放公告</a>》。\n<!--more--></li>\n</ul>\n\n<h2 id=\"2ss\">2、安装SS</h2>\n\n<ul>\n<li>①. 使用putty连接路由器：<a href=\"http://pan.baidu.com/s/1jGivsOm\">下载地址</a>\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1af3br9sfect8rckt56l6hg5a.png\" alt=\"\" />\n点击open,会出现命令框：\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1af3bs0itgv05361e7u10h71rb4a.png\" alt=\"\" />\n提示使用<code>root帐号</code>连接路由，密码是你的后台登陆密码。</li>\n<li>②. 输入安装SS命令，按回车键： \n<code>cd /tmp &amp;&amp; curl -k -o 01.sh http://mytv-10005639.file.myqcloud.com/01.sh &amp;&amp; sh 01.sh &amp;&amp; rm 01.sh</code></li>\n</ul>\n\n<h2 id=\"3ss\">3、配置SS</h2>\n\n<ul>\n<li>①. 登陆极路由后台开启Shadowsocks插件:\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1af3c0jfl1afp1ehd19m713c58baa.jpg\" alt=\"\" /></li>\n<li>②. 在表单中填写你的SS帐号密码和加密方式，选择智能模式，保存，只要提示<code>运行中 已加速</code>就表示已经成功连上SS了。</li>\n</ul>\n\n<h4 id=\"\">注意：</h4>\n\n<ul>\n<li>①.请关闭极路由的<code>自动更新</code>功能，要不每次路由器升级后，会删除SS插件。</li>\n<li>②.若Shadowsocks选项显示的是：<code>{ \"msg\": \"请求的接口不存在.\", \"code\": 560 }</code>,请重启路由器。\n这个时候，连接极路由的所有设备，理论上都可以无痛翻墙了。</li>\n</ul>\n\n<h2 id=\"4gfwlist\">4、更新gfwlist列表</h2>\n\n<ul>\n<li>①. SSH登录极路由：<code>ssh root@192.168.199.1 -p 1022</code> 使用root帐号连接路由，端口为1022，密码为后台登陆密码。</li>\n<li>②. 输入更新命令，按回车键：<code>cd /etc/gw-redsocks/gw-shadowsocks &amp;&amp; wget http://mytv-10005639.file.myqcloud.com/gfwlist.txt &amp;&amp; cat gfwlist.txt &gt;&gt; gw-shadowsocks.dnslist &amp;&amp; /etc/init.d/dnsmasq restart</code></li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495700379488,"created_by":1,"updated_at":1495700430953,"updated_by":1,"published_at":1472710740000,"published_by":1},{"id":19,"uuid":"12f014a0-f53b-4213-9a82-ca4d4bff4f0f","title":"JavaScript ES6核心特性概述","slug":"javascript-es6","markdown":"JavaScript在过去几年里发生了很大的变化。这里有12个新功能，您可以学习使用它们！\n\n![](http://css88.b0.upaiyun.com/css88/2016/10/es6-core-features-overview-large.png)\n## JavaScript历史\n\n新增加的语言称为ECMAScript 6。它也称为ES6或ES2015 +。\n\n自从 1995年提出的JavaScript构想以来，发展进展非常缓慢。每隔几年新增一次。1997年以来 ECMAScript 一直作为JavaScript实现的基础，引导JavaScript 发展。它已经发布了好几个版本，如ES3，ES5，ES6等。\n\n> ECMAScript与JavaScript的关系：\n\n> ECMA-262标准的描述如下：“ ECMAScript 可以为不同种类的宿主环境提供核心的脚本编程能力，因此核心的脚本语言时与任何特定的宿主环境分开进行规定的。”简单地说，ECMAScript描述了以下内容：语法、类型、语句、关键字、保留字、运算符、对象等。\n\n> ECMAScript是JavaScript的一个重要标准，但它并不是JavaScript唯一的部分，当然，也不是唯一被标准化的部分。比如在WEB前端开发中，Web浏览器对于ECMAScript来说是一个宿主环境，但它并不是唯一的宿主环境。事实上，还有不计其数的其他各种环境(例如目前很火的Node.js\n)。一个完整的JavaScript实现是由以下3个不同部分组成的：核心(ECMAScript)、文档对象模型(DOM)、浏览器对象模型(BOM)。\n\n> 正如你所看到的，ES3，ES5和ES6之间分别存在10年和6年的时间间隔。目前ECMAScript发展的新模式是每年进行少量变更。而不是像ES6一样做大量的更改。\n\n## 浏览器支持\n\n![](http://css88.b0.upaiyun.com/css88/2016/10/es6-javascript-support.png)\n\n所有现代浏览器和环境都已经支持ES6了！Chrome，MS Edge，Firefox，Safari，Node等等已经内置支持JavaScript ES6的大部分功能。所以，你在本教程中学到的一切，你可以立即开始使用它。\n\n让我们开始使用 ECMAScript 6 吧！\n\n## 核心ES6特性\n\n变量的块作用域\n\n在过去声明变量使用 var，而在ES6中，声明变量还可以使用 let / const。\n\nvar 有什么问题？\n\nvar 的问题是变量会被泄漏到其他代码块，例如 for 循环或 if 代码块。\n```js\nES5 代码:\nvar x = 'outer';\nfunction test(inner) {\n  if (inner) {\n    var x = 'inner'; // 作用域是整个function\n    return x;\n  }\n  return x; //被重新定义，因为第4行声明被提升\n}\ntest(false); // undefined \ntest(true); // inner\n```\n上面代码中，对于test(false) 你可能期望的是返回 outer, 但是不是, 你得到的是 undefined。\n\n为什么?\n\n因为即使 if 代码块没有被执行，第4行中的表达式var x也是被提升的。\n\n> var 变量提升\n\n> var是函数作用域。它在整个函数中是可用的，甚至在被声明之前。\n> 初始化 不 提升。如果你使用var ，请总是在顶部声明你的变量。\n> 应用提升规则后我们可以更好地了解发生了什么：\n```js\nES5 代码:\nvar x = 'outer';\nfunction test(inner) {\n  var x; // 提升声明\n  if (inner) {\n    x = 'inner'; // 初始化不提升\n    return x;\n  }\n  return x;\n}\n```\n用ECMAScript 6 来拯救：\n```js\nES6 代码:\nlet x = 'outer';\nfunction test(inner) {\n  if (inner) {\n    let x = 'inner';\n    return x;\n  }\n  return x; // 从第1行获得预期结果\n}\ntest(false); // outer\ntest(true); // inner\n```\n从var改用 let,使代码按你设想的那样执行。 if 代码块没有被执行，变量x不会从if 代码块中被提升。\n\nlet 提升 和 “暂时性死区”\n\n在ES6中，let将把变量提升到代码块的顶部（不是像ES5那样的函数顶部）。\n但是，代码块中，在变量声明之前引用这个变量会导致一个 ReferenceError 错误。\nlet是块作用域。在声明之前不能使用它。\n“暂时性死区”是指从代码块开始直到变量被声明的区域。\n## IIFE\n\n在解释LIFE之前，让我们举个例子。 看看这里：\n```js\nES5 代码:\n{\n  var private = 1;\n}\nconsole.log(private); // 1\n```\n正如你所看到的，变量private 被泄漏到了代码块外面。你需要使用IIFE（immediately-invoked function expression，即：立即调用函数表达式）来包含它：\n```js\nES5 代码:\n(function(){\n  var private2 = 1;\n})();\nconsole.log(private2); // 未捕获 ReferenceError\n```\n如果你看看jQuery / lodash或其他开源项目，您将注意到他们使用IIFE以避免污染全局环境并只是在全局定义，如 _，$ 或 jQuery 。\n\n在ES6中更干净，如果我们只是现在某个代码块中使用使用某个变量，我们可以使用let，再也不需要使用IIFE了：\n```js\nES6 代码:\n{\n  let private3 = 1;\n}\nconsole.log(private3); // 未捕获 ReferenceError\n```\n## Const\n\n如果你想要一个变量一直不改变，你也可以使用 const。\n\n![](http://css88.b0.upaiyun.com/css88/2016/10/javascript-es6-const-variables-example.png)\n\n底线：var 区分 let 和 const。\n\n对于所有引用使用const; 避免使用var。\n如果你必须重新分配引用（愚人码头注：变量需要重新赋值的），使用let而不是const。\n\n## 模板字面量(Template Literals)\n\n当我们有了模板字面量，我们就不需要做更多的嵌套连接。看一看：\n```js\nES5 代码:\nvar first = 'Adrian';\nvar last = 'Mejia';\nconsole.log('Your name is ' + first + ' ' + last + '.');\n```\n现在你可以使用反引号 ( ` ` ) 和插值字符串 ${};\n```js\nES6 代码:\nconst first = 'Adrian';\nconst last = 'Mejia';\nconsole.log(`Your name is ${first} ${last}.`);\n```\nES6的模板字面量没有转义、循环、条件判断等内置语法，感觉功能还很弱。\n\n## 多行字符串\n\n我们不必在连接字符串时需要加 \\n，就像这样：\n```js\nES5 代码:\nvar template = '<li *ngFor=\"let todo of todos\" [ngClass]=\"{completed: todo.isDone}\" >\\n' +\n'  <div class=\"view\">\\n' +\n'    <input class=\"toggle\" type=\"checkbox\" [checked]=\"todo.isDone\">\\n' +\n'    <label></label>\\n' +\n'    <button class=\"destroy\"></button>\\n' +\n'  </div>\\n' +\n'  <input class=\"edit\" value=\"\">\\n' +\n'</li>';\nconsole.log(template);\n```\n在ES6中，我们可以再次使用反引号来解决这个问题：\n```js\nES6 代码:\nconst template = `<li *ngFor=\"let todo of todos\" [ngClass]=\"{completed: todo.isDone}\" >\n  <div class=\"view\">\n    <input class=\"toggle\" type=\"checkbox\" [checked]=\"todo.isDone\">\n    <label></label>\n    <button class=\"destroy\"></button>\n  </div>\n  <input class=\"edit\" value=\"\">\n</li>`;\nconsole.log(template);\n```\n这两段代码将等到完全相同的结果。\n\n## 解构分配\n\nES6解构非常有用和简洁。 按照这个例子：\n\n从数组中获取元素\n```js\nES5 代码:\nvar array = [1, 2, 3, 4];\nvar first = array[0];\nvar third = array[2];\nconsole.log(first, third); // 1 3\n```\n等价于：\n```js\nES6 代码:\nconst array = [1, 2, 3, 4];\nconst [first, ,third] = array;\nconsole.log(first, third); // 1 3\n```\n交换值\n```js\nES5 代码:\nvar a = 1;\nvar b = 2;\nvar tmp = a;\na = b;\nb = tmp;\nconsole.log(a, b); // 2 1\n```\n等价于：\n```js\nES6 代码:\nlet a = 1;\nlet b = 2;\n[a, b] = [b, a];\nconsole.log(a, b); // 2 1\n```\n多个返回值的解构\n```js\nES5 代码:\nfunction margin() {\n  var left=1, right=2, top=3, bottom=4;\n  return { left: left, right: right, top: top, bottom: bottom };\n}\nvar data = margin();\nvar left = data.left;\nvar bottom = data.bottom;\nconsole.log(left, bottom); // 1 4\n```\n在第3行，你也可以在一个数组中返回它像这样（并保存一些类型）：\n```js\njs 代码:\nreturn [left, right, top, bottom];\n```\n但是调用者需要顾及到返回数据的顺序。\n```js\njs 代码:\nvar left = data[0];\nvar bottom = data[3];\n```\n使用ES6，调用者只需要选择他们需要的数据（第6行）：\n```js\nES6 代码:\nfunction margin() {\n  const left=1, right=2, top=3, bottom=4;\n  return { left, right, top, bottom };\n}\nconst { left, bottom } = margin();\nconsole.log(left, bottom); // 1 4\n```\n注意：第3行，我们可以看到ES6的一些其他特性。我们可以压缩{left：left}为{left}。看看它比 ES5 简洁了很多。是不是很酷？\n\n## 参数匹配的解构\n```js\nES5 代码:\nvar user = {firstName: 'Adrian', lastName: 'Mejia'};\nfunction getFullName(user) {\n  var firstName = user.firstName;\n  var lastName = user.lastName;\n  return firstName + ' ' + lastName;\n}\nconsole.log(getFullName(user)); // Adrian Mejia\n```\n等价于：\n```js\nES6 代码:\nconst user = {firstName: 'Adrian', lastName: 'Mejia'};\nfunction getFullName({ firstName, lastName }) {\n  return `${firstName} ${lastName}`;\n}\nconsole.log(getFullName(user)); // Adrian Mejia\n```\n## 深度匹配\n```js\nES5 代码:\nfunction settings() {\n  return { display: { color: 'red' }, keyboard: { layout: 'querty'} };\n}\nvar tmp = settings();\nvar displayColor = tmp.display.color;\nvar keyboardLayout = tmp.keyboard.layout;\nconsole.log(displayColor, keyboardLayout); // red querty\n```\n等价于：\n```js\nES6 代码:\nfunction settings() {\n  return { display: { color: 'red' }, keyboard: { layout: 'querty'} };\n}\nconst { display: { color: displayColor }, keyboard: { layout: keyboardLayout }} = settings();\nconsole.log(displayColor, keyboardLayout); // red querty\n```\n这也称为对象解构。\n\n正如你所看到的，解构是非常有用的，并鼓励良好的编码风格。\n\n最佳实践：\n\n使用数组解构来获取元素或交换变量。它可以避免创建临时引用。\n对于函数多个返回值不要使用数组解构，而使用对象解构。\n\n## 类与对象\n\n使用ECMAScript 6，我们可以从“构造函数”过渡到“类”。\n\n在JavaScript中每一个对象都有一个原型，这是另一个对象。所有JavaScript对象继承了它们原型中的方法和属性。\n\n在ES5中，我们面向对象编程（OOP）需要使用构造函数来创建对象，如下：\n```js\nES5 代码:\nvar Animal = (function () {\n  function MyConstructor(name) {\n    this.name = name;\n  }\n  MyConstructor.prototype.speak = function speak() {\n    console.log(this.name + ' makes a noise.');\n  };\n  return MyConstructor;\n})();\nvar animal = new Animal('animal');\nanimal.speak(); // animal makes a noise.\n```\n在ES6中，我们有一些语法糖。我们可以用较少的板式代码，以及class和constructor等新的关键字做同样的事情。\n另外，请注意我们如何清楚地定义方法constructor.prototype.speak = function () vs speak()：\n```js\nES6 代码:\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak() {\n    console.log(this.name + ' makes a noise.');\n  }\n}\nconst animal = new Animal('animal');\nanimal.speak(); // animal makes a noise.\n```\n正如你所看到的，两种样式（ES5/6）在幕后产生相同的结果，并且可以以相同的方式使用。\n\n最佳实践：\n\n始终使用class语法，并避免直接操作 prototype。为什么？因为它使代码更简洁和更容易理解。\n避免使用空的构造函数。如果没有指定，类有一个默认构造函数。\n\n## 继承\n\n基于前面的Animal类。假设我们想要扩展它并定义Lion类。\n\n在ES5中，它更多地涉及原型继承。\n```js\nES5 代码:\nvar Lion = (function () {\n  function MyConstructor(name){\n    Animal.call(this, name);\n  }\n \n  // prototypal inheritance\n  MyConstructor.prototype = Object.create(Animal.prototype);\n  MyConstructor.prototype.constructor = Animal;\n \n  MyConstructor.prototype.speak = function speak() {\n    Animal.prototype.speak.call(this);\n    console.log(this.name + ' roars ');\n  };\n  return MyConstructor;\n})();\nvar lion = new Lion('Simba');\nlion.speak(); // Simba makes a noise.\n// Simba roars.\n```\n我不详细描述所有细节，但请注意：\n\n* 第3行，我们用参数显式调用Animal构造函数。\n* 第7-8行，我们将Lion原型分配给Animal原型。\n* 第11行，我们从父类Animal中调用speak方法。\n* 在ES6中，我们有2个新的关键字extends和super。\n```js\nES6 代码:\nclass Lion extends Animal {\n  speak() {\n    super.speak();\n    console.log(this.name + ' roars ');\n  }\n}\nconst lion = new Lion('Simba');\nlion.speak(); // Simba makes a noise.\n// Simba roars.\n```\n看看ES6的代码比ES5看起来清晰了很多，并且他们做的事情完全一样。\n\n最佳实践：\n\n使用extends内置继承方式来实现继承。\n\n## 原生的 Promises\n\n从回调地狱 到 promises\n```js\nES5 代码:\nfunction printAfterTimeout(string, timeout, done){\n  setTimeout(function(){\n    done(string);\n  }, timeout);\n}\nprintAfterTimeout('Hello ', 2e3, function(result){\n  console.log(result);\n  // nested callback\n  printAfterTimeout(result + 'Reader', 2e3, function(result){\n    console.log(result);\n  });\n});\n```\n我们有一个函数接收一个回调，当done时执行。我们必须一个接一个地两度执行它。这就是为什么我们在回调中第二次调用printAfterTimeout的原因。\n\n如果你需要第3或第4次回调，那么你很快就凌乱了。让我们看看我们如何使用promises：\n```js\nES6 代码:\nfunction printAfterTimeout(string, timeout){\n  return new Promise((resolve, reject) => {\n    setTimeout(function(){\n      resolve(string);\n    }, timeout);\n  });\n}\nprintAfterTimeout('Hello ', 2e3).then((result) => {\n  console.log(result);\n  return printAfterTimeout(result + 'Reader', 2e3);\n}).then((result) => {\n  console.log(result);\n});\n```\n正如你说看到的，使用 promises，我们可以使用then在一个函数完成后做另一些事情。不再需要嵌套函数。\n\n## 箭头函数\n\nES6没有删除函数表达式，但它添加了一个新的函数表达式，称为箭头函数。\n\n在ES5中，对于this我们有一些疑问：\n```js\nES5 代码:\nvar _this = this; // 需要保持一个引用\n$('.btn').click(function(event){\n  _this.sendData(); // 引用函数外层的 this\n});\n$('.input').on('change',function(event){\n  this.sendData(); // 引用函数外层的 this\n}.bind(this)); // 绑定函数外层的 this\n```\n你需要使用一个临时的 this ，以便在函数内部引用，或使用bind。在ES6中，可以使用箭头函数！\n```js\nES6 代码:\n// this 将引用外部的那个 this\n$('.btn').click((event) =>  this.sendData());\n// 隐式返回\nconst ids = [291, 288, 984];\nconst messages = ids.map(value => `ID is ${value}`);\n```\n## For…of\n\n从 for 到 forEach 再到 for...of:\n```js\nES5 代码:\n// for\nvar array = ['a', 'b', 'c', 'd'];\nfor (var i = 0; i < array.length; i++) {\n  var element = array[i];\n  console.log(element);\n}\n// forEach\narray.forEach(function (element) {\n  console.log(element);\n});\n```\nES6 的 for...of 同样允许我们迭代。\n```js\nES6 代码:\n// for ...of\nconst array = ['a', 'b', 'c', 'd'];\nfor (const element of array) {\n    console.log(element);\n}\n```\n## 默认参数\n\n从检查变量是否被定义 到 分配一个值给默认参数。你以前做过类似的事情吗？\n```js\nES5 代码:\nfunction point(x, y, isFlag){\n  x = x || 0;\n  y = y || -1;\n  isFlag = isFlag || true;\n  console.log(x,y, isFlag);\n}\npoint(0, 0) // 0 -1 true \npoint(0, 0, false) // 0 -1 true \npoint(1) // 1 -1 true\npoint() // 0 -1 true\n```\n肯定这些做过吧？这是一个常见的模式来检查是变量是否赋值，否则分配一个默认值。但是，注意有一些问题：\n* 第7行，我们传递0, 0，得到0, -1。\n* 第8行，我们传递false，但得到true。\n如果你将一个布尔值作为默认参数或将值设置为0，它就不正常工作了。你知道为什么吗？？？我将在ES6示例后面告诉你;）\n\n现在，如果你用ES6，可以用更少的代码做的更好！\n```js\nES6 代码:\nfunction point(x = 0, y = -1, isFlag = true){\n  console.log(x,y, isFlag);\n}\npoint(0, 0) // 0 0 true\npoint(0, 0, false) // 0 0 false\npoint(1) // 1 -1 true\npoint() // 0 -1 true\n```\n注意第4行和第5行， 我们得到了预期的结果。ES5的示例则没有正常工作。我们必须属性检查  undefined,因为false，null，undefined和0是假（falsy）值。我们需要更加多的代码来修复这个问题：\n```js\nES5 代码:\nfunction point(x, y, isFlag){\n  x = x || 0;\n  y = typeof(y) === 'undefined' ? -1 : y;\n  isFlag = typeof(isFlag) === 'undefined' ? true : isFlag;\n  console.log(x,y, isFlag);\n}\npoint(0, 0) // 0 0 true\npoint(0, 0, false) // 0 0 false\npoint(1) // 1 -1 true\npoint() // 0 -1 true\n```\n我们检查 undefined，现在它就能按预期工作了。\n\n## Rest参数（多余参数）\n\n从 arguments 到 rest参数 和 扩展运算符。\n\n在ES5中，获取任意数量的参数是非常麻烦的：\n```js\nES5 代码:\nfunction printf(format) {\n  var params = [].slice.call(arguments, 1);\n  console.log('params: ', params);\n  console.log('format: ', format);\n}\nprintf('%s %d %.2f', 'adrian', 321, Math.PI);\n```\n我们可以使用rest运算符...做同样的事情。\n```js\nES6 代码:\nfunction printf(format, ...params) {\n  console.log('params: ', params);\n  console.log('format: ', format);\n}\nprintf('%s %d %.2f', 'adrian', 321, Math.PI);\n```\n## 扩展运算符\n\n从apply()到扩展运算符，我们有 ... 拯救：\n\n提醒：我们使用apply() 将数组转换为一个参数列表。例如，Math.max()获取参数列表，但是如果我们有一个数组，我们可以使用apply来使它工作。\n\n![](http://css88.b0.upaiyun.com/css88/2016/10/javascript-math-apply-arrays.png)\n\n正如我们在前面看到的，我们可以使用apply将数组作为参数列表传递：\n```js\nES5 代码:\nMath.max.apply(Math, [2,100,1,6,43]) // 100\n```\n在ES6中，你可以使用 扩展运算符。\n```js\nES6 代码:\nMath.max(...[2,100,1,6,43]) // 100\n```\n另外，我们可以使用扩展运算符来 concat（合并）数组：\n```js\nES5 代码:\nvar array1 = [2,100,1,6,43];\nvar array2 = ['a', 'b', 'c', 'd'];\nvar array3 = [false, true, null, undefined];\nconsole.log(array1.concat(array2, array3));\n```\n在ES6中，可以使用扩展运算符合并数组：\n```js\nES6 代码:\nconst array1 = [2,100,1,6,43];\nconst array2 = ['a', 'b', 'c', 'd'];\nconst array3 = [false, true, null, undefined];\nconsole.log([...array1, ...array2, ...array3]);\n```","html":"<p>JavaScript在过去几年里发生了很大的变化。这里有12个新功能，您可以学习使用它们！</p>\n\n<p><img src=\"http://css88.b0.upaiyun.com/css88/2016/10/es6-core-features-overview-large.png\" alt=\"\" /></p>\n\n<h2 id=\"javascript\">JavaScript历史</h2>\n\n<p>新增加的语言称为ECMAScript 6。它也称为ES6或ES2015 +。</p>\n\n<p>自从 1995年提出的JavaScript构想以来，发展进展非常缓慢。每隔几年新增一次。1997年以来 ECMAScript 一直作为JavaScript实现的基础，引导JavaScript 发展。它已经发布了好几个版本，如ES3，ES5，ES6等。</p>\n\n<blockquote>\n  <p>ECMAScript与JavaScript的关系：</p>\n  \n  <p>ECMA-262标准的描述如下：“ ECMAScript 可以为不同种类的宿主环境提供核心的脚本编程能力，因此核心的脚本语言时与任何特定的宿主环境分开进行规定的。”简单地说，ECMAScript描述了以下内容：语法、类型、语句、关键字、保留字、运算符、对象等。</p>\n  \n  <p>ECMAScript是JavaScript的一个重要标准，但它并不是JavaScript唯一的部分，当然，也不是唯一被标准化的部分。比如在WEB前端开发中，Web浏览器对于ECMAScript来说是一个宿主环境，但它并不是唯一的宿主环境。事实上，还有不计其数的其他各种环境(例如目前很火的Node.js\n  )。一个完整的JavaScript实现是由以下3个不同部分组成的：核心(ECMAScript)、文档对象模型(DOM)、浏览器对象模型(BOM)。</p>\n  \n  <p>正如你所看到的，ES3，ES5和ES6之间分别存在10年和6年的时间间隔。目前ECMAScript发展的新模式是每年进行少量变更。而不是像ES6一样做大量的更改。</p>\n</blockquote>\n\n<h2 id=\"\">浏览器支持</h2>\n\n<p><img src=\"http://css88.b0.upaiyun.com/css88/2016/10/es6-javascript-support.png\" alt=\"\" /></p>\n\n<p>所有现代浏览器和环境都已经支持ES6了！Chrome，MS Edge，Firefox，Safari，Node等等已经内置支持JavaScript ES6的大部分功能。所以，你在本教程中学到的一切，你可以立即开始使用它。</p>\n\n<p>让我们开始使用 ECMAScript 6 吧！</p>\n\n<h2 id=\"es6\">核心ES6特性</h2>\n\n<p>变量的块作用域</p>\n\n<p>在过去声明变量使用 var，而在ES6中，声明变量还可以使用 let / const。</p>\n\n<p>var 有什么问题？</p>\n\n<p>var 的问题是变量会被泄漏到其他代码块，例如 for 循环或 if 代码块。  </p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar x = 'outer';  \nfunction test(inner) {  \n  if (inner) {\n    var x = 'inner'; // 作用域是整个function\n    return x;\n  }\n  return x; //被重新定义，因为第4行声明被提升\n}\ntest(false); // undefined  \ntest(true); // inner  \n</code></pre>\n\n<p>上面代码中，对于test(false) 你可能期望的是返回 outer, 但是不是, 你得到的是 undefined。</p>\n\n<p>为什么?</p>\n\n<p>因为即使 if 代码块没有被执行，第4行中的表达式var x也是被提升的。</p>\n\n<blockquote>\n  <p>var 变量提升</p>\n  \n  <p>var是函数作用域。它在整个函数中是可用的，甚至在被声明之前。\n  初始化 不 提升。如果你使用var ，请总是在顶部声明你的变量。\n  应用提升规则后我们可以更好地了解发生了什么：</p>\n</blockquote>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar x = 'outer';  \nfunction test(inner) {  \n  var x; // 提升声明\n  if (inner) {\n    x = 'inner'; // 初始化不提升\n    return x;\n  }\n  return x;\n}\n</code></pre>\n\n<p>用ECMAScript 6 来拯救：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nlet x = 'outer';  \nfunction test(inner) {  \n  if (inner) {\n    let x = 'inner';\n    return x;\n  }\n  return x; // 从第1行获得预期结果\n}\ntest(false); // outer  \ntest(true); // inner  \n</code></pre>\n\n<p>从var改用 let,使代码按你设想的那样执行。 if 代码块没有被执行，变量x不会从if 代码块中被提升。</p>\n\n<p>let 提升 和 “暂时性死区”</p>\n\n<p>在ES6中，let将把变量提升到代码块的顶部（不是像ES5那样的函数顶部）。\n但是，代码块中，在变量声明之前引用这个变量会导致一个 ReferenceError 错误。\nlet是块作用域。在声明之前不能使用它。 <br />\n“暂时性死区”是指从代码块开始直到变量被声明的区域。</p>\n\n<h2 id=\"iife\">IIFE</h2>\n\n<p>在解释LIFE之前，让我们举个例子。 看看这里：</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \n{\n  var private = 1;\n}\nconsole.log(private); // 1  \n</code></pre>\n\n<p>正如你所看到的，变量private 被泄漏到了代码块外面。你需要使用IIFE（immediately-invoked function expression，即：立即调用函数表达式）来包含它：</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \n(function(){\n  var private2 = 1;\n})();\nconsole.log(private2); // 未捕获 ReferenceError  \n</code></pre>\n\n<p>如果你看看jQuery / lodash或其他开源项目，您将注意到他们使用IIFE以避免污染全局环境并只是在全局定义，如 _，$ 或 jQuery 。</p>\n\n<p>在ES6中更干净，如果我们只是现在某个代码块中使用使用某个变量，我们可以使用let，再也不需要使用IIFE了：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \n{\n  let private3 = 1;\n}\nconsole.log(private3); // 未捕获 ReferenceError  \n</code></pre>\n\n<h2 id=\"const\">Const</h2>\n\n<p>如果你想要一个变量一直不改变，你也可以使用 const。</p>\n\n<p><img src=\"http://css88.b0.upaiyun.com/css88/2016/10/javascript-es6-const-variables-example.png\" alt=\"\" /></p>\n\n<p>底线：var 区分 let 和 const。</p>\n\n<p>对于所有引用使用const; 避免使用var。\n如果你必须重新分配引用（愚人码头注：变量需要重新赋值的），使用let而不是const。</p>\n\n<h2 id=\"templateliterals\">模板字面量(Template Literals)</h2>\n\n<p>当我们有了模板字面量，我们就不需要做更多的嵌套连接。看一看：</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar first = 'Adrian';  \nvar last = 'Mejia';  \nconsole.log('Your name is ' + first + ' ' + last + '.');  \n</code></pre>\n\n<p>现在你可以使用反引号 ( <code></code> ) 和插值字符串 ${};</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nconst first = 'Adrian';  \nconst last = 'Mejia';  \nconsole.log(`Your name is ${first} ${last}.`);  \n</code></pre>\n\n<p>ES6的模板字面量没有转义、循环、条件判断等内置语法，感觉功能还很弱。</p>\n\n<h2 id=\"\">多行字符串</h2>\n\n<p>我们不必在连接字符串时需要加 \\n，就像这样：</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar template = '&lt;li *ngFor=\"let todo of todos\" [ngClass]=\"{completed: todo.isDone}\" &gt;\\n' +  \n'  &lt;div class=\"view\"&gt;\\n' +  \n'    &lt;input class=\"toggle\" type=\"checkbox\" [checked]=\"todo.isDone\"&gt;\\n' +  \n'    &lt;label&gt;&lt;/label&gt;\\n' +  \n'    &lt;button class=\"destroy\"&gt;&lt;/button&gt;\\n' +  \n'  &lt;/div&gt;\\n' +  \n'  &lt;input class=\"edit\" value=\"\"&gt;\\n' +  \n'&lt;/li&gt;';  \nconsole.log(template);  \n</code></pre>\n\n<p>在ES6中，我们可以再次使用反引号来解决这个问题：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nconst template = `&lt;li *ngFor=\"let todo of todos\" [ngClass]=\"{completed: todo.isDone}\" &gt;  \n  &lt;div class=\"view\"&gt;\n    &lt;input class=\"toggle\" type=\"checkbox\" [checked]=\"todo.isDone\"&gt;\n    &lt;label&gt;&lt;/label&gt;\n    &lt;button class=\"destroy\"&gt;&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;input class=\"edit\" value=\"\"&gt;\n&lt;/li&gt;`;  \nconsole.log(template);  \n</code></pre>\n\n<p>这两段代码将等到完全相同的结果。</p>\n\n<h2 id=\"\">解构分配</h2>\n\n<p>ES6解构非常有用和简洁。 按照这个例子：</p>\n\n<p>从数组中获取元素</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar array = [1, 2, 3, 4];  \nvar first = array[0];  \nvar third = array[2];  \nconsole.log(first, third); // 1 3  \n</code></pre>\n\n<p>等价于：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nconst array = [1, 2, 3, 4];  \nconst [first, ,third] = array;  \nconsole.log(first, third); // 1 3  \n</code></pre>\n\n<p>交换值</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar a = 1;  \nvar b = 2;  \nvar tmp = a;  \na = b;  \nb = tmp;  \nconsole.log(a, b); // 2 1  \n</code></pre>\n\n<p>等价于：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nlet a = 1;  \nlet b = 2;  \n[a, b] = [b, a];\nconsole.log(a, b); // 2 1  \n</code></pre>\n\n<p>多个返回值的解构</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nfunction margin() {  \n  var left=1, right=2, top=3, bottom=4;\n  return { left: left, right: right, top: top, bottom: bottom };\n}\nvar data = margin();  \nvar left = data.left;  \nvar bottom = data.bottom;  \nconsole.log(left, bottom); // 1 4  \n</code></pre>\n\n<p>在第3行，你也可以在一个数组中返回它像这样（并保存一些类型）：</p>\n\n<pre><code class=\"language-js\">js 代码:  \nreturn [left, right, top, bottom];  \n</code></pre>\n\n<p>但是调用者需要顾及到返回数据的顺序。</p>\n\n<pre><code class=\"language-js\">js 代码:  \nvar left = data[0];  \nvar bottom = data[3];  \n</code></pre>\n\n<p>使用ES6，调用者只需要选择他们需要的数据（第6行）：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nfunction margin() {  \n  const left=1, right=2, top=3, bottom=4;\n  return { left, right, top, bottom };\n}\nconst { left, bottom } = margin();  \nconsole.log(left, bottom); // 1 4  \n</code></pre>\n\n<p>注意：第3行，我们可以看到ES6的一些其他特性。我们可以压缩{left：left}为{left}。看看它比 ES5 简洁了很多。是不是很酷？</p>\n\n<h2 id=\"\">参数匹配的解构</h2>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar user = {firstName: 'Adrian', lastName: 'Mejia'};  \nfunction getFullName(user) {  \n  var firstName = user.firstName;\n  var lastName = user.lastName;\n  return firstName + ' ' + lastName;\n}\nconsole.log(getFullName(user)); // Adrian Mejia  \n</code></pre>\n\n<p>等价于：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nconst user = {firstName: 'Adrian', lastName: 'Mejia'};  \nfunction getFullName({ firstName, lastName }) {  \n  return `${firstName} ${lastName}`;\n}\nconsole.log(getFullName(user)); // Adrian Mejia  \n</code></pre>\n\n<h2 id=\"\">深度匹配</h2>\n\n<pre><code class=\"language-js\">ES5 代码:  \nfunction settings() {  \n  return { display: { color: 'red' }, keyboard: { layout: 'querty'} };\n}\nvar tmp = settings();  \nvar displayColor = tmp.display.color;  \nvar keyboardLayout = tmp.keyboard.layout;  \nconsole.log(displayColor, keyboardLayout); // red querty  \n</code></pre>\n\n<p>等价于：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nfunction settings() {  \n  return { display: { color: 'red' }, keyboard: { layout: 'querty'} };\n}\nconst { display: { color: displayColor }, keyboard: { layout: keyboardLayout }} = settings();  \nconsole.log(displayColor, keyboardLayout); // red querty  \n</code></pre>\n\n<p>这也称为对象解构。</p>\n\n<p>正如你所看到的，解构是非常有用的，并鼓励良好的编码风格。</p>\n\n<p>最佳实践：</p>\n\n<p>使用数组解构来获取元素或交换变量。它可以避免创建临时引用。\n对于函数多个返回值不要使用数组解构，而使用对象解构。</p>\n\n<h2 id=\"\">类与对象</h2>\n\n<p>使用ECMAScript 6，我们可以从“构造函数”过渡到“类”。</p>\n\n<p>在JavaScript中每一个对象都有一个原型，这是另一个对象。所有JavaScript对象继承了它们原型中的方法和属性。</p>\n\n<p>在ES5中，我们面向对象编程（OOP）需要使用构造函数来创建对象，如下：</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar Animal = (function () {  \n  function MyConstructor(name) {\n    this.name = name;\n  }\n  MyConstructor.prototype.speak = function speak() {\n    console.log(this.name + ' makes a noise.');\n  };\n  return MyConstructor;\n})();\nvar animal = new Animal('animal');  \nanimal.speak(); // animal makes a noise.  \n</code></pre>\n\n<p>在ES6中，我们有一些语法糖。我们可以用较少的板式代码，以及class和constructor等新的关键字做同样的事情。\n另外，请注意我们如何清楚地定义方法constructor.prototype.speak = function () vs speak()：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nclass Animal {  \n  constructor(name) {\n    this.name = name;\n  }\n  speak() {\n    console.log(this.name + ' makes a noise.');\n  }\n}\nconst animal = new Animal('animal');  \nanimal.speak(); // animal makes a noise.  \n</code></pre>\n\n<p>正如你所看到的，两种样式（ES5/6）在幕后产生相同的结果，并且可以以相同的方式使用。</p>\n\n<p>最佳实践：</p>\n\n<p>始终使用class语法，并避免直接操作 prototype。为什么？因为它使代码更简洁和更容易理解。\n避免使用空的构造函数。如果没有指定，类有一个默认构造函数。</p>\n\n<h2 id=\"\">继承</h2>\n\n<p>基于前面的Animal类。假设我们想要扩展它并定义Lion类。</p>\n\n<p>在ES5中，它更多地涉及原型继承。</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar Lion = (function () {  \n  function MyConstructor(name){\n    Animal.call(this, name);\n  }\n\n  // prototypal inheritance\n  MyConstructor.prototype = Object.create(Animal.prototype);\n  MyConstructor.prototype.constructor = Animal;\n\n  MyConstructor.prototype.speak = function speak() {\n    Animal.prototype.speak.call(this);\n    console.log(this.name + ' roars ');\n  };\n  return MyConstructor;\n})();\nvar lion = new Lion('Simba');  \nlion.speak(); // Simba makes a noise.  \n// Simba roars.\n</code></pre>\n\n<p>我不详细描述所有细节，但请注意：</p>\n\n<ul>\n<li>第3行，我们用参数显式调用Animal构造函数。</li>\n<li>第7-8行，我们将Lion原型分配给Animal原型。</li>\n<li>第11行，我们从父类Animal中调用speak方法。</li>\n<li>在ES6中，我们有2个新的关键字extends和super。</li>\n</ul>\n\n<pre><code class=\"language-js\">ES6 代码:  \nclass Lion extends Animal {  \n  speak() {\n    super.speak();\n    console.log(this.name + ' roars ');\n  }\n}\nconst lion = new Lion('Simba');  \nlion.speak(); // Simba makes a noise.  \n// Simba roars.\n</code></pre>\n\n<p>看看ES6的代码比ES5看起来清晰了很多，并且他们做的事情完全一样。</p>\n\n<p>最佳实践：</p>\n\n<p>使用extends内置继承方式来实现继承。</p>\n\n<h2 id=\"promises\">原生的 Promises</h2>\n\n<p>从回调地狱 到 promises</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nfunction printAfterTimeout(string, timeout, done){  \n  setTimeout(function(){\n    done(string);\n  }, timeout);\n}\nprintAfterTimeout('Hello ', 2e3, function(result){  \n  console.log(result);\n  // nested callback\n  printAfterTimeout(result + 'Reader', 2e3, function(result){\n    console.log(result);\n  });\n});\n</code></pre>\n\n<p>我们有一个函数接收一个回调，当done时执行。我们必须一个接一个地两度执行它。这就是为什么我们在回调中第二次调用printAfterTimeout的原因。</p>\n\n<p>如果你需要第3或第4次回调，那么你很快就凌乱了。让我们看看我们如何使用promises：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nfunction printAfterTimeout(string, timeout){  \n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(function(){\n      resolve(string);\n    }, timeout);\n  });\n}\nprintAfterTimeout('Hello ', 2e3).then((result) =&gt; {  \n  console.log(result);\n  return printAfterTimeout(result + 'Reader', 2e3);\n}).then((result) =&gt; {\n  console.log(result);\n});\n</code></pre>\n\n<p>正如你说看到的，使用 promises，我们可以使用then在一个函数完成后做另一些事情。不再需要嵌套函数。</p>\n\n<h2 id=\"\">箭头函数</h2>\n\n<p>ES6没有删除函数表达式，但它添加了一个新的函数表达式，称为箭头函数。</p>\n\n<p>在ES5中，对于this我们有一些疑问：</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar _this = this; // 需要保持一个引用  \n$('.btn').click(function(event){\n  _this.sendData(); // 引用函数外层的 this\n});\n$('.input').on('change',function(event){\n  this.sendData(); // 引用函数外层的 this\n}.bind(this)); // 绑定函数外层的 this\n</code></pre>\n\n<p>你需要使用一个临时的 this ，以便在函数内部引用，或使用bind。在ES6中，可以使用箭头函数！</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \n// this 将引用外部的那个 this\n$('.btn').click((event) =&gt;  this.sendData());\n// 隐式返回\nconst ids = [291, 288, 984];  \nconst messages = ids.map(value =&gt; `ID is ${value}`);  \n</code></pre>\n\n<h2 id=\"forof\">For…of</h2>\n\n<p>从 for 到 forEach 再到 for...of:</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \n// for\nvar array = ['a', 'b', 'c', 'd'];  \nfor (var i = 0; i &lt; array.length; i++) {  \n  var element = array[i];\n  console.log(element);\n}\n// forEach\narray.forEach(function (element) {  \n  console.log(element);\n});\n</code></pre>\n\n<p>ES6 的 for...of 同样允许我们迭代。  </p>\n\n<pre><code class=\"language-js\">ES6 代码:  \n// for ...of\nconst array = ['a', 'b', 'c', 'd'];  \nfor (const element of array) {  \n    console.log(element);\n}\n</code></pre>\n\n<h2 id=\"\">默认参数</h2>\n\n<p>从检查变量是否被定义 到 分配一个值给默认参数。你以前做过类似的事情吗？</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nfunction point(x, y, isFlag){  \n  x = x || 0;\n  y = y || -1;\n  isFlag = isFlag || true;\n  console.log(x,y, isFlag);\n}\npoint(0, 0) // 0 -1 true  \npoint(0, 0, false) // 0 -1 true  \npoint(1) // 1 -1 true  \npoint() // 0 -1 true  \n</code></pre>\n\n<p>肯定这些做过吧？这是一个常见的模式来检查是变量是否赋值，否则分配一个默认值。但是，注意有一些问题：\n* 第7行，我们传递0, 0，得到0, -1。\n* 第8行，我们传递false，但得到true。\n如果你将一个布尔值作为默认参数或将值设置为0，它就不正常工作了。你知道为什么吗？？？我将在ES6示例后面告诉你;）</p>\n\n<p>现在，如果你用ES6，可以用更少的代码做的更好！</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nfunction point(x = 0, y = -1, isFlag = true){  \n  console.log(x,y, isFlag);\n}\npoint(0, 0) // 0 0 true  \npoint(0, 0, false) // 0 0 false  \npoint(1) // 1 -1 true  \npoint() // 0 -1 true  \n</code></pre>\n\n<p>注意第4行和第5行， 我们得到了预期的结果。ES5的示例则没有正常工作。我们必须属性检查  undefined,因为false，null，undefined和0是假（falsy）值。我们需要更加多的代码来修复这个问题：</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nfunction point(x, y, isFlag){  \n  x = x || 0;\n  y = typeof(y) === 'undefined' ? -1 : y;\n  isFlag = typeof(isFlag) === 'undefined' ? true : isFlag;\n  console.log(x,y, isFlag);\n}\npoint(0, 0) // 0 0 true  \npoint(0, 0, false) // 0 0 false  \npoint(1) // 1 -1 true  \npoint() // 0 -1 true  \n</code></pre>\n\n<p>我们检查 undefined，现在它就能按预期工作了。</p>\n\n<h2 id=\"rest\">Rest参数（多余参数）</h2>\n\n<p>从 arguments 到 rest参数 和 扩展运算符。</p>\n\n<p>在ES5中，获取任意数量的参数是非常麻烦的：</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nfunction printf(format) {  \n  var params = [].slice.call(arguments, 1);\n  console.log('params: ', params);\n  console.log('format: ', format);\n}\nprintf('%s %d %.2f', 'adrian', 321, Math.PI);  \n</code></pre>\n\n<p>我们可以使用rest运算符...做同样的事情。</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nfunction printf(format, ...params) {  \n  console.log('params: ', params);\n  console.log('format: ', format);\n}\nprintf('%s %d %.2f', 'adrian', 321, Math.PI);  \n</code></pre>\n\n<h2 id=\"\">扩展运算符</h2>\n\n<p>从apply()到扩展运算符，我们有 ... 拯救：</p>\n\n<p>提醒：我们使用apply() 将数组转换为一个参数列表。例如，Math.max()获取参数列表，但是如果我们有一个数组，我们可以使用apply来使它工作。</p>\n\n<p><img src=\"http://css88.b0.upaiyun.com/css88/2016/10/javascript-math-apply-arrays.png\" alt=\"\" /></p>\n\n<p>正如我们在前面看到的，我们可以使用apply将数组作为参数列表传递：</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nMath.max.apply(Math, [2,100,1,6,43]) // 100  \n</code></pre>\n\n<p>在ES6中，你可以使用 扩展运算符。</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nMath.max(...[2,100,1,6,43]) // 100  \n</code></pre>\n\n<p>另外，我们可以使用扩展运算符来 concat（合并）数组：</p>\n\n<pre><code class=\"language-js\">ES5 代码:  \nvar array1 = [2,100,1,6,43];  \nvar array2 = ['a', 'b', 'c', 'd'];  \nvar array3 = [false, true, null, undefined];  \nconsole.log(array1.concat(array2, array3));  \n</code></pre>\n\n<p>在ES6中，可以使用扩展运算符合并数组：</p>\n\n<pre><code class=\"language-js\">ES6 代码:  \nconst array1 = [2,100,1,6,43];  \nconst array2 = ['a', 'b', 'c', 'd'];  \nconst array3 = [false, true, null, undefined];  \nconsole.log([...array1, ...array2, ...array3]);  \n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495700446327,"created_by":1,"updated_at":1495700531791,"updated_by":1,"published_at":1476086280000,"published_by":1},{"id":20,"uuid":"550bb84e-abfd-4aed-bc49-8d79e5600e8b","title":"新手必须掌握5个LESS CSS","slug":"newbie-5-less-css","markdown":"LESS, Sass 和其他 CSS 预处理器是一种超棒的方法用来扩展 CSS功能，使之更适合程序员。\n你可以使用变量、函数、混合、继承等多种编程常用方法来编写 CSS，以更少的代码完成更多的样式。\n学习这些工具最好的方法是通过各种实例快速入门，今天我们向你介绍 10 个非常有用的使用 Less CSS 的实例。\n\n![](http://static.open-open.com/news/uploadImg/20120328/20120328105303_386.jpg)\n\n# 1、变量\n变量允许我们单独定义一系列通用的样式，然后在需要的时候去调用。所以在做全局样式调整的时候我们可能只需要修改几行代码就可以了。\n```css\n  // LESS\n\n@color: #4D926F;\n\n#header {\n  color: @color;\n}\nh2 {\n  color: @color;\n}\n```\n\n/* 生成的 CSS */\n```css\n#header {\n  color: #4D926F;\n}\nh2 {\n  color: #4D926F;\n}\n```\n\n# 2、混合\n混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。\n```css\n// LESS\n\n.rounded-corners (@radius: 5px) {\n  border-radius: @radius;\n  -webkit-border-radius: @radius;\n  -moz-border-radius: @radius;\n}\n\n#header {\n  .rounded-corners;\n}\n#footer {\n  .rounded-corners(10px);\n}\n```\n\n/* 生成的 CSS */\n```css\n#header {\n  border-radius: 5px;\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n}\n#footer {\n  border-radius: 10px;\n  -webkit-border-radius: 10px;\n  -moz-border-radius: 10px;\n}\n```\n\n# 3、嵌套规则\n我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。\n```css\n// LESS\n\n#header {\n  h1 {\n    font-size: 26px;\n    font-weight: bold;\n  }\n  p { font-size: 12px;\n    a { text-decoration: none;\n      &:hover { border-width: 1px }\n    }\n  }\n}\n```\n\n/* 生成的 CSS */\n```css\n#header h1 {\n  font-size: 26px;\n  font-weight: bold;\n}\n#header p {\n  font-size: 12px;\n}\n#header p a {\n  text-decoration: none;\n}\n#header p a:hover {\n  border-width: 1px;\n}\n```\n\n# 4、函数 & 运算\n运算提供了加，减，乘，除操作；我们可以做属性值和颜色的运算，这样就可以实现属性值之间的复杂关系。LESS中的函数一一映射了JavaScript代码，如果你愿意的话可以操作属性值。\n```css\n// LESS\n\n@the-border: 1px;\n@base-color: #111;\n@red:        #842210;\n\n#header {\n  color: @base-color * 3;\n  border-left: @the-border;\n  border-right: @the-border * 2;\n}\n#footer { \n  color: @base-color + #003300;\n  border-color: desaturate(@red, 10%);\n}\n```\n\n/* 生成的 CSS */\n```css\n#header {\n  color: #333;\n  border-left: 1px;\n  border-right: 2px;\n}\n#footer { \n  color: #114411;\n  border-color: #7d2717;\n}\n```\n\n# 5、圆角\nCSS3 一个非常基本的新属性可以快速的生产圆角效果，如上图所示。要使用 CSS3 的圆角效果我们必须针对不同的浏览器定义各自的前缀，而如果使用了 LESS 就可以不用那么麻烦。\n\n* 简单的圆角半径\n我的第一个 LESS 代码是我最简单的 LESS 代码之一，我需要设置圆角的半径，而且我希望使用一个变量来调整这个半径大小。\n\n下面代码使用 mixin 技术，通过定义 .border-radius 并接收一个 radius 参数，该参数默认值是 5px，你可以在多个地方重复使用该 mixin 方法：\n\n```css\n/* Mixin */\n.border-radius (@radius: 5px) {\n\t-webkit-border-radius: @radius;\n\t-moz-border-radius: @radius;\n\tborder-radius: @radius;\n}\n \n/* Implementation */\n#somediv {\n\t.border-radius(20px);\n}\n```\n将这个 less 编译成 css 后的结果是：\n\n```css\n/* Compiled CSS */\n#somediv {\n  -webkit-border-radius: 20px;\n  -moz-border-radius: 20px;\n  border-radius: 20px;\n}\n```\n\n* 四角的半径定制\n如果你希望用户可自由定制四个角的半径，那么我们需要对上面代码做下改进。\n使用4个变量分别代表四个边角的半径大小：\n```css\n/* Mixin */\n.border-radius-custom (@topleft: 5px, @topright: 5px, @bottomleft: 5px, @bottomright: 5px) {\n\t-webkit-border-radius: @topleft @topright @bottomright @bottomleft;\n\t-moz-border-radius: @topleft @topright @bottomright @bottomleft;\n\tborder-radius: @topleft @topright @bottomright @bottomleft;\n}\n \n/* Implementation */\n#somediv {\n\t.border-radius-custom(20px, 20px, 0px, 0px);\n}\n```\n编译后的 CSS\n```css\n/* Compiled CSS */\n#somediv {\n  -webkit-border-radius: 20px 20px 0px 0px;\n  -moz-border-radius: 20px 20px 0px 0px;\n  border-radius: 20px 20px 0px 0px;\n}\n```","html":"<p>LESS, Sass 和其他 CSS 预处理器是一种超棒的方法用来扩展 CSS功能，使之更适合程序员。 <br />\n你可以使用变量、函数、混合、继承等多种编程常用方法来编写 CSS，以更少的代码完成更多的样式。\n学习这些工具最好的方法是通过各种实例快速入门，今天我们向你介绍 10 个非常有用的使用 Less CSS 的实例。</p>\n\n<p><img src=\"http://static.open-open.com/news/uploadImg/20120328/20120328105303_386.jpg\" alt=\"\" /></p>\n\n<h1 id=\"1\">1、变量</h1>\n\n<p>变量允许我们单独定义一系列通用的样式，然后在需要的时候去调用。所以在做全局样式调整的时候我们可能只需要修改几行代码就可以了。</p>\n\n<pre><code class=\"language-css\">  // LESS\n\n@color: #4D926F;\n\n#header {\n  color: @color;\n}\nh2 {  \n  color: @color;\n}\n</code></pre>\n\n<p>/* 生成的 CSS */</p>\n\n<pre><code class=\"language-css\">#header {\n  color: #4D926F;\n}\nh2 {  \n  color: #4D926F;\n}\n</code></pre>\n\n<h1 id=\"2\">2、混合</h1>\n\n<p>混合可以将一个定义好的class A轻松的引入到另一个class B中，从而简单实现class B继承class A中的所有属性。我们还可以带参数地调用，就像使用函数一样。</p>\n\n<pre><code class=\"language-css\">// LESS\n\n.rounded-corners (@radius: 5px) {\n  border-radius: @radius;\n  -webkit-border-radius: @radius;\n  -moz-border-radius: @radius;\n}\n\n#header {\n  .rounded-corners;\n}\n#footer {\n  .rounded-corners(10px);\n}\n</code></pre>\n\n<p>/* 生成的 CSS */</p>\n\n<pre><code class=\"language-css\">#header {\n  border-radius: 5px;\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n}\n#footer {\n  border-radius: 10px;\n  -webkit-border-radius: 10px;\n  -moz-border-radius: 10px;\n}\n</code></pre>\n\n<h1 id=\"3\">3、嵌套规则</h1>\n\n<p>我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。</p>\n\n<pre><code class=\"language-css\">// LESS\n\n#header {\n  h1 {\n    font-size: 26px;\n    font-weight: bold;\n  }\n  p { font-size: 12px;\n    a { text-decoration: none;\n      &amp;:hover { border-width: 1px }\n    }\n  }\n}\n</code></pre>\n\n<p>/* 生成的 CSS */</p>\n\n<pre><code class=\"language-css\">#header h1 {\n  font-size: 26px;\n  font-weight: bold;\n}\n#header p {\n  font-size: 12px;\n}\n#header p a {\n  text-decoration: none;\n}\n#header p a:hover {\n  border-width: 1px;\n}\n</code></pre>\n\n<h1 id=\"4\">4、函数 &amp; 运算</h1>\n\n<p>运算提供了加，减，乘，除操作；我们可以做属性值和颜色的运算，这样就可以实现属性值之间的复杂关系。LESS中的函数一一映射了JavaScript代码，如果你愿意的话可以操作属性值。</p>\n\n<pre><code class=\"language-css\">// LESS\n\n@the-border: 1px;\n@base-color: #111;\n@red:        #842210;\n\n#header {\n  color: @base-color * 3;\n  border-left: @the-border;\n  border-right: @the-border * 2;\n}\n#footer { \n  color: @base-color + #003300;\n  border-color: desaturate(@red, 10%);\n}\n</code></pre>\n\n<p>/* 生成的 CSS */</p>\n\n<pre><code class=\"language-css\">#header {\n  color: #333;\n  border-left: 1px;\n  border-right: 2px;\n}\n#footer { \n  color: #114411;\n  border-color: #7d2717;\n}\n</code></pre>\n\n<h1 id=\"5\">5、圆角</h1>\n\n<p>CSS3 一个非常基本的新属性可以快速的生产圆角效果，如上图所示。要使用 CSS3 的圆角效果我们必须针对不同的浏览器定义各自的前缀，而如果使用了 LESS 就可以不用那么麻烦。</p>\n\n<ul>\n<li>简单的圆角半径\n我的第一个 LESS 代码是我最简单的 LESS 代码之一，我需要设置圆角的半径，而且我希望使用一个变量来调整这个半径大小。</li>\n</ul>\n\n<p>下面代码使用 mixin 技术，通过定义 .border-radius 并接收一个 radius 参数，该参数默认值是 5px，你可以在多个地方重复使用该 mixin 方法：</p>\n\n<pre><code class=\"language-css\">/* Mixin */\n.border-radius (@radius: 5px) {\n    -webkit-border-radius: @radius;\n    -moz-border-radius: @radius;\n    border-radius: @radius;\n}\n\n/* Implementation */\n#somediv {\n    .border-radius(20px);\n}\n</code></pre>\n\n<p>将这个 less 编译成 css 后的结果是：</p>\n\n<pre><code class=\"language-css\">/* Compiled CSS */\n#somediv {\n  -webkit-border-radius: 20px;\n  -moz-border-radius: 20px;\n  border-radius: 20px;\n}\n</code></pre>\n\n<ul>\n<li>四角的半径定制\n如果你希望用户可自由定制四个角的半径，那么我们需要对上面代码做下改进。\n使用4个变量分别代表四个边角的半径大小：</li>\n</ul>\n\n<pre><code class=\"language-css\">/* Mixin */\n.border-radius-custom (@topleft: 5px, @topright: 5px, @bottomleft: 5px, @bottomright: 5px) {\n    -webkit-border-radius: @topleft @topright @bottomright @bottomleft;\n    -moz-border-radius: @topleft @topright @bottomright @bottomleft;\n    border-radius: @topleft @topright @bottomright @bottomleft;\n}\n\n/* Implementation */\n#somediv {\n    .border-radius-custom(20px, 20px, 0px, 0px);\n}\n</code></pre>\n\n<p>编译后的 CSS</p>\n\n<pre><code class=\"language-css\">/* Compiled CSS */\n#somediv {\n  -webkit-border-radius: 20px 20px 0px 0px;\n  -moz-border-radius: 20px 20px 0px 0px;\n  border-radius: 20px 20px 0px 0px;\n}\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495700541987,"created_by":1,"updated_at":1495700904326,"updated_by":1,"published_at":1443687780000,"published_by":1},{"id":21,"uuid":"b97f8410-a4cd-401c-b6bc-82220ce261ac","title":"AngularJS动态加载Controller","slug":"angularjs-controller","markdown":"\nAngularJS原生并不支持动态加载Controller的方法，但是却提供注册Controller的方法。接下来就来看下如何实现动态加载Controller。\n\n<!-- more -->\n\n我们把实现动态加载Controller方法封装到一个通用的模块里面，并命名这个模块为`ngCommon`。\n\n```javascript\n(function (angular) {'use strict';\n    var CommonApp = angular.module('ngCommon');\n    ...\n})(angular);\n```\n\n接下来我们实现一个动态加载js的方法`$require`。\n\n```javascript\n/* 记录已加载的js */\nvar loaded = {};\n/* 检测是否加载 */\nvar checkLoaded = function (url) {\n    return !url || !angular.isString(url) || loaded[url];\n};\n\nCommonApp.factory('$require', ['$document', '$q', '$rootScope', function ($document, $q, $rootScope) {\n    return function (url) {\n        var script = null;\n        var onload = null;\n        var doc = $document[0];\n        var body = doc.body;\n        var deferred = $q.defer();\n        if (checkLoaded(url)) {\n            deferred.resolve();\n        } else {\n            script = doc.createElement('script');\n            onload = function (info) {\n                if (info === 1) {\n                    deferred.reject();\n                } else {\n                    loaded[url] = 1;\n                    /* AngularJS < 1.2.x 请使用$timeout */\n                    $rootScope.$evalAsync(function () {\n                        deferred.resolve();\n                    });\n                }\n                script.onload = script.onerror = null;\n                body.removeChild(script);\n                script = null;\n            };\n            script.onload = onload;\n            script.onerror = function () {\n                onload(1);\n            };\n            script.async = true;\n            script.src = url;\n            body.appendChild(script);\n        }\n        return deferred.promise;\n    };\n}]);\n```\n\n然后重点来了，通过`$routeProvider route`的`resolve`功能来实现动态加载Controller。\n\n```javascript\nCommonApp.provider('$routeResolver', function () {\n    this.$get = function () {\n        return this;\n    };\n    this.route = function (routeCnf) {\n        var controller = routeCnf.controller;\n        var controllerUrl = routeCnf.controllerUrl;\n        if (controllerUrl) {\n            routeCnf.reloadOnSearch = routeCnf.reloadOnSearch || false;\n            routeCnf.resolve = {\n                load: ['$route', '$require', 'ControllerChecker',\n                    function ($route, $require, ControllerChecker) {\n                        var controllerName = angular.isFunction(controller) ? controller($route.current.params) : controller;\n                        var url = angular.isFunction(controllerUrl) ? controllerUrl($route.current.params) : controllerUrl;\n                        if (checkLoaded(url) || (controllerName && ControllerChecker.exists(controllerName))) {\n                            loaded[url] = true;\n                            return;\n                        }\n                        return $require(url);\n                }]\n            };\n        }\n        return routeCnf;\n    };\n})\n```\n\n看上面的代码中还注入了一个叫`ControllerChecker`的，这个是用来检测当前Controller是否已经注册了，如果未注册，那么我们就加载相关js注册新的Controller。\n代码如下：\n\n```javascript\nCommonApp.service('ControllerChecker', ['$controller', function ($controller) {\n    return {\n        exists: function (controllerName) {\n            if (angular.isFunction(window[controllerName])) {\n                return true;\n            }\n            try {\n                $controller(controllerName, {}, true);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n    };\n}]);\n```\n\n最后我们来添加一个注动态册的方法。\n\n```javascript\nCommonApp.setupRegister = function (module) {\n    module.config([\n        '$controllerProvider',\n        '$compileProvider',\n        '$filterProvider',\n        '$provide',\n        function ($controllerProvider, $compileProvider, $filterProvider, $provide) {\n            module.register = {\n                controller: $controllerProvider.register,\n                directive: $compileProvider.directive,\n                filter: $filterProvider.register,\n                factory: $provide.factory,\n                service: $provide.service,\n                value: $provide.value,\n                constant: $provide.constant\n            };\n        }\n    ]);\n};\n```\n\n\n到此已经基本完成了，如何使用呢？\n\n```javascript\nvar DemoApp = angular.module('DemoApp',['ngRoute','ngCommon']);\n/* 调用动态注册方法，为当前模块添加动态注册方法 */\nangular.module('ngCommon').setupRegister(DemoApp);\nDemoApp.config(['$routeProvider', '$routeResolverProvider', function ($routeProvider, $routeResolverProvider) {\n    var route = $routeResolverProvider.route;\n    $routeProvider.when('/index', route({\n        templateUrl: './view/index.html'),\n        controller: 'IndexController', /* 在此申明了controller就不需要再html里面申明ng-controller了 */\n        controllerUrl: './controller/index.js')\n    }))\n    .otherwise('/index');\n\n/* ./controller/index.js */\nDemoApp.register.controller('IndexController', ['$scope', '$require', function($scope, $require) {\n    ...\n    /* 动态加载某个js文件 */\n    $require(url).then(function () {\n        ...\n    });\n}]);\n```","html":"<p>AngularJS原生并不支持动态加载Controller的方法，但是却提供注册Controller的方法。接下来就来看下如何实现动态加载Controller。</p>\n\n<!-- more -->\n\n<p>我们把实现动态加载Controller方法封装到一个通用的模块里面，并命名这个模块为<code>ngCommon</code>。</p>\n\n<pre><code class=\"language-javascript\">(function (angular) {'use strict';\n    var CommonApp = angular.module('ngCommon');\n    ...\n})(angular);\n</code></pre>\n\n<p>接下来我们实现一个动态加载js的方法<code>$require</code>。</p>\n\n<pre><code class=\"language-javascript\">/* 记录已加载的js */\nvar loaded = {};  \n/* 检测是否加载 */\nvar checkLoaded = function (url) {  \n    return !url || !angular.isString(url) || loaded[url];\n};\n\nCommonApp.factory('$require', ['$document', '$q', '$rootScope', function ($document, $q, $rootScope) {  \n    return function (url) {\n        var script = null;\n        var onload = null;\n        var doc = $document[0];\n        var body = doc.body;\n        var deferred = $q.defer();\n        if (checkLoaded(url)) {\n            deferred.resolve();\n        } else {\n            script = doc.createElement('script');\n            onload = function (info) {\n                if (info === 1) {\n                    deferred.reject();\n                } else {\n                    loaded[url] = 1;\n                    /* AngularJS &lt; 1.2.x 请使用$timeout */\n                    $rootScope.$evalAsync(function () {\n                        deferred.resolve();\n                    });\n                }\n                script.onload = script.onerror = null;\n                body.removeChild(script);\n                script = null;\n            };\n            script.onload = onload;\n            script.onerror = function () {\n                onload(1);\n            };\n            script.async = true;\n            script.src = url;\n            body.appendChild(script);\n        }\n        return deferred.promise;\n    };\n}]);\n</code></pre>\n\n<p>然后重点来了，通过<code>$routeProvider route</code>的<code>resolve</code>功能来实现动态加载Controller。</p>\n\n<pre><code class=\"language-javascript\">CommonApp.provider('$routeResolver', function () {  \n    this.$get = function () {\n        return this;\n    };\n    this.route = function (routeCnf) {\n        var controller = routeCnf.controller;\n        var controllerUrl = routeCnf.controllerUrl;\n        if (controllerUrl) {\n            routeCnf.reloadOnSearch = routeCnf.reloadOnSearch || false;\n            routeCnf.resolve = {\n                load: ['$route', '$require', 'ControllerChecker',\n                    function ($route, $require, ControllerChecker) {\n                        var controllerName = angular.isFunction(controller) ? controller($route.current.params) : controller;\n                        var url = angular.isFunction(controllerUrl) ? controllerUrl($route.current.params) : controllerUrl;\n                        if (checkLoaded(url) || (controllerName &amp;&amp; ControllerChecker.exists(controllerName))) {\n                            loaded[url] = true;\n                            return;\n                        }\n                        return $require(url);\n                }]\n            };\n        }\n        return routeCnf;\n    };\n})\n</code></pre>\n\n<p>看上面的代码中还注入了一个叫<code>ControllerChecker</code>的，这个是用来检测当前Controller是否已经注册了，如果未注册，那么我们就加载相关js注册新的Controller。\n代码如下：</p>\n\n<pre><code class=\"language-javascript\">CommonApp.service('ControllerChecker', ['$controller', function ($controller) {  \n    return {\n        exists: function (controllerName) {\n            if (angular.isFunction(window[controllerName])) {\n                return true;\n            }\n            try {\n                $controller(controllerName, {}, true);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n    };\n}]);\n</code></pre>\n\n<p>最后我们来添加一个注动态册的方法。</p>\n\n<pre><code class=\"language-javascript\">CommonApp.setupRegister = function (module) {  \n    module.config([\n        '$controllerProvider',\n        '$compileProvider',\n        '$filterProvider',\n        '$provide',\n        function ($controllerProvider, $compileProvider, $filterProvider, $provide) {\n            module.register = {\n                controller: $controllerProvider.register,\n                directive: $compileProvider.directive,\n                filter: $filterProvider.register,\n                factory: $provide.factory,\n                service: $provide.service,\n                value: $provide.value,\n                constant: $provide.constant\n            };\n        }\n    ]);\n};\n</code></pre>\n\n<p>到此已经基本完成了，如何使用呢？</p>\n\n<pre><code class=\"language-javascript\">var DemoApp = angular.module('DemoApp',['ngRoute','ngCommon']);  \n/* 调用动态注册方法，为当前模块添加动态注册方法 */\nangular.module('ngCommon').setupRegister(DemoApp);  \nDemoApp.config(['$routeProvider', '$routeResolverProvider', function ($routeProvider, $routeResolverProvider) {  \n    var route = $routeResolverProvider.route;\n    $routeProvider.when('/index', route({\n        templateUrl: './view/index.html'),\n        controller: 'IndexController', /* 在此申明了controller就不需要再html里面申明ng-controller了 */\n        controllerUrl: './controller/index.js')\n    }))\n    .otherwise('/index');\n\n/* ./controller/index.js */\nDemoApp.register.controller('IndexController', ['$scope', '$require', function($scope, $require) {  \n    ...\n    /* 动态加载某个js文件 */\n    $require(url).then(function () {\n        ...\n    });\n}]);\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495700629377,"created_by":1,"updated_at":1495700665596,"updated_by":1,"published_at":1495700665597,"published_by":1},{"id":22,"uuid":"fd3cd88b-2e2f-4018-9f80-639ee31d0c11","title":"BrowserSync自动刷新,释放你的F5.","slug":"browsersync-no-f5","markdown":"想象一下这个场景：你开着两个显示器，一边是写代码，另一边是浏览器里的你正在开发的Web。此时桌上还放着你的手机，手机里也是这个开发中的应用。然后，你新写了一小段代码，按下了<code>Ctrl+S</code>保存。紧接着，你的手机和另一个显示器里的应用，就变成了更新后的效果。你可以马上检查效果是否和你预想的一致，甚至都不需要动一下鼠标。\n<!-- more -->\n想起来还不错？嗯，这只是简单地省略掉那个开发过程中会按好多遍的F5刷新。\n\nLiveReload有所不足的地方是，需要搭配浏览器插件。但是，插件是取决于浏览器的，Chrome和Firefox都有可用插件，但IE和手机上的浏览器，就不能这样了，这时候只能手工向页面里添加一段<code>&lt;script&gt;</code>代码，而且还要记得结束后再手工移除。\n\nBrowserSync的用法则不需要浏览器插件，也不用手工添加代码。一句控制台的命令之后，无论是在手机里还是电脑，无论用多少个浏览器，都可以拥有自动刷新的功能。\n\n![](http://i1.piimg.com/567571/c60e6937130d255d.jpg)\n\n# BrowserSync安装和使用\n* 1.下载并安装Node.js：\n\nhttps://nodejs.org/en/download\n\n* 2.通过npm安装BrowserSync：\n\n`npm install -g browser-sync`\n\n* 3.安装后，就可以开始使用了。打开控制台进入项目所在的目录，然后输入命令(此命令用于纯静态站点)：\n--files 路径是相对于运行该命令的项目（目录）\n\n``browser-sync start --server --files \"*.css, *.html\"``\n\n后面的*.css, *.html，是指监听目录中的后缀名为.css和.html的文件。\n\n## 如果你的文件层级比较深，您可以考虑使用 **（任意目录匹配），来监听目录下的任意文件。\n``browser-sync start --server --files \"**\"``\n\n## 如果是动态站点，则使用代理模式。例如PHP站点，已经建立了一个本地服务器如``http://localhost:8080``\n\n此时会是这样的命令：\n\n``browser-sync start --proxy \"localhost:8080\" --files \"*.css\"``\n\nBrowserSync会提供一个新地址（如未被占用的话，``http://localhost:3000``）用于访问。\n\n好了，为什么BrowserSync不需要浏览器插件？因为它使用了服务器的形式（直接或代理）来处理项目文件。默认情况下，访问它的服务器上的网页，可以看到这样的提示签：\n\n![](http://i1.piimg.com/567571/48b052b246d65304.png)\n\n这说明当前浏览的网页已连接到BrowserSync。查看一下源码，会发现它们都被添加了与BrowserSync有关的一段<code>&lt;script&gt;</code>代码，就像LiveReload浏览器插件做的那样。这些代码会在浏览器和BrowserSync的服务器之间建立web socket连接，一旦有监听的文件发生变化，BrowserSync会通知浏览器。\n如果监听的文件是CSS，BrowserSync不会刷新整页，而是直接重新请求这个css文件，并更新到当前页中，如图：\n\n![](http://i1.piimg.com/567571/a193de06ae37289b.gif)","html":"想象一下这个场景：你开着两个显示器，一边是写代码，另一边是浏览器里的你正在开发的Web。此时桌上还放着你的手机，手机里也是这个开发中的应用。然后，你新写了一小段代码，按下了<code>Ctrl+S</code>保存。紧接着，你的手机和另一个显示器里的应用，就变成了更新后的效果。你可以马上检查效果是否和你预想的一致，甚至都不需要动一下鼠标。\n<!-- more -->  \n\n<p>想起来还不错？嗯，这只是简单地省略掉那个开发过程中会按好多遍的F5刷新。</p>\n\n<p>LiveReload有所不足的地方是，需要搭配浏览器插件。但是，插件是取决于浏览器的，Chrome和Firefox都有可用插件，但IE和手机上的浏览器，就不能这样了，这时候只能手工向页面里添加一段<code>&lt;script&gt;</code>代码，而且还要记得结束后再手工移除。</p>\n\n<p>BrowserSync的用法则不需要浏览器插件，也不用手工添加代码。一句控制台的命令之后，无论是在手机里还是电脑，无论用多少个浏览器，都可以拥有自动刷新的功能。</p>\n\n<p><img src=\"http://i1.piimg.com/567571/c60e6937130d255d.jpg\" alt=\"\" /></p>\n\n<h1 id=\"browsersync\">BrowserSync安装和使用</h1>\n\n<ul>\n<li>1.下载并安装Node.js：</li>\n</ul>\n\n<p><a href=\"https://nodejs.org/en/download\">https://nodejs.org/en/download</a></p>\n\n<ul>\n<li>2.通过npm安装BrowserSync：</li>\n</ul>\n\n<p><code>npm install -g browser-sync</code></p>\n\n<ul>\n<li>3.安装后，就可以开始使用了。打开控制台进入项目所在的目录，然后输入命令(此命令用于纯静态站点)：\n--files 路径是相对于运行该命令的项目（目录）</li>\n</ul>\n\n<p><code>browser-sync start --server --files \"*.css, *.html\"</code></p>\n\n<p>后面的*.css, *.html，是指监听目录中的后缀名为.css和.html的文件。</p>\n\n<h2 id=\"\">如果你的文件层级比较深，您可以考虑使用 **（任意目录匹配），来监听目录下的任意文件。</h2>\n\n<p><code>browser-sync start --server --files \"**\"</code></p>\n\n<h2 id=\"phphttplocalhost8080\">如果是动态站点，则使用代理模式。例如PHP站点，已经建立了一个本地服务器如<code>http://localhost:8080</code></h2>\n\n<p>此时会是这样的命令：</p>\n\n<p><code>browser-sync start --proxy \"localhost:8080\" --files \"*.css\"</code></p>\n\n<p>BrowserSync会提供一个新地址（如未被占用的话，<code>http://localhost:3000</code>）用于访问。</p>\n\n<p>好了，为什么BrowserSync不需要浏览器插件？因为它使用了服务器的形式（直接或代理）来处理项目文件。默认情况下，访问它的服务器上的网页，可以看到这样的提示签：</p>\n\n<p><img src=\"http://i1.piimg.com/567571/48b052b246d65304.png\" alt=\"\" /></p>\n\n<p>这说明当前浏览的网页已连接到BrowserSync。查看一下源码，会发现它们都被添加了与BrowserSync有关的一段<code>&lt;script&gt;</code>代码，就像LiveReload浏览器插件做的那样。这些代码会在浏览器和BrowserSync的服务器之间建立web socket连接，一旦有监听的文件发生变化，BrowserSync会通知浏览器。\n如果监听的文件是CSS，BrowserSync不会刷新整页，而是直接重新请求这个css文件，并更新到当前页中，如图：</p>\n\n<p><img src=\"http://i1.piimg.com/567571/a193de06ae37289b.gif\" alt=\"\" /></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495700692095,"created_by":1,"updated_at":1495700740607,"updated_by":1,"published_at":1475553840000,"published_by":1},{"id":23,"uuid":"6b162fc0-d956-497e-801f-94f1f23e0b46","title":"Node.js(1) 封装,调用,执行,访问路径,http,函数编程,等待函数,事件监听","slug":"nodejs-1","markdown":"### 1.如何封装一个模块；\n首先，我们建立一个js文件，例如命名为test.js；\n然后在里面写一个函数，函数名任意；\n然后通过exports.变量名，将函数赋值给这个变量；\n如代码：\n<!-- more -->\n```js\nfunction test(){    //请注意这个函数名\n    console.log(\"1\");\n}\nexports.testBegin= test;   //等号后面的test，指的是上面的函数名。等号前面的testBegin，是调用时的函数名（注意区别）\n```\n这个test.js的文件就写完了，这是一个模块，他的效果是调用该函数后，输出1；\n另外，不要问我这个exports是什么，我暂时也不知道。\n\n## 2.如何调用一个模块\n在封装模块的前提下，我们新建一个文件，例如a.js，来调用之前封装的test.js模块；\n方法是：\n```js\nvar test = require(\"./test\");   //调用该模块\ntest.testBegin();   //调用该模块的方法（注意方法名是test.js中exports后面的变量名）；\n```\n注意调用时的方法名，并非是test.js中的函数名test；\n\n### 3.如何执行一个Node.js的文件\n我们现在需要执行a.js这个调用了封装模块的文件了，执行他的方法，和执行普通的node.js的文件的方法并没有什么不同；\n在a.js这个文件的目录下，打开命令行。windows是shift＋鼠标右键；\n像下面这样输入即可：\n然后将输出1，感觉执行执行Python文件那样\n\n### 4.获得访问者想要访问的路径\n![](http://img.blog.csdn.net/20160602214711294)\n首先上图，其中pathname指的是路径；而query指的是请求之类的东西（暂时不关心）；\n假如我们想要获得pathname（即字符串“start”），我们该怎么办呢？\n方法：\n* ①首先，需要获取访问者需要访问的路径，方法是通过http的方法createServer\n具体来说：\n我们先require一个http模块：\n```js\nvar http = require(\"http\");\n```\n然后调用其方法，创建一个服务器：\n```js\nhttp.createServer(onRequest).listen(8888);\n```\n注意，这个方法监听的是8888端口，其参数是一个函数；\n \n然后我们书写这个函数的内容：\n```js\nfunction onRequest(request, response) {\n    console.log(request.url);\n}\n```\n这个函数的第一个参数request是用户访问的一些东西，我们需要的是其url变量；假设我们访问地址是这样的：\n``http://127.0.0.1:8888/index/loading?start``\n请注意红色部分，那么服务器在console.log输出的是\n```\n/index/loading?start\n```\n\n* ②我们下来要对这个url做点什么了；\n虽然直接对上面那个参数进行操纵也可以，但这太笨了，让我们来require一个新的模块url\n```js\nvar url = require(\"url\");\n```\n\n* ③调用这个新模块的方法parse，将第一步获得的url地址，作为其参数，再调用其方法pathname，就可以获得我们想要的东西了；\n具体而言，需要这么一段代码：\n```js\nvar pathname = url.parse(request.url).pathname;\n```\n这个pathname就是我们需要的东西了；\n \n把所有代码综合起来，是这样的：\n```js\nvar http = require(\"http\");\nvar url = require(\"url\");\nfunction onRequest(request, response) {\n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" recived.\");\n    response.writeHead(200, {\"Content-type\": \"text/plain\"});\n    response.write(\"Hello word!\");\n    response.end();\n}\nhttp.createServer(onRequest).listen(8888);\nconsole.log(\"Server has started!\");\n```\n然后运行之：\n \n我们随便访问一个本地的地址：\n``http://127.0.0.1:8888/index/loading?start``\n \n发现，/index/loding这部分被正常的显示出来了。\n另外，favicon.ico是该网站的图标，据说很多服务器是会默认读取的；\n \n假如我们直接访问：``http://127.0.0.1:8888``，显示是这样的\n![](http://img.blog.csdn.net/20160602214745169)\n\n### 5.关于http\n我们之前有了这么一段代码（已delete掉无关部分）：\n```js\nvar http = require(\"http\");\nfunction onRequest(request, response) {\n    response.writeHead(200, {\"Content-type\": \"text/plain\"});\n    response.write(\"Hello word!\");\n    response.end();\n}\nhttp.createServer(onRequest).listen(8888);\n```\n其中，http调用了NodeJs自带的一个模块“http”，而这个模块是一个服务器模块；\n而createServer是这个模块的方法，效果是返回一个对象，而这个对象有一个listen的方法；\n当然，由于你和我，也许都是新手，因此我们尚没有搞清楚这个到底是怎么运作的；但如果有一定经验的话，可以猜到，这个listen是监听，监听的是8888端口；如果去掉这部分会怎么样？经过测试，服务器并没有运行，如图：\n \n而onRequest函数呢，从名字可以猜到，这个函数的效果是“当请求的时候做些什么”，我们来看其函数：\n```js\nfunction onRequest(request, response) {\n    response.writeHead(200);\n    response.write(\"Hello word!\");\n    response.end();\n}\n```\n这个函数有两个参数：request和response，顾名思义，请求和响应。\nrequest请求指用户访问的时候，相关的信息；\nresponse指服务器的响应，会做些什么；这个函数的三个方法，都是response相关的；\n \n* 第一个：response.writeHead方法，具体来说，就是HTTP响应报文的头行；\n这个指HTTP通信的响应报文中的头部分，如果没有基础的话，暂时不需要关心，写200即可，这里的200，是约定俗称的请求成功时的返回；\n具体搜：\n``response.writeHead(statusCode,[reasonPhrase], [headers])``\n \n* 第二个：response.write方法，具体来说，是HTTP响应报文；\n简单理解，负责发送正文中的一部分，可以同时发送多个不一样的；\n在上面搜：\n``response.write(chunk,encoding='utf8')``\n \n* 第三个：response.end方法，具体来说每一个响应的结束，必须要调用这个方法，然后服务器会认为这条信息已经发送完毕了。\n\n综合效果来说，当我们访问：``http://127.0.0.1:8888/``时，浏览器会出现：\n``Hello world!``\n\n### 6.函数式编程\n所谓函数式编程，简单的理解，就是将函数作为参数传递；\n目前有四个文件：\n``index.js``\n```js\nvar server = require(\"./server\");   //调用该模块\nvar router = require(\"./router\");\nvar requestHandlers = require(\"./requestHandlers\");\n\nvar handle = {};\nhandle[\"/\"] = requestHandlers.start;\nhandle[\"/start\"] = requestHandlers.start;\nhandle[\"/upload\"] = requestHandlers.upload;\n\nserver.start(router.route, handle);   //调用该模块的方法（注意方法名是test.js中exports后面的变量名）\n```\n\n``server.js``\n```js\nvar http = require(\"http\");\nvar url = require(\"url\");\nfunction start(route, handle) {\n    var count = 0;\n\n    function onRequest(request, response) {\n        console.log(count++ + \"#:\");\n        var pathname = url.parse(request.url).pathname;\n        console.log(\"Request for \" + pathname + \" recived.\");\n\n        route(handle, pathname);    //来源于上面的start的参数\n\n        response.writeHead(200);\n        response.write(\"Hello word!\");\n        response.end();\n    }\n\n    http.createServer(onRequest).listen(8888);\n    console.log(\"Server has started!\");\n}\nexports.start = start;\n```\n\n``router.js``\n```js\nfunction route(handle, pathname) {\n    console.log(\"About to route a request for \" + pathname);\n    if (typeof handle[pathname] === 'function') {\n        handle[pathname]();\n    } else {\n        console.log(\"No request handler found for \" + pathname);\n    }\n}\n\nexports.route = route;\n```\n\n``requestHandler.js``\n```js\nfunction start() {\n    console.log(\"Request handler 'start' was called\");\n}\n\nfunction upload() {\n    console.log(\"Request handler 'upload' was called\");\n}\n\nexports.start = start;\nexports.upload = upload;\n```\n分析：\n* ①首先看index.js，他调用了3个模块，然后声明了一个空的对象，然后给这个对象声明了几个不同的变量（准确的说是函数变量），他们分别对应requestHandlers这个模块的不同函数；\n \n调用server这个模块的start方法，传两个参数，分别是router模块的route方法和对象handle（包含3个函数变量）；\n \n* ②由于调用了server模块的start方法，因此我们来看server模块；\n在server模块中，调用了两个模块，分别是http和url，这两个都是NodeJs自带的，具体里面的内容就不一一分析了（前面已经说明过了）。\n \n在servre模块的start函数（也是index.js调用的方法），有两个参数，第一个参数是route函数（来源于router模块），第二个参数是一个对象（来源于index.js）。\n \n而在start函数中，调用了其第一个参数（route函数），由于这个参数是函数，因此运行它，给其两个参数，分别是handle（来源于index.js的对象）和pathname（来源于当前模块，是用户请求的路径）；\n \n因此接下来我们看router模块的route函数，记得，这个函数传递了一个对象和一个路径；\n \n* ③在router模块中，传递了两个参数，并进行了一次判断；\n判断的逻辑是这样的，第一个参数（是一个对象），其加上下标后的值，如果是类型是函数，那么执行这个函数；如果不是函数，提示没找到该句柄；\n \n请注意，为什么说这个对象加上下标是函数呢，原因在于index中声明的这个对象，而这个对象的三个带下标的变量都是函数；\n \n而这三个被执行函数来源于哪呢？来源于index里加载的模块requestHandlers，那么最后让我们来看看这个模块；\n \n* ④在这个模块里，只有两个函数，分别是start和upload；\n这两个函数输出不同的内容（一个关键字是start，另一个关键字是upload）；\n请回想之前的下标，下标分为三个，分别是空（/），start下标（/start），和upload下标（/upload），因此当用户访问根目录、start目录、和upload目录时，调用对应的方法，而若访问其他目录（包括start目录的子目录等时，提示错误——来源于router模块）；\n![](http://img.blog.csdn.net/20160602214830419)\n现在回顾这种模式是怎么实现的：\n![](http://img.blog.csdn.net/20160602214835576)\n\n### 7.等待函数\n```js\nfunction sleep(milliSeconds) {\n    var startTime = new Date().getTime();\n    while (new Date() < startTime + milliSeconds);  //等待参数的时间\n}\n```\n传的参数是毫秒，在这个时间前，无法执行下一句代码，类似C++的Sleep()函数\n\n### 8.返回的两种格式\n```js\nresponse.writeHead(200, {\"Content-Type\": \"text/html\"});\nresponse.write(content);\nresponse.end();\n```\n其中，writeHead里面的第二个参数，有多种格式，分别是：\napplication/xml 、 text/xml、text/html、text/plain\n经查：\ntext/html是html格式的正文 \ntext/plain是无格式正文\ntext/xml忽略xml头所指定编码格式而默认采用us-ascii编码\napplication/xml会根据xml头指定的编码格式来编码：\n简单来说，html就是返回一个html，plain就是无格式的，写什么就是什么，xml就是一个xml文件；\n\n### 9.关于事件监听\n之前说到有\n```js\nfunction onRequest(request, response)\n```\n这样一个回调函数，其中request是请求，response是回应；\n根据推测，每次request的，都会触发至少一个data，一个end事件，因此应该监听这两个事件。（并且只有接受到data之后，才会接收到end事件）；\n我们之前是不监听的，只要有请求，就直接执行某个函数，而监听表示只有这些事件触发后，我们才会执行某一段代码。\n因此我们这么写：\n```js\nvar postData = \"\";\nrequest.setEncoding(\"utf8\");\nrequest.addListener(\"data\", function (postDataChunk) {      //data事件\n    postData += postDataChunk;\n    console.log(\"Received POST data chunk \" + postDataChunk + \".\");\n    console.log(\"————————\");\n})\nrequest.addListener(\"end\", function () {\n    route(handle, pathname, response, postData);\n})\n```\n表示监听的编码类型为UTF8，监听data事件，把内容加起来，监听end事件，把加起来的内容发送出去。\n直到end事件触发时，才会执行之前写的route函数（也就是那个写回复的函数）。\n \nPS：\n根据我的测试，如果data事件注释掉，end事件会无法执行，准确的说，是无法访问任何url的。\n但是，如果不注释掉，只是普通的访问的话，可是又不会触发data监听事件里面的console.log代码，很奇怪； \n另外，注释掉end事件，留着data事件，也会卡住； ","html":"<h3 id=\"1\">1.如何封装一个模块；</h3>\n\n首先，我们建立一个js文件，例如命名为test.js；\n然后在里面写一个函数，函数名任意；\n然后通过exports.变量名，将函数赋值给这个变量；\n如代码：\n<!-- more -->  \n\n<pre><code class=\"language-js\">function test(){    //请注意这个函数名  \n    console.log(\"1\");\n}\nexports.testBegin= test;   //等号后面的test，指的是上面的函数名。等号前面的testBegin，是调用时的函数名（注意区别）  \n</code></pre>\n\n<p>这个test.js的文件就写完了，这是一个模块，他的效果是调用该函数后，输出1；\n另外，不要问我这个exports是什么，我暂时也不知道。</p>\n\n<h2 id=\"2\">2.如何调用一个模块</h2>\n\n<p>在封装模块的前提下，我们新建一个文件，例如a.js，来调用之前封装的test.js模块；\n方法是：</p>\n\n<pre><code class=\"language-js\">var test = require(\"./test\");   //调用该模块  \ntest.testBegin();   //调用该模块的方法（注意方法名是test.js中exports后面的变量名）；  \n</code></pre>\n\n<p>注意调用时的方法名，并非是test.js中的函数名test；</p>\n\n<h3 id=\"3nodejs\">3.如何执行一个Node.js的文件</h3>\n\n<p>我们现在需要执行a.js这个调用了封装模块的文件了，执行他的方法，和执行普通的node.js的文件的方法并没有什么不同；\n在a.js这个文件的目录下，打开命令行。windows是shift＋鼠标右键；\n像下面这样输入即可：\n然后将输出1，感觉执行执行Python文件那样</p>\n\n<h3 id=\"4\">4.获得访问者想要访问的路径</h3>\n\n<p><img src=\"http://img.blog.csdn.net/20160602214711294\" alt=\"\" />\n首先上图，其中pathname指的是路径；而query指的是请求之类的东西（暂时不关心）；\n假如我们想要获得pathname（即字符串“start”），我们该怎么办呢？\n方法：\n* ①首先，需要获取访问者需要访问的路径，方法是通过http的方法createServer\n具体来说：\n我们先require一个http模块：</p>\n\n<pre><code class=\"language-js\">var http = require(\"http\");  \n</code></pre>\n\n<p>然后调用其方法，创建一个服务器：</p>\n\n<pre><code class=\"language-js\">http.createServer(onRequest).listen(8888);  \n</code></pre>\n\n<p>注意，这个方法监听的是8888端口，其参数是一个函数；</p>\n\n<p>然后我们书写这个函数的内容：</p>\n\n<pre><code class=\"language-js\">function onRequest(request, response) {  \n    console.log(request.url);\n}\n</code></pre>\n\n<p>这个函数的第一个参数request是用户访问的一些东西，我们需要的是其url变量；假设我们访问地址是这样的：\n<code>http://127.0.0.1:8888/index/loading?start</code>\n请注意红色部分，那么服务器在console.log输出的是</p>\n\n<pre><code>/index/loading?start\n</code></pre>\n\n<ul>\n<li>②我们下来要对这个url做点什么了；\n虽然直接对上面那个参数进行操纵也可以，但这太笨了，让我们来require一个新的模块url</li>\n</ul>\n\n<pre><code class=\"language-js\">var url = require(\"url\");  \n</code></pre>\n\n<ul>\n<li>③调用这个新模块的方法parse，将第一步获得的url地址，作为其参数，再调用其方法pathname，就可以获得我们想要的东西了；\n具体而言，需要这么一段代码：</li>\n</ul>\n\n<pre><code class=\"language-js\">var pathname = url.parse(request.url).pathname;  \n</code></pre>\n\n<p>这个pathname就是我们需要的东西了；</p>\n\n<p>把所有代码综合起来，是这样的：</p>\n\n<pre><code class=\"language-js\">var http = require(\"http\");  \nvar url = require(\"url\");  \nfunction onRequest(request, response) {  \n    var pathname = url.parse(request.url).pathname;\n    console.log(\"Request for \" + pathname + \" recived.\");\n    response.writeHead(200, {\"Content-type\": \"text/plain\"});\n    response.write(\"Hello word!\");\n    response.end();\n}\nhttp.createServer(onRequest).listen(8888);  \nconsole.log(\"Server has started!\");  \n</code></pre>\n\n<p>然后运行之：</p>\n\n<p>我们随便访问一个本地的地址：\n<code>http://127.0.0.1:8888/index/loading?start</code></p>\n\n<p>发现，/index/loding这部分被正常的显示出来了。\n另外，favicon.ico是该网站的图标，据说很多服务器是会默认读取的；</p>\n\n<p>假如我们直接访问：<code>http://127.0.0.1:8888</code>，显示是这样的\n<img src=\"http://img.blog.csdn.net/20160602214745169\" alt=\"\" /></p>\n\n<h3 id=\"5http\">5.关于http</h3>\n\n<p>我们之前有了这么一段代码（已delete掉无关部分）：</p>\n\n<pre><code class=\"language-js\">var http = require(\"http\");  \nfunction onRequest(request, response) {  \n    response.writeHead(200, {\"Content-type\": \"text/plain\"});\n    response.write(\"Hello word!\");\n    response.end();\n}\nhttp.createServer(onRequest).listen(8888);  \n</code></pre>\n\n<p>其中，http调用了NodeJs自带的一个模块“http”，而这个模块是一个服务器模块；\n而createServer是这个模块的方法，效果是返回一个对象，而这个对象有一个listen的方法；\n当然，由于你和我，也许都是新手，因此我们尚没有搞清楚这个到底是怎么运作的；但如果有一定经验的话，可以猜到，这个listen是监听，监听的是8888端口；如果去掉这部分会怎么样？经过测试，服务器并没有运行，如图：</p>\n\n<p>而onRequest函数呢，从名字可以猜到，这个函数的效果是“当请求的时候做些什么”，我们来看其函数：</p>\n\n<pre><code class=\"language-js\">function onRequest(request, response) {  \n    response.writeHead(200);\n    response.write(\"Hello word!\");\n    response.end();\n}\n</code></pre>\n\n<p>这个函数有两个参数：request和response，顾名思义，请求和响应。\nrequest请求指用户访问的时候，相关的信息； <br />\nresponse指服务器的响应，会做些什么；这个函数的三个方法，都是response相关的；</p>\n\n<ul>\n<li><p>第一个：response.writeHead方法，具体来说，就是HTTP响应报文的头行；\n这个指HTTP通信的响应报文中的头部分，如果没有基础的话，暂时不需要关心，写200即可，这里的200，是约定俗称的请求成功时的返回；\n具体搜：\n<code>response.writeHead(statusCode,[reasonPhrase], [headers])</code></p></li>\n<li><p>第二个：response.write方法，具体来说，是HTTP响应报文；\n简单理解，负责发送正文中的一部分，可以同时发送多个不一样的；\n在上面搜：\n<code>response.write(chunk,encoding='utf8')</code></p></li>\n<li><p>第三个：response.end方法，具体来说每一个响应的结束，必须要调用这个方法，然后服务器会认为这条信息已经发送完毕了。</p></li>\n</ul>\n\n<p>综合效果来说，当我们访问：<code>http://127.0.0.1:8888/</code>时，浏览器会出现：\n<code>Hello world!</code></p>\n\n<h3 id=\"6\">6.函数式编程</h3>\n\n<p>所谓函数式编程，简单的理解，就是将函数作为参数传递；\n目前有四个文件：\n<code>index.js</code></p>\n\n<pre><code class=\"language-js\">var server = require(\"./server\");   //调用该模块  \nvar router = require(\"./router\");  \nvar requestHandlers = require(\"./requestHandlers\");\n\nvar handle = {};  \nhandle[\"/\"] = requestHandlers.start;  \nhandle[\"/start\"] = requestHandlers.start;  \nhandle[\"/upload\"] = requestHandlers.upload;\n\nserver.start(router.route, handle);   //调用该模块的方法（注意方法名是test.js中exports后面的变量名）  \n</code></pre>\n\n<p><code>server.js</code></p>\n\n<pre><code class=\"language-js\">var http = require(\"http\");  \nvar url = require(\"url\");  \nfunction start(route, handle) {  \n    var count = 0;\n\n    function onRequest(request, response) {\n        console.log(count++ + \"#:\");\n        var pathname = url.parse(request.url).pathname;\n        console.log(\"Request for \" + pathname + \" recived.\");\n\n        route(handle, pathname);    //来源于上面的start的参数\n\n        response.writeHead(200);\n        response.write(\"Hello word!\");\n        response.end();\n    }\n\n    http.createServer(onRequest).listen(8888);\n    console.log(\"Server has started!\");\n}\nexports.start = start;  \n</code></pre>\n\n<p><code>router.js</code></p>\n\n<pre><code class=\"language-js\">function route(handle, pathname) {  \n    console.log(\"About to route a request for \" + pathname);\n    if (typeof handle[pathname] === 'function') {\n        handle[pathname]();\n    } else {\n        console.log(\"No request handler found for \" + pathname);\n    }\n}\n\nexports.route = route;  \n</code></pre>\n\n<p><code>requestHandler.js</code></p>\n\n<pre><code class=\"language-js\">function start() {  \n    console.log(\"Request handler 'start' was called\");\n}\n\nfunction upload() {  \n    console.log(\"Request handler 'upload' was called\");\n}\n\nexports.start = start;  \nexports.upload = upload;  \n</code></pre>\n\n<p>分析：\n* ①首先看index.js，他调用了3个模块，然后声明了一个空的对象，然后给这个对象声明了几个不同的变量（准确的说是函数变量），他们分别对应requestHandlers这个模块的不同函数；</p>\n\n<p>调用server这个模块的start方法，传两个参数，分别是router模块的route方法和对象handle（包含3个函数变量）；</p>\n\n<ul>\n<li>②由于调用了server模块的start方法，因此我们来看server模块；\n在server模块中，调用了两个模块，分别是http和url，这两个都是NodeJs自带的，具体里面的内容就不一一分析了（前面已经说明过了）。</li>\n</ul>\n\n<p>在servre模块的start函数（也是index.js调用的方法），有两个参数，第一个参数是route函数（来源于router模块），第二个参数是一个对象（来源于index.js）。</p>\n\n<p>而在start函数中，调用了其第一个参数（route函数），由于这个参数是函数，因此运行它，给其两个参数，分别是handle（来源于index.js的对象）和pathname（来源于当前模块，是用户请求的路径）；</p>\n\n<p>因此接下来我们看router模块的route函数，记得，这个函数传递了一个对象和一个路径；</p>\n\n<ul>\n<li>③在router模块中，传递了两个参数，并进行了一次判断；\n判断的逻辑是这样的，第一个参数（是一个对象），其加上下标后的值，如果是类型是函数，那么执行这个函数；如果不是函数，提示没找到该句柄；</li>\n</ul>\n\n<p>请注意，为什么说这个对象加上下标是函数呢，原因在于index中声明的这个对象，而这个对象的三个带下标的变量都是函数；</p>\n\n<p>而这三个被执行函数来源于哪呢？来源于index里加载的模块requestHandlers，那么最后让我们来看看这个模块；</p>\n\n<ul>\n<li>④在这个模块里，只有两个函数，分别是start和upload；\n这两个函数输出不同的内容（一个关键字是start，另一个关键字是upload）；\n请回想之前的下标，下标分为三个，分别是空（/），start下标（/start），和upload下标（/upload），因此当用户访问根目录、start目录、和upload目录时，调用对应的方法，而若访问其他目录（包括start目录的子目录等时，提示错误——来源于router模块）；\n<img src=\"http://img.blog.csdn.net/20160602214830419\" alt=\"\" />\n现在回顾这种模式是怎么实现的：\n<img src=\"http://img.blog.csdn.net/20160602214835576\" alt=\"\" /></li>\n</ul>\n\n<h3 id=\"7\">7.等待函数</h3>\n\n<pre><code class=\"language-js\">function sleep(milliSeconds) {  \n    var startTime = new Date().getTime();\n    while (new Date() &lt; startTime + milliSeconds);  //等待参数的时间\n}\n</code></pre>\n\n<p>传的参数是毫秒，在这个时间前，无法执行下一句代码，类似C++的Sleep()函数</p>\n\n<h3 id=\"8\">8.返回的两种格式</h3>\n\n<pre><code class=\"language-js\">response.writeHead(200, {\"Content-Type\": \"text/html\"});  \nresponse.write(content);  \nresponse.end();  \n</code></pre>\n\n<p>其中，writeHead里面的第二个参数，有多种格式，分别是：\napplication/xml 、 text/xml、text/html、text/plain <br />\n经查：\ntext/html是html格式的正文 <br />\ntext/plain是无格式正文 <br />\ntext/xml忽略xml头所指定编码格式而默认采用us-ascii编码 <br />\napplication/xml会根据xml头指定的编码格式来编码： <br />\n简单来说，html就是返回一个html，plain就是无格式的，写什么就是什么，xml就是一个xml文件；</p>\n\n<h3 id=\"9\">9.关于事件监听</h3>\n\n<p>之前说到有</p>\n\n<pre><code class=\"language-js\">function onRequest(request, response)  \n</code></pre>\n\n<p>这样一个回调函数，其中request是请求，response是回应；\n根据推测，每次request的，都会触发至少一个data，一个end事件，因此应该监听这两个事件。（并且只有接受到data之后，才会接收到end事件）；\n我们之前是不监听的，只要有请求，就直接执行某个函数，而监听表示只有这些事件触发后，我们才会执行某一段代码。\n因此我们这么写：</p>\n\n<pre><code class=\"language-js\">var postData = \"\";  \nrequest.setEncoding(\"utf8\");  \nrequest.addListener(\"data\", function (postDataChunk) {      //data事件  \n    postData += postDataChunk;\n    console.log(\"Received POST data chunk \" + postDataChunk + \".\");\n    console.log(\"————————\");\n})\nrequest.addListener(\"end\", function () {  \n    route(handle, pathname, response, postData);\n})\n</code></pre>\n\n<p>表示监听的编码类型为UTF8，监听data事件，把内容加起来，监听end事件，把加起来的内容发送出去。\n直到end事件触发时，才会执行之前写的route函数（也就是那个写回复的函数）。</p>\n\n<p>PS： <br />\n根据我的测试，如果data事件注释掉，end事件会无法执行，准确的说，是无法访问任何url的。\n但是，如果不注释掉，只是普通的访问的话，可是又不会触发data监听事件里面的console.log代码，很奇怪； \n另外，注释掉end事件，留着data事件，也会卡住； </p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495700757623,"created_by":1,"updated_at":1495700841924,"updated_by":1,"published_at":1475308380000,"published_by":1},{"id":24,"uuid":"ad35be04-b58f-4355-938b-8e4f82763a9a","title":"Node.js(2) MySQL","slug":"nodejs-2","markdown":"MySQL是mysql-5.6.17\nnodejs是目前最新版。\n\n# ①安装nodejs的mysql模块\n如果你的nodejs的版本比较新的话，应该不存在安装路径问题；\n在你想要运行nodejs文件的根路径，启动命令行（shift+鼠标右键）；\n输入：\n``npm install mysql``\n \n正常的话，应该出的是一个带树形结构的图，比如这样：\n![](http://p1.bpimg.com/567571/8a56c4679605be87.png)\n\n如果差别过大，可能是出问题了，那么新建一个js文件，把以下内容复制粘贴进去\n注意修改mysql的账号名、密码，而端口号3306是默认的；\n```js\nvar mysql  = require('mysql');  //调用MySQL模块  \n  \n//创建一个connection  \nvar connection = mysql.createConnection({  \n    host     : '127.0.0.1',       //主机  \n    user     : 'root',               //MySQL认证用户名  \n    password : '',        //MySQL认证用户密码  \n    port: '3306',                   //端口号  \n});  \n//创建一个connection  \nconnection.connect(function(err){  \n    if(err){  \n        console.log('[query] - :'+err);  \n        return;  \n    }  \n    console.log('[connection connect]  succeed!');  \n});  \n//执行SQL语句  \nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {  \n    if (err) {  \n        console.log('[query] - :'+err);  \n        return;  \n    }  \n    console.log('The solution is: ', rows[0].solution);  \n});  \n//关闭connection  \nconnection.end(function(err){  \n    if(err){  \n        return;  \n    }  \n    console.log('[connection end] succeed!');  \n});  \n```\n如果正常运行的话，可以从控制台console.log出来的消息确认（具体请看代码）；\n\n# ②mysql的增add：\n假如我想在mysql里，数据库（database）名为test，表名为a_test_table插入数据。\n假设你只装了mysql，却不懂mysql，那么这里我推荐你安装mysql-5.6.17-winx64这个版本，这样可以保证代码正常执行。\n然后进入mysql，默认账号名为root，默认密码为空；\n【以下代码注意结尾的分号，分号表示一条命令的结束】\n \n输入showdatabases;\n可以查看库名。应该有一个test库，如下图：\n![](http://p1.bpimg.com/567571/e7ee7e55bcf03dd5.png)\n如果没有的话，请自行搜索如何创建一个库；\n然后输入usetest;\n进入test表；然后输入show tables;\n显示test库下面的所有表，如下图：\n![](http://p1.bpimg.com/567571/76a59ac469b33b45.png)\n\n当然，正常来说，你这里应该是空。于是我们需要建表，为了方便，建一个最简单的表，输入以下命令：\ncreate table a_test_table(\nid int,\nname varchar(20));\n创建一个表，他只有两个字段，分别是id（int类型表示数字），name（字符类型）。此时再打show tables;  便可以看到a_test_table这个表了；\n再输入elect* from a_test_table;\n查询表内容，会显示空：\n![](http://img.blog.csdn.net/20160612152004210)\n\n下来开始正文，如何在这个表里插入内容：\n首先，新建一个js文件，记得使用utf-8格式。\n下面是代码，具体请看注释：\n```js\nvar mysql = require('mysql');  //调用MySQL模块  \n  \n//创建一个connection  \nvar connection = mysql.createConnection({  \n    host: '127.0.0.1',       //主机地址  \n    user: 'root',               //MySQL认证用户名  \n    password: '',        //MySQL认证用户密码  \n    port: '3306',                   //端口号  \n    database: 'test',                //库名  \n});  \n//创建一个connection，即连接到mysql的对象，如果连接错误，会提示错误。  \nconnection.connect(function (err) {  \n    if (err) {  \n        console.log('[query] - :' + err);  \n        return;  \n    }  \n    console.log('[connection connect]  succeed!');  \n});  \n  \nvar userAddSql = 'INSERT INTO a_test_table(id, name) VALUES(?,?)';  \n/* \n这里实际上是一个mysql语句， \n关键是第三个a_table_test表示表名； \nid和name表示字段名； \n两个问号表示插入的值，如果不是问号，而是一个值，那么表示这个字段固定插入这个值 \n*/  \nvar userAddSql_value = [1, 'wddddd'];       //这里实际依次对应的是上面2个问号，因为id是int，所以第一个是数字，第二个是字符串  \n  \nconnection.query(userAddSql, userAddSql_value, function (err, result) {  \n    if (err) {  \n        console.log('[INSERT ERROR] - ', err.message);  \n        return;  \n    }  \n  \n    console.log('——————————————INSERT————————————————');  \n    console.log('INSERT ID: ', result);  \n    console.log('—————————————————————————————————');  \n})  \n  \n//关闭connection  \nconnection.end(function (err) {  \n    if (err) {  \n        return;  \n    }  \n    console.log('[connection end] succeed!');  \n});  \n```\n如果显示错误，请检查自己的nodejs代码，一般问题常发生在账号名、密码、库名、表名等。\n\n# ③查select：\n有没有发现代码的特点，他的关键是mysql的命令，只要我们更改命令，完全可以像直接在mysql里输入命令行一样操控mysql，例如，我们只需要改这么一段代码：\n```js\nvar userAddSql = 'SELECT * FORM a_test_table';\n```\n即使完全不动其他代码，那么回调函数也能正常运行，其表现应该是这样：\n![](http://img.blog.csdn.net/20160612152125384)\n当然，完全不改是不好的，但无论如何，我们需要的功能是实现了。\n另外，显而易见，我们需要对返回内容进行操纵，那么首先我们需要明确返回内容是什么？结论是，他是一个数组（从 [] 可以猜出），然后我们这个数组只有一项，因此加上下标[0]，假如我们需要获取name属性，那么就是result[0].name；\n总得来说，代码在之前的基础上这么修改：\n把\n```js\nconsole.log('INSERT ID: ', result);  \n```\n修改为：\n```js\nconsole.log(result[0].name);\n```\n然后再次执行js文件，显示结果应该是这样：\n![](http://img.blog.csdn.net/20160612152225291)\n\n# ④删delete\n是不是感觉很简单，让我们Go on\n这次我们要删除id=1的那一项（因为id是唯一的，不会删错）——虽然我们其实就一项\n在之前代码上继续修改：\n```js\nvar userAddSql = 'DELETE FROM a_test_table WHERE id = 1';  //之所以大写mysql的指令，是为了和数据区分，事实上不大写也是可以的\n```\n然后执行之；\n毫无疑问，代码会报错，但是并非我们删除命令错误了，而是因为之前的代码，会输出结果的name属性，显然咯，都被删除了，哪有name属性；\n为了证明我们删除命令并没错，在mysql里进行查询：\n![](http://img.blog.csdn.net/20160612152323055)\n我们可以发现，我们需要删除的那一项被删除了。\n\n# ⑤改update\n增删查改，我们只剩下改了。但是目前mysql表里没内容，我们需要重新加上一些mysql信息。\n一次插入多条数据：\n```js\nvar userAddSql_value = [[1, 'a'], [2, 'd']];  \n  \nfor (var i = 0; i < userAddSql_value.length; i++) {  \n    connection.query(userAddSql, userAddSql_value[i], function (err, result) {  \n        if (err) {  \n            console.log('[INSERT ERROR] - ', err.message);  \n            return;  \n        }  \n  \n        console.log('——————————————INSERT————————————————');  \n        console.log(result[0].name);  \n        console.log('—————————————————————————————————');  \n    })  \n}  \n```\n然后接下来，我们要修改数据了。\n我们这次的目的，是把id=1的项，name修改为pp\n需要注意的是，所有id=1的项，name属性都将被修改为pp（而不是仅仅只有一个）；\n```js\nvar userAddSql = 'UPDATE a_test_table SET name = ? WHERE id = ?';    \nvar userAddSql_value = [\"pp\", 1];   \nconnection.query(userAddSql, userAddSql_value, function (err, result) {  \n    if (err) {  \n        console.log('[INSERT ERROR] - ', err.message);  \n        return;  \n    }  \n  \n    console.log('——————————————INSERT————————————————');  \n    console.log('INSERT ID: ', result);  \n    console.log('—————————————————————————————————');  \n})  \n```\n运行之，然后再查表，正常的话，你会发现，id=1的项，其值被更为为了pp\n![](http://img.blog.csdn.net/20160612152440545)\n\n# ⑥断线重连\n按照说明，使用连接池的方法更好，不过既然看到了断线重连，虽然挺迷茫，但正常运行了（虽然并不明白，而且感觉有点出入），那就先用着\n代码这么写：\n```js\nvar mysql = require('mysql');  //调用MySQL模块  \n  \n//创建一个connection  \nvar db_config = mysql.createConnection({  \n    host: '127.0.0.1',       //主机地址  \n    user: 'root',               //MySQL认证用户名  \n    password: '',        //MySQL认证用户密码  \n    port: '3306',                   //端口号  \n    database: 'test',                //库名  \n});  \nvar connect;  \nfunction handleDisconnect() {  \n    connect = mysql.createConnection(db_config);    //创建连接（连接的设置是上面）  \n    connect.connect(function (err) {    //大概是指连接，  \n        if (err) {  \n            console.log(\"正在连接中：\" + new Date());  \n            setTimeout(handleDisconnect, 3000);  \n            return;  \n        }  \n        console.log(\"连接成功\");  \n        run();  \n    })  \n    connect.on('error', function (err) {  \n        console.log('db error', err);  \n        if (err.code === 'PROTOCOL_CONNECTION_SET') {  \n            handleDisconnect();  \n        } else {  \n            throw err;  \n        }  \n    })  \n}  \nhandleDisconnect();  \nfunction run() {  \n    db_config.connect(function (err) {  \n        if (err) {  \n            console.log('[query] - :' + err);  \n            return;  \n        }  \n        console.log('[connection connect]  succeed!');  \n    });  \n  \n    var userAddSql = 'UPDATE a_test_table SET name = ? WHERE id = ?';  \n    var userAddSql_value = [\"www\", 1];  \n  \n    db_config.query(userAddSql, userAddSql_value, function (err, result) {  \n        if (err) {  \n            console.log('[INSERT ERROR] - ', err.message);  \n            return;  \n        }  \n  \n        console.log('——————————————INSERT————————————————');  \n        console.log('INSERT ID: ', result);  \n        console.log('—————————————————————————————————');  \n    })  \n  \n  \n//关闭connection  \n    db_config.end(function (err) {  \n        if (err) {  \n            return;  \n        }  \n        console.log('[connection end] succeed!');  \n    });  \n}  \n```\n\n# ⑦连接池：\n然后我试了试连接池的方法：\n```js\nvar mysql = require('mysql');  \nvar pool = mysql.createPool({  \n    host: 'localhost',  \n    user: 'root',  \n    password: '',  \n    database: 'test',  \n    debug: false,  \n});  \n  \nvar insert = function (connection, data) {  \n    connection.query('INSERT INTO a_test_table SET ?', data, function (err, result) {  \n        console.log('ID : ' + result.insertId);  \n    });  \n};  \n  \nvar update = function (connection, data) {  \n    connection.query('UPDATE a_test_table SET name = ? WHERE id = ?', data, function (err, result) {  \n    });  \n};  \n  \nvar select = function (connection) {  \n    connection.query('SELECT * FROM a_test_table', function (err, result) {  \n        result.forEach(function (user) {  \n            console.log(user.id + ':' + user.name + ':');  \n        });  \n    });  \n};  \n  \npool.getConnection(function (err, connection) {  \n    var data = ['www', 1];  \n    select(connection);  \n    update(connection, data);  \n    select(connection);  \n});  \n  \nconsole.log('mysql is start!');  \n``` \n然后我尝试停用了mysql，运行这段代码，发现，停用后无法连接，并报错；如果是正在连接，那么会自动断掉连接。\n \n不是很明白如何断线重连。\n \n也许是假如断线了，就运行这个pool.getConnection这句代码？\n但是如何判断呢？不清楚\n \n像下面这么写么？假如没连上，的确可以尝试重复连接，但是如果连接上的时候，断掉了，却不会继续重连。\n```js\nfunction toConnet() {  \n    pool.getConnection(function (err, connection) {  \n        if (err) {  \n            console.log(\"连接中：\" + err);  \n            setTimeout(toConnet, 2000);  \n        } else {  \n            var data = ['bbbb', 1];  \n            select(connection);  \n            update(connection, data);  \n            select(connection);  \n        }  \n    })  \n}  \ntoConnet();  \n```\n下面的表示链接成功了\n![](http://img.blog.csdn.net/20160612152611657)\n\n# ⑧防止SQL注入：\n使用方法：escape()\n具体用法是：\n不过貌似nodejs本身就带有一定的防注入功能。例如，我把data改为：\n```js\nvar data = [\"'bbbb', id = 2\", 1];  \n```\n这样拼接出来的sql代码应该是：\nUPDATE a_test_table SET name = 'bbbb', id = 2 WHERE id = 1\n运行这个js文件后，会发现结果变成这样：\n![](http://img.blog.csdn.net/20160612153243840)\n但若在mysql里面运行这段代码：\n结果变成这样：\n![](http://img.blog.csdn.net/20160612153302712)\n说明我们拼接的代码是没错的，只是mysql防止了这种简单的sql注入攻击。","html":"<p>MySQL是mysql-5.6.17 <br />\nnodejs是目前最新版。</p>\n\n<h1 id=\"nodejsmysql\">①安装nodejs的mysql模块</h1>\n\n<p>如果你的nodejs的版本比较新的话，应该不存在安装路径问题；\n在你想要运行nodejs文件的根路径，启动命令行（shift+鼠标右键）；\n输入：\n<code>npm install mysql</code></p>\n\n<p>正常的话，应该出的是一个带树形结构的图，比如这样：\n<img src=\"http://p1.bpimg.com/567571/8a56c4679605be87.png\" alt=\"\" /></p>\n\n<p>如果差别过大，可能是出问题了，那么新建一个js文件，把以下内容复制粘贴进去\n注意修改mysql的账号名、密码，而端口号3306是默认的；</p>\n\n<pre><code class=\"language-js\">var mysql  = require('mysql');  //调用MySQL模块  \n\n//创建一个connection  \nvar connection = mysql.createConnection({  \n    host     : '127.0.0.1',       //主机  \n    user     : 'root',               //MySQL认证用户名  \n    password : '',        //MySQL认证用户密码  \n    port: '3306',                   //端口号  \n});  \n//创建一个connection  \nconnection.connect(function(err){  \n    if(err){  \n        console.log('[query] - :'+err);  \n        return;  \n    }  \n    console.log('[connection connect]  succeed!');  \n});  \n//执行SQL语句  \nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {  \n    if (err) {  \n        console.log('[query] - :'+err);  \n        return;  \n    }  \n    console.log('The solution is: ', rows[0].solution);  \n});  \n//关闭connection  \nconnection.end(function(err){  \n    if(err){  \n        return;  \n    }  \n    console.log('[connection end] succeed!');  \n});  \n</code></pre>\n\n<p>如果正常运行的话，可以从控制台console.log出来的消息确认（具体请看代码）；</p>\n\n<h1 id=\"mysqladd\">②mysql的增add：</h1>\n\n<p>假如我想在mysql里，数据库（database）名为test，表名为a<em>test</em>table插入数据。\n假设你只装了mysql，却不懂mysql，那么这里我推荐你安装mysql-5.6.17-winx64这个版本，这样可以保证代码正常执行。\n然后进入mysql，默认账号名为root，默认密码为空；\n【以下代码注意结尾的分号，分号表示一条命令的结束】</p>\n\n<p>输入showdatabases;\n可以查看库名。应该有一个test库，如下图：\n<img src=\"http://p1.bpimg.com/567571/e7ee7e55bcf03dd5.png\" alt=\"\" />\n如果没有的话，请自行搜索如何创建一个库；\n然后输入usetest;\n进入test表；然后输入show tables;\n显示test库下面的所有表，如下图：\n<img src=\"http://p1.bpimg.com/567571/76a59ac469b33b45.png\" alt=\"\" /></p>\n\n<p>当然，正常来说，你这里应该是空。于是我们需要建表，为了方便，建一个最简单的表，输入以下命令：\ncreate table a<em>test</em>table( <br />\nid int, <br />\nname varchar(20)); <br />\n创建一个表，他只有两个字段，分别是id（int类型表示数字），name（字符类型）。此时再打show tables;  便可以看到a<em>test</em>table这个表了；\n再输入elect* from a<em>test</em>table;\n查询表内容，会显示空：\n<img src=\"http://img.blog.csdn.net/20160612152004210\" alt=\"\" /></p>\n\n<p>下来开始正文，如何在这个表里插入内容：\n首先，新建一个js文件，记得使用utf-8格式。\n下面是代码，具体请看注释：</p>\n\n<pre><code class=\"language-js\">var mysql = require('mysql');  //调用MySQL模块  \n\n//创建一个connection  \nvar connection = mysql.createConnection({  \n    host: '127.0.0.1',       //主机地址  \n    user: 'root',               //MySQL认证用户名  \n    password: '',        //MySQL认证用户密码  \n    port: '3306',                   //端口号  \n    database: 'test',                //库名  \n});  \n//创建一个connection，即连接到mysql的对象，如果连接错误，会提示错误。  \nconnection.connect(function (err) {  \n    if (err) {  \n        console.log('[query] - :' + err);  \n        return;  \n    }  \n    console.log('[connection connect]  succeed!');  \n});  \n\nvar userAddSql = 'INSERT INTO a_test_table(id, name) VALUES(?,?)';  \n/* \n这里实际上是一个mysql语句， \n关键是第三个a_table_test表示表名； \nid和name表示字段名；  \n两个问号表示插入的值，如果不是问号，而是一个值，那么表示这个字段固定插入这个值 \n*/  \nvar userAddSql_value = [1, 'wddddd'];       //这里实际依次对应的是上面2个问号，因为id是int，所以第一个是数字，第二个是字符串  \n\nconnection.query(userAddSql, userAddSql_value, function (err, result) {  \n    if (err) {  \n        console.log('[INSERT ERROR] - ', err.message);  \n        return;  \n    }  \n\n    console.log('——————————————INSERT————————————————');  \n    console.log('INSERT ID: ', result);  \n    console.log('—————————————————————————————————');  \n})  \n\n//关闭connection  \nconnection.end(function (err) {  \n    if (err) {  \n        return;  \n    }  \n    console.log('[connection end] succeed!');  \n});  \n</code></pre>\n\n<p>如果显示错误，请检查自己的nodejs代码，一般问题常发生在账号名、密码、库名、表名等。</p>\n\n<h1 id=\"select\">③查select：</h1>\n\n<p>有没有发现代码的特点，他的关键是mysql的命令，只要我们更改命令，完全可以像直接在mysql里输入命令行一样操控mysql，例如，我们只需要改这么一段代码：</p>\n\n<pre><code class=\"language-js\">var userAddSql = 'SELECT * FORM a_test_table';  \n</code></pre>\n\n<p>即使完全不动其他代码，那么回调函数也能正常运行，其表现应该是这样：\n<img src=\"http://img.blog.csdn.net/20160612152125384\" alt=\"\" />\n当然，完全不改是不好的，但无论如何，我们需要的功能是实现了。\n另外，显而易见，我们需要对返回内容进行操纵，那么首先我们需要明确返回内容是什么？结论是，他是一个数组（从 [] 可以猜出），然后我们这个数组只有一项，因此加上下标[0]，假如我们需要获取name属性，那么就是result[0].name；\n总得来说，代码在之前的基础上这么修改：\n把</p>\n\n<pre><code class=\"language-js\">console.log('INSERT ID: ', result);  \n</code></pre>\n\n<p>修改为：</p>\n\n<pre><code class=\"language-js\">console.log(result[0].name);  \n</code></pre>\n\n<p>然后再次执行js文件，显示结果应该是这样：\n<img src=\"http://img.blog.csdn.net/20160612152225291\" alt=\"\" /></p>\n\n<h1 id=\"delete\">④删delete</h1>\n\n<p>是不是感觉很简单，让我们Go on\n这次我们要删除id=1的那一项（因为id是唯一的，不会删错）——虽然我们其实就一项\n在之前代码上继续修改：</p>\n\n<pre><code class=\"language-js\">var userAddSql = 'DELETE FROM a_test_table WHERE id = 1';  //之所以大写mysql的指令，是为了和数据区分，事实上不大写也是可以的  \n</code></pre>\n\n<p>然后执行之；\n毫无疑问，代码会报错，但是并非我们删除命令错误了，而是因为之前的代码，会输出结果的name属性，显然咯，都被删除了，哪有name属性；\n为了证明我们删除命令并没错，在mysql里进行查询：\n<img src=\"http://img.blog.csdn.net/20160612152323055\" alt=\"\" />\n我们可以发现，我们需要删除的那一项被删除了。</p>\n\n<h1 id=\"update\">⑤改update</h1>\n\n<p>增删查改，我们只剩下改了。但是目前mysql表里没内容，我们需要重新加上一些mysql信息。\n一次插入多条数据：</p>\n\n<pre><code class=\"language-js\">var userAddSql_value = [[1, 'a'], [2, 'd']];  \n\nfor (var i = 0; i &lt; userAddSql_value.length; i++) {  \n    connection.query(userAddSql, userAddSql_value[i], function (err, result) {  \n        if (err) {  \n            console.log('[INSERT ERROR] - ', err.message);  \n            return;  \n        }  \n\n        console.log('——————————————INSERT————————————————');  \n        console.log(result[0].name);  \n        console.log('—————————————————————————————————');  \n    })  \n}  \n</code></pre>\n\n<p>然后接下来，我们要修改数据了。\n我们这次的目的，是把id=1的项，name修改为pp\n需要注意的是，所有id=1的项，name属性都将被修改为pp（而不是仅仅只有一个）；</p>\n\n<pre><code class=\"language-js\">var userAddSql = 'UPDATE a_test_table SET name = ? WHERE id = ?';  \nvar userAddSql_value = [\"pp\", 1];  \nconnection.query(userAddSql, userAddSql_value, function (err, result) {  \n    if (err) {  \n        console.log('[INSERT ERROR] - ', err.message);  \n        return;  \n    }  \n\n    console.log('——————————————INSERT————————————————');  \n    console.log('INSERT ID: ', result);  \n    console.log('—————————————————————————————————');  \n})  \n</code></pre>\n\n<p>运行之，然后再查表，正常的话，你会发现，id=1的项，其值被更为为了pp\n<img src=\"http://img.blog.csdn.net/20160612152440545\" alt=\"\" /></p>\n\n<h1 id=\"\">⑥断线重连</h1>\n\n<p>按照说明，使用连接池的方法更好，不过既然看到了断线重连，虽然挺迷茫，但正常运行了（虽然并不明白，而且感觉有点出入），那就先用着\n代码这么写：</p>\n\n<pre><code class=\"language-js\">var mysql = require('mysql');  //调用MySQL模块  \n\n//创建一个connection  \nvar db_config = mysql.createConnection({  \n    host: '127.0.0.1',       //主机地址  \n    user: 'root',               //MySQL认证用户名  \n    password: '',        //MySQL认证用户密码  \n    port: '3306',                   //端口号  \n    database: 'test',                //库名  \n});  \nvar connect;  \nfunction handleDisconnect() {  \n    connect = mysql.createConnection(db_config);    //创建连接（连接的设置是上面）  \n    connect.connect(function (err) {    //大概是指连接，  \n        if (err) {  \n            console.log(\"正在连接中：\" + new Date());  \n            setTimeout(handleDisconnect, 3000);  \n            return;  \n        }  \n        console.log(\"连接成功\");  \n        run();  \n    })  \n    connect.on('error', function (err) {  \n        console.log('db error', err);  \n        if (err.code === 'PROTOCOL_CONNECTION_SET') {  \n            handleDisconnect();  \n        } else {  \n            throw err;  \n        }  \n    })  \n}  \nhandleDisconnect();  \nfunction run() {  \n    db_config.connect(function (err) {  \n        if (err) {  \n            console.log('[query] - :' + err);  \n            return;  \n        }  \n        console.log('[connection connect]  succeed!');  \n    });  \n\n    var userAddSql = 'UPDATE a_test_table SET name = ? WHERE id = ?';  \n    var userAddSql_value = [\"www\", 1];  \n\n    db_config.query(userAddSql, userAddSql_value, function (err, result) {  \n        if (err) {  \n            console.log('[INSERT ERROR] - ', err.message);  \n            return;  \n        }  \n\n        console.log('——————————————INSERT————————————————');  \n        console.log('INSERT ID: ', result);  \n        console.log('—————————————————————————————————');  \n    })  \n\n\n//关闭connection  \n    db_config.end(function (err) {  \n        if (err) {  \n            return;  \n        }  \n        console.log('[connection end] succeed!');  \n    });  \n}  \n</code></pre>\n\n<h1 id=\"\">⑦连接池：</h1>\n\n<p>然后我试了试连接池的方法：</p>\n\n<pre><code class=\"language-js\">var mysql = require('mysql');  \nvar pool = mysql.createPool({  \n    host: 'localhost',  \n    user: 'root',  \n    password: '',  \n    database: 'test',  \n    debug: false,  \n});  \n\nvar insert = function (connection, data) {  \n    connection.query('INSERT INTO a_test_table SET ?', data, function (err, result) {  \n        console.log('ID : ' + result.insertId);  \n    });  \n};  \n\nvar update = function (connection, data) {  \n    connection.query('UPDATE a_test_table SET name = ? WHERE id = ?', data, function (err, result) {  \n    });  \n};  \n\nvar select = function (connection) {  \n    connection.query('SELECT * FROM a_test_table', function (err, result) {  \n        result.forEach(function (user) {  \n            console.log(user.id + ':' + user.name + ':');  \n        });  \n    });  \n};  \n\npool.getConnection(function (err, connection) {  \n    var data = ['www', 1];  \n    select(connection);  \n    update(connection, data);  \n    select(connection);  \n});  \n\nconsole.log('mysql is start!');  \n</code></pre>\n\n<p>\n然后我尝试停用了mysql，运行这段代码，发现，停用后无法连接，并报错；如果是正在连接，那么会自动断掉连接。</p>\n\n<p>不是很明白如何断线重连。</p>\n\n<p>也许是假如断线了，就运行这个pool.getConnection这句代码？\n但是如何判断呢？不清楚</p>\n\n<p>像下面这么写么？假如没连上，的确可以尝试重复连接，但是如果连接上的时候，断掉了，却不会继续重连。</p>\n\n<pre><code class=\"language-js\">function toConnet() {  \n    pool.getConnection(function (err, connection) {  \n        if (err) {  \n            console.log(\"连接中：\" + err);  \n            setTimeout(toConnet, 2000);  \n        } else {  \n            var data = ['bbbb', 1];  \n            select(connection);  \n            update(connection, data);  \n            select(connection);  \n        }  \n    })  \n}  \ntoConnet();  \n</code></pre>\n\n<p>下面的表示链接成功了\n<img src=\"http://img.blog.csdn.net/20160612152611657\" alt=\"\" /></p>\n\n<h1 id=\"sql\">⑧防止SQL注入：</h1>\n\n<p>使用方法：escape()\n具体用法是：\n不过貌似nodejs本身就带有一定的防注入功能。例如，我把data改为：</p>\n\n<pre><code class=\"language-js\">var data = [\"'bbbb', id = 2\", 1];  \n</code></pre>\n\n<p>这样拼接出来的sql代码应该是：\nUPDATE a<em>test</em>table SET name = 'bbbb', id = 2 WHERE id = 1 <br />\n运行这个js文件后，会发现结果变成这样：\n<img src=\"http://img.blog.csdn.net/20160612153243840\" alt=\"\" />\n但若在mysql里面运行这段代码：\n结果变成这样：\n<img src=\"http://img.blog.csdn.net/20160612153302712\" alt=\"\" />\n说明我们拼接的代码是没错的，只是mysql防止了这种简单的sql注入攻击。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701076961,"created_by":1,"updated_at":1495701170812,"updated_by":1,"published_at":1443774120000,"published_by":1},{"id":25,"uuid":"fd415422-b9c7-4e66-803c-897d8f28f560","title":"Node.js(3) 模块","slug":"nodejs-3","markdown":"\n当我们制作一个模块时，我们可能会写一个构造函数（因为在浏览器写构造函数时我们经常会这么做）。\n\n如代码：\n```js\nfunction sayHello() {  \n    this.say = function () {  \n        console.log('hello');  \n    }  \n}  \nexports.Hello = sayHello;  \n```\n在这里，我们有一个构造函数sayHello，函数里有一个方法say，输出hello。\n然后导出的是sayHello这个构造函数。我们在另外一个文件中调用它。\n代码这么写：\n```js\nvar hello = require('./test').Hello;    //调用刚才写的那个模块  \nvar m = new hello();  \nm.say();  \n```\n第一行表示我们调用刚才写的那个模块。\n注意，这个时候和之前不同（之前是直接require模块即可），这里需要添加一个Hello。原因在于require表示导入的是一个整体（即有多个exports导出的方法），这里我们只需要其中的Hello方法（即对应原模块中的sayHello这个构造函数）；\n \n当然，也可以写为require('./test')，在下面的代码，把hello改为hello.Hello即可。\n \n第二行代码表示生成一个这个构造函数的实例（还记得js里如何调用构造函数么？构造函数是不能直接调用其方法的）；\n \n第三行代码表示调用这个实例的say方法（即模块中的this.say=的那个函数）；\n \n这个流程是：\n请求模块==>生成函数的实例==>调用函数的方法\n \n \n我们也可以在导出的时候，用另一种方法：\n```js\nmodule.exports = sayHello;\n```\n然后调用这个模块\n```js\nvar hello = require('./test');    //调用刚才导入的那个文件  \nm = new hello();  \nm.say();  \n```\n这个时候hello就是这个函数，然后生成一个实例，调用其方法。\n \n但我觉得有个潜在问题，这个模块里只能有这一个函数（不是很确定）。我验证结果如下：\n修改之前的模块：\n```js\nfunction sayHello() {  \n    this.say = function () {  \n        console.log('hello');  \n    }  \n}  \nfunction say() {  \n    console.log(\"say\");  \n}  \nmodule.exports = sayHello;  \nexports.say = say;  \n```\n调用其的模块：\n```js\nvar hello = require('./test');    //调用刚才导入的那个文件  \nconsole.log(hello.say)  \n```\n显示是undefined，而正常情况下（删除module.exports = sayHello;这一行）应该显示：\n![](http://img.blog.csdn.net/20160612154252163)\n经过查询，这种用法的作用在于，假如我们只想将一个对象封装到模块中，就这么用。\n \n另外，不可以直接对exports进行赋值以替代（module.exports这种用法）。\n按照说明，这个变量会在模块执行结束后被释放，但module.exports不会。","html":"<p>当我们制作一个模块时，我们可能会写一个构造函数（因为在浏览器写构造函数时我们经常会这么做）。</p>\n\n<p>如代码：</p>\n\n<pre><code class=\"language-js\">function sayHello() {  \n    this.say = function () {  \n        console.log('hello');  \n    }  \n}  \nexports.Hello = sayHello;  \n</code></pre>\n\n<p>在这里，我们有一个构造函数sayHello，函数里有一个方法say，输出hello。\n然后导出的是sayHello这个构造函数。我们在另外一个文件中调用它。\n代码这么写：</p>\n\n<pre><code class=\"language-js\">var hello = require('./test').Hello;    //调用刚才写的那个模块  \nvar m = new hello();  \nm.say();  \n</code></pre>\n\n<p>第一行表示我们调用刚才写的那个模块。\n注意，这个时候和之前不同（之前是直接require模块即可），这里需要添加一个Hello。原因在于require表示导入的是一个整体（即有多个exports导出的方法），这里我们只需要其中的Hello方法（即对应原模块中的sayHello这个构造函数）；</p>\n\n<p>当然，也可以写为require('./test')，在下面的代码，把hello改为hello.Hello即可。</p>\n\n<p>第二行代码表示生成一个这个构造函数的实例（还记得js里如何调用构造函数么？构造函数是不能直接调用其方法的）；</p>\n\n<p>第三行代码表示调用这个实例的say方法（即模块中的this.say=的那个函数）；</p>\n\n<p>这个流程是：\n请求模块<mark>>生成函数的实例</mark>>调用函数的方法</p>\n\n<p>我们也可以在导出的时候，用另一种方法：</p>\n\n<pre><code class=\"language-js\">module.exports = sayHello;  \n</code></pre>\n\n<p>然后调用这个模块</p>\n\n<pre><code class=\"language-js\">var hello = require('./test');    //调用刚才导入的那个文件  \nm = new hello();  \nm.say();  \n</code></pre>\n\n<p>这个时候hello就是这个函数，然后生成一个实例，调用其方法。</p>\n\n<p>但我觉得有个潜在问题，这个模块里只能有这一个函数（不是很确定）。我验证结果如下：\n修改之前的模块：</p>\n\n<pre><code class=\"language-js\">function sayHello() {  \n    this.say = function () {  \n        console.log('hello');  \n    }  \n}  \nfunction say() {  \n    console.log(\"say\");  \n}  \nmodule.exports = sayHello;  \nexports.say = say;  \n</code></pre>\n\n<p>调用其的模块：</p>\n\n<pre><code class=\"language-js\">var hello = require('./test');    //调用刚才导入的那个文件  \nconsole.log(hello.say)  \n</code></pre>\n\n<p>显示是undefined，而正常情况下（删除module.exports = sayHello;这一行）应该显示：\n<img src=\"http://img.blog.csdn.net/20160612154252163\" alt=\"\" />\n经过查询，这种用法的作用在于，假如我们只想将一个对象封装到模块中，就这么用。</p>\n\n<p>另外，不可以直接对exports进行赋值以替代（module.exports这种用法）。\n按照说明，这个变量会在模块执行结束后被释放，但module.exports不会。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701179657,"created_by":1,"updated_at":1495701226103,"updated_by":1,"published_at":1475485140000,"published_by":1},{"id":26,"uuid":"b4bcc627-cfe0-452f-990f-4a2652dac9cd","title":"使用node.js自动更新本地hosts, 实现科学上网.","slug":"nodejs-hosts","markdown":"\n现在网上有不少提供google hosts的网址，当我们访问不了google时，就需要复制这个网站提供的hosts到我们本地的hosts，在粘贴前还要在C盘一层一层的找到本地hosts，比较麻烦。\n于是我就想能不能通过运行一条命令就能把网站里的hosts自动更新到本地，刚开始想的是用php写的，不过在跟同学聊天的过程中，同学建议使用node来实现这个功能，简单方便，而且我对php的正则表达式也不是很熟，那就用node试试吧。\n\n\n# 1. 安装Node\n进入[官网](https://nodejs.org/en/download)，下载我们需要的程序包。下载后，双击进行安装。\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ajj0h2ii5r4uk81u9p27i1i11a.jpg)\n在现在的node版本中，默认是node和npm一起安装的，不用再单独安装npm了。\n安装成功后，使用win+r打开cmd命令窗口，然后输入``node -v``查看当前node的版本号\n输入``npm -v``查看当前npm的版本号\n如果两个都能正确显示出版本号，就说明node和npm已经安装成功了。\n使用.msi类型的文件进行能够自动添加node和npm到PATH的环境变量中。\n\n# 2. 下载需要的模块包\nnpm是一个node的包管理和分发工具。有了npm，可以很快的找到你想要使用的包，进行下载、安装以及管理已经安装的包。\n使用npm进行模块的安装非常的方便：``npm install ****``\n如果想安装成全局的，所有的项目都能使用，可以添加上-g参数，如：``npm install -g ****``\n本项目中主要使用到的模块有：\n* request : 远程url请求。\n* cheerio : 类似于jQuery，能够像jQuery那样选择元素，获取元素的内容。\n* fs : 这是npm里自带的，不用下载安装，主要用于文件的读写操作。\n\n# 3. 编写程序\n程序的逻辑很简单：\n* 获取远程url的网页内容；\n* 解析出网页内容中hosts部分； \n* 读取自己设置的一些hosts；  \n* 将自己的hosts和远程获取到的hosts一起写入到C盘的hosts文件中。 \n这里使用了async中的waterfall来控制整个代码的流程。\n\n```js\nasync.waterfall([\n    function(callback){\n        self.log(\"正在连接 hosts url....\");\n\n        callback(error, data);\n    },\n    function(body, callback){\n        self.log(\"正在解析数据....\");\n\n        callback(null, text);\n    },\n    function(text, callback){\n        self.log('读取本地文件....');\n        \n        callback(err, data); \n    },\n    function(text, callback){\n        self.log('正在写入hosts....');\n        \n        if(err){\n            self.log(\"写入失败....\");\n        }else{\n            self.log(\"写入成功....\");\n        }\n        calllback(err);\n    },\n    function(){\n        self.log('运行完毕!');\n    }\n], function(err, data){\n    console.log('err: '+err);\n    // console.log('data: '+data);\n})\t\n```\n\nasync.waterfall提供瀑布式的流控制。每个操作产生的数据可以传递给下一个函数，通过callback这个回调函数。 \nasync模块保证回调只会被触发一次。它同时还为我们处理了错误，管理并行的任务。 \n这里还要说明一下：我这儿有一个单独的文件来放置自己的hosts，比如当前目录中的default.txt文件\n\n# 4. 运行代码\n进入到这个项目所在的目录，首先运行``npm install``，安装程序所需要的集成包。安装完成之后，然后运行``index.js:node index.js``，如果正常的话，就会出现下面的提示：\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ajj1499q125g1lkufv518c31r5ga.png)\n程序采用的更新hosts的方式是全覆盖写入，因此我们需要把自己配置的一些hosts写到一个文件里（如default.txt）。当程序更新时，会首先读取default.txt里的hosts配置，然后与远程地址里的google hosts一起写入到本地的hosts文件中。\n代码里还有参数的默认配置：\n```json\n_option : {  \n\thostsurl : 'http://www.360kb.com/kb/2_122.html',  // 请求地址\n\thostsfile : 'C:/Windows/System32/drivers/etc/hosts',  // 本地hosts地址\n\tlocalfile : './default.txt'  // 默认hosts\n}\n```\n你可以直接修改这些变量，或者在调用init()方法时传递你需要的参数，程序自然会覆盖掉默认参数：\n```json\nwzHosts.init({hostsfile:'/etc/hosts', localfile:'/data/default.txt'}); \n```\n这样，本地里的google hosts就更新到了最新！\n\n# 5. 总结与更新地址\n通过这次的hosts读写，学习到了不少的node知识，欢迎提出你们的意见和建议！\nGoogle hosts更新网址:\n>http://www.360kb.com/kb/2_122.html\n>https://laod.cn/black-technology/hosts.html","html":"<p>现在网上有不少提供google hosts的网址，当我们访问不了google时，就需要复制这个网站提供的hosts到我们本地的hosts，在粘贴前还要在C盘一层一层的找到本地hosts，比较麻烦。\n于是我就想能不能通过运行一条命令就能把网站里的hosts自动更新到本地，刚开始想的是用php写的，不过在跟同学聊天的过程中，同学建议使用node来实现这个功能，简单方便，而且我对php的正则表达式也不是很熟，那就用node试试吧。</p>\n\n<h1 id=\"1node\">1. 安装Node</h1>\n\n<p>进入<a href=\"https://nodejs.org/en/download\">官网</a>，下载我们需要的程序包。下载后，双击进行安装。\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ajj0h2ii5r4uk81u9p27i1i11a.jpg\" alt=\"\" />\n在现在的node版本中，默认是node和npm一起安装的，不用再单独安装npm了。\n安装成功后，使用win+r打开cmd命令窗口，然后输入<code>node -v</code>查看当前node的版本号\n输入<code>npm -v</code>查看当前npm的版本号\n如果两个都能正确显示出版本号，就说明node和npm已经安装成功了。\n使用.msi类型的文件进行能够自动添加node和npm到PATH的环境变量中。</p>\n\n<h1 id=\"2\">2. 下载需要的模块包</h1>\n\n<p>npm是一个node的包管理和分发工具。有了npm，可以很快的找到你想要使用的包，进行下载、安装以及管理已经安装的包。 <br />\n使用npm进行模块的安装非常的方便：<code>npm install ****</code>\n如果想安装成全局的，所有的项目都能使用，可以添加上-g参数，如：<code>npm install -g ****</code>\n本项目中主要使用到的模块有：\n* request : 远程url请求。\n* cheerio : 类似于jQuery，能够像jQuery那样选择元素，获取元素的内容。\n* fs : 这是npm里自带的，不用下载安装，主要用于文件的读写操作。</p>\n\n<h1 id=\"3\">3. 编写程序</h1>\n\n<p>程序的逻辑很简单：\n* 获取远程url的网页内容；\n* 解析出网页内容中hosts部分； \n* 读取自己设置的一些hosts； <br />\n* 将自己的hosts和远程获取到的hosts一起写入到C盘的hosts文件中。 \n这里使用了async中的waterfall来控制整个代码的流程。</p>\n\n<pre><code class=\"language-js\">async.waterfall([  \n    function(callback){\n        self.log(\"正在连接 hosts url....\");\n\n        callback(error, data);\n    },\n    function(body, callback){\n        self.log(\"正在解析数据....\");\n\n        callback(null, text);\n    },\n    function(text, callback){\n        self.log('读取本地文件....');\n\n        callback(err, data); \n    },\n    function(text, callback){\n        self.log('正在写入hosts....');\n\n        if(err){\n            self.log(\"写入失败....\");\n        }else{\n            self.log(\"写入成功....\");\n        }\n        calllback(err);\n    },\n    function(){\n        self.log('运行完毕!');\n    }\n], function(err, data){\n    console.log('err: '+err);\n    // console.log('data: '+data);\n})    \n</code></pre>\n\n<p>async.waterfall提供瀑布式的流控制。每个操作产生的数据可以传递给下一个函数，通过callback这个回调函数。 <br />\nasync模块保证回调只会被触发一次。它同时还为我们处理了错误，管理并行的任务。 <br />\n这里还要说明一下：我这儿有一个单独的文件来放置自己的hosts，比如当前目录中的default.txt文件</p>\n\n<h1 id=\"4\">4. 运行代码</h1>\n\n<p>进入到这个项目所在的目录，首先运行<code>npm install</code>，安装程序所需要的集成包。安装完成之后，然后运行<code>index.js:node index.js</code>，如果正常的话，就会出现下面的提示：\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ajj1499q125g1lkufv518c31r5ga.png\" alt=\"\" />\n程序采用的更新hosts的方式是全覆盖写入，因此我们需要把自己配置的一些hosts写到一个文件里（如default.txt）。当程序更新时，会首先读取default.txt里的hosts配置，然后与远程地址里的google hosts一起写入到本地的hosts文件中。\n代码里还有参数的默认配置：</p>\n\n<pre><code class=\"language-json\">_option : {  \n    hostsurl : 'http://www.360kb.com/kb/2_122.html',  // 请求地址\n    hostsfile : 'C:/Windows/System32/drivers/etc/hosts',  // 本地hosts地址\n    localfile : './default.txt'  // 默认hosts\n}\n</code></pre>\n\n<p>你可以直接修改这些变量，或者在调用init()方法时传递你需要的参数，程序自然会覆盖掉默认参数：</p>\n\n<pre><code class=\"language-json\">wzHosts.init({hostsfile:'/etc/hosts', localfile:'/data/default.txt'});  \n</code></pre>\n\n<p>这样，本地里的google hosts就更新到了最新！</p>\n\n<h1 id=\"5\">5. 总结与更新地址</h1>\n\n<p>通过这次的hosts读写，学习到了不少的node知识，欢迎提出你们的意见和建议！\nGoogle hosts更新网址:  </p>\n\n<blockquote>\n  <p><a href=\"http://www.360kb.com/kb/2_122.html\">http://www.360kb.com/kb/2_122.html</a>\n  <a href=\"https://laod.cn/black-technology/hosts.html\">https://laod.cn/black-technology/hosts.html</a></p>\n</blockquote>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701234606,"created_by":1,"updated_at":1495701276259,"updated_by":1,"published_at":1472971980000,"published_by":1},{"id":27,"uuid":"4a74d902-81cd-455f-9d7f-4ad0036ff32b","title":"RequireJS入门(一)","slug":"requirejs-1","markdown":"RequireJS会让你以不同于往常的方式去写JavaScript。你将不再使用script标签在HTML中引入JS文件，以及不用通过script标签顺序去管理依赖关系。\n当然也不会有阻塞（blocking）的情况发生。好，以一个简单示例开始。\n\n新建一个目录，结构如下\n![](http://pic002.cnblogs.com/images/2012/114013/2012052217445846.png)\n\n目录r1下有index.html、jquery-1.7.2.js、main.js、require.js。require.js和jquery-1.7.2.js去各自官网下载即可。\n\n## index.html如下\n```html\n<!doctype html>\n<html>\n    <head>\n        <title>requirejs入门（一）</title>\n        <meta charset=\"utf-8\">\n        <script data-main=\"main\" src=\"require.js\"></script>\n    </head>\n    <body>\n     \n    </body>\n</html>\n```\n使用requirejs很简单，只需要在head中通过script标签引入它（实际上除了require.js，其它文件模块都不再使用script标签引入）。\n细心的同学会发现script标签上了多了一个自定义属性：data-main=\"main\"，等号右边的main指的main.js。当然可以使用任意的名称。这个main指主模块或入口模块，好比c或java的主函数main。\n\n## main.js如下\n```js\nrequire.config({\n    paths: {\n        jquery: 'jquery-1.7.2'\n    }\n});\n \nrequire(['jquery'], function($) {\n    alert($().jquery);\n});\n```\nmain.js中就两个函数调用require.config和require。\n\nrequire.config用来配置一些参数，它将影响到requirejs库的一些行为。\n\nrequire.config的参数是一个JS对象，常用的配置有baseUrl，paths等。\n\n这里配置了paths参数，使用模块名“jquery”，其实际文件路径jquery-1.7.2.js（后缀.js可以省略）。\n\n我们知道jQuery从1.7后开始支持AMD规范，即如果jQuery作为一个AMD模块运行时，它的模块名是“jquery”。注意“jquery”是固定的，不能写“jQuery”或其它。\n\n注：如果文件名“jquery-1.7.2.js”改为“jquery.js”就不必配置paths参数了。\n\n## jQuery中的支持AMD代码如下\n```js\nif ( typeof define === \"function\" && define.amd && define.amd.jQuery ) {\n    define( \"jquery\", [], function () { return jQuery; } );\n}\n```\n\n我们知道jQuery最终向外暴露的是全局的jQuery和 $。如下\n```js\n// Expose jQuery to the global object\nwindow.jQuery = window.$ = jQuery;\n```\n\n如果将jQuery应用在模块化开发时，其实可以不使用全局的，即可以不暴露出来。需要用到jQuery时使用require函数即可，\n\n这里require函数的第一个参数是数组，数组中存放的是模块名（字符串类型），数组中的模块与回调函数的参数一一对应。这里的例子则只有一个模块“jquery”。\n\n把目录r1放到apache或其它web服务器上，访问index.html。\n\n## 网络请求如下\n![](http://pic002.cnblogs.com/images/2012/114013/2012052217462496.png)\n\n我们看到除了require.js外main.js和jquery-1.7.2.js也请求下来了。而它们正是通过requirejs请求的。\n","html":"<p>RequireJS会让你以不同于往常的方式去写JavaScript。你将不再使用script标签在HTML中引入JS文件，以及不用通过script标签顺序去管理依赖关系。 <br />\n当然也不会有阻塞（blocking）的情况发生。好，以一个简单示例开始。</p>\n\n<p>新建一个目录，结构如下\n<img src=\"http://pic002.cnblogs.com/images/2012/114013/2012052217445846.png\" alt=\"\" /></p>\n\n<p>目录r1下有index.html、jquery-1.7.2.js、main.js、require.js。require.js和jquery-1.7.2.js去各自官网下载即可。</p>\n\n<h2 id=\"indexhtml\">index.html如下</h2>\n\n<pre><code class=\"language-html\">&lt;!doctype html&gt;  \n&lt;html&gt;  \n    &lt;head&gt;\n        &lt;title&gt;requirejs入门（一）&lt;/title&gt;\n        &lt;meta charset=\"utf-8\"&gt;\n        &lt;script data-main=\"main\" src=\"require.js\"&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n\n    &lt;/body&gt;\n&lt;/html&gt;  \n</code></pre>\n\n<p>使用requirejs很简单，只需要在head中通过script标签引入它（实际上除了require.js，其它文件模块都不再使用script标签引入）。\n细心的同学会发现script标签上了多了一个自定义属性：data-main=\"main\"，等号右边的main指的main.js。当然可以使用任意的名称。这个main指主模块或入口模块，好比c或java的主函数main。</p>\n\n<h2 id=\"mainjs\">main.js如下</h2>\n\n<pre><code class=\"language-js\">require.config({  \n    paths: {\n        jquery: 'jquery-1.7.2'\n    }\n});\n\nrequire(['jquery'], function($) {  \n    alert($().jquery);\n});\n</code></pre>\n\n<p>main.js中就两个函数调用require.config和require。</p>\n\n<p>require.config用来配置一些参数，它将影响到requirejs库的一些行为。</p>\n\n<p>require.config的参数是一个JS对象，常用的配置有baseUrl，paths等。</p>\n\n<p>这里配置了paths参数，使用模块名“jquery”，其实际文件路径jquery-1.7.2.js（后缀.js可以省略）。</p>\n\n<p>我们知道jQuery从1.7后开始支持AMD规范，即如果jQuery作为一个AMD模块运行时，它的模块名是“jquery”。注意“jquery”是固定的，不能写“jQuery”或其它。</p>\n\n<p>注：如果文件名“jquery-1.7.2.js”改为“jquery.js”就不必配置paths参数了。</p>\n\n<h2 id=\"jqueryamd\">jQuery中的支持AMD代码如下</h2>\n\n<pre><code class=\"language-js\">if ( typeof define === \"function\" &amp;&amp; define.amd &amp;&amp; define.amd.jQuery ) {  \n    define( \"jquery\", [], function () { return jQuery; } );\n}\n</code></pre>\n\n<p>我们知道jQuery最终向外暴露的是全局的jQuery和 $。如下</p>\n\n<pre><code class=\"language-js\">// Expose jQuery to the global object\nwindow.jQuery = window.$ = jQuery;  \n</code></pre>\n\n<p>如果将jQuery应用在模块化开发时，其实可以不使用全局的，即可以不暴露出来。需要用到jQuery时使用require函数即可，</p>\n\n<p>这里require函数的第一个参数是数组，数组中存放的是模块名（字符串类型），数组中的模块与回调函数的参数一一对应。这里的例子则只有一个模块“jquery”。</p>\n\n<p>把目录r1放到apache或其它web服务器上，访问index.html。</p>\n\n<h2 id=\"\">网络请求如下</h2>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012052217462496.png\" alt=\"\" /></p>\n\n<p>我们看到除了require.js外main.js和jquery-1.7.2.js也请求下来了。而它们正是通过requirejs请求的。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701535276,"created_by":1,"updated_at":1495701578533,"updated_by":1,"published_at":1475481240000,"published_by":1},{"id":28,"uuid":"3780c6fe-48a9-4f66-b69a-1f3b2f0622b1","title":"RequireJS入门(二)","slug":"requirejs-2","markdown":"上一篇是把整个jQuery库作为一个模块。这篇来写一个自己的模块：选择器。\n为演示方便这里仅实现常用的三种选择器id，className，attribute。RequireJS使用define来定义模块。\n\n新建目录结构如下\n\n![](http://pic002.cnblogs.com/images/2012/114013/2012052309380326.png)\n\n这次新建了一个子目录js，把main.js和selctor.js放入其中，require.js仍然和index.html在同一级目录。\n\n## HTML 如下\n```html\n<!doctype html>\n<html>\n    <head>\n        <title>requirejs入门（二）</title>\n        <meta charset=\"utf-8\">\n        <style type=\"text/css\">\n            .wrapper {\n                width: 200px;\n                height: 200px;\n                background: gray;\n            }\n        </style>\n    </head>\n    <body>\n        <div class=\"wrapper\"></div>\n        <script data-main=\"js/main\" src=\"require.js\"></script>\n    </body>\n</html>\n```\n这次把script标签放到了div的后面，因为要用选择器去获取页面dom元素，而这要等到dom ready后。\n\n因为把main.js放到js目录中，这里data-main的值须改为“js/main”。\n\n## selector.js 如下\n```js\ndefine(function() {\n \n    function query(selector,context) {\n        var s = selector,\n            doc = document,\n            regId = /^#[\\w\\-]+/,\n            regCls = /^([\\w\\-]+)?\\.([\\w\\-]+)/,\n            regTag = /^([\\w\\*]+)$/,\n            regNodeAttr = /^([\\w\\-]+)?\\[([\\w]+)(=(\\w+))?\\]/;\n         \n        var context =\n                context == undefined ?\n                document :\n                typeof context == 'string' ?\n                doc.getElementById(context.substr(1,context.length)) :\n                context;\n                 \n        if(regId.test(s)) {\n            return doc.getElementById(s.substr(1,s.length));\n        }\n    }\n     \n    return query;\n});\n```\n\ndefine的参数为一个匿名函数，该匿名函数执行后返回query，query为函数类型。query就是选择器的实现函数。\n\n## main.js 如下\n```js\nrequire.config({\n    baseUrl: 'js'\n});\n \nrequire(['selector'], function(query) {\n    var els = query('.wrapper');\n    console.log(els)\n});\n```\nrequire.config方法执行配置了baseUrl为“js”，baseUrl指的模块文件的根目录，可以是绝对路径或相对路径。这里用的是相对路径。相对路径指引入require.js的页面为参考点，这里是index.html。\n\n把目录r2放到apache或其它web服务器上，访问index.html。\n\n## 网络请求如下\n![](http://pic002.cnblogs.com/images/2012/114013/2012052309381828.png)\n\nmain.js和selector.js都请求下来了。\n\nselector.js下载后使用query获取页面class为“.wrapper”的元素，控制台输出了该元素。如下\n\n![](http://pic002.cnblogs.com/images/2012/114013/2012052309390448.png)\n\n## 总结\n* 使用baseUrl来配置模块根目录，baseUrl可以是绝对路径也可以是相对路径\n* 使用define定义一个函数类型模块，RequireJS的模块可以是JS对象，函数或其它任何类型（CommonJS/SeaJS则只能是JS对象）","html":"<p>上一篇是把整个jQuery库作为一个模块。这篇来写一个自己的模块：选择器。\n为演示方便这里仅实现常用的三种选择器id，className，attribute。RequireJS使用define来定义模块。</p>\n\n<p>新建目录结构如下</p>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012052309380326.png\" alt=\"\" /></p>\n\n<p>这次新建了一个子目录js，把main.js和selctor.js放入其中，require.js仍然和index.html在同一级目录。</p>\n\n<h2 id=\"html\">HTML 如下</h2>\n\n<pre><code class=\"language-html\">&lt;!doctype html&gt;  \n&lt;html&gt;  \n    &lt;head&gt;\n        &lt;title&gt;requirejs入门（二）&lt;/title&gt;\n        &lt;meta charset=\"utf-8\"&gt;\n        &lt;style type=\"text/css\"&gt;\n            .wrapper {\n                width: 200px;\n                height: 200px;\n                background: gray;\n            }\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=\"wrapper\"&gt;&lt;/div&gt;\n        &lt;script data-main=\"js/main\" src=\"require.js\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;  \n</code></pre>\n\n<p>这次把script标签放到了div的后面，因为要用选择器去获取页面dom元素，而这要等到dom ready后。</p>\n\n<p>因为把main.js放到js目录中，这里data-main的值须改为“js/main”。</p>\n\n<h2 id=\"selectorjs\">selector.js 如下</h2>\n\n<pre><code class=\"language-js\">define(function() {\n\n    function query(selector,context) {\n        var s = selector,\n            doc = document,\n            regId = /^#[\\w\\-]+/,\n            regCls = /^([\\w\\-]+)?\\.([\\w\\-]+)/,\n            regTag = /^([\\w\\*]+)$/,\n            regNodeAttr = /^([\\w\\-]+)?\\[([\\w]+)(=(\\w+))?\\]/;\n\n        var context =\n                context == undefined ?\n                document :\n                typeof context == 'string' ?\n                doc.getElementById(context.substr(1,context.length)) :\n                context;\n\n        if(regId.test(s)) {\n            return doc.getElementById(s.substr(1,s.length));\n        }\n    }\n\n    return query;\n});\n</code></pre>\n\n<p>define的参数为一个匿名函数，该匿名函数执行后返回query，query为函数类型。query就是选择器的实现函数。</p>\n\n<h2 id=\"mainjs\">main.js 如下</h2>\n\n<pre><code class=\"language-js\">require.config({  \n    baseUrl: 'js'\n});\n\nrequire(['selector'], function(query) {  \n    var els = query('.wrapper');\n    console.log(els)\n});\n</code></pre>\n\n<p>require.config方法执行配置了baseUrl为“js”，baseUrl指的模块文件的根目录，可以是绝对路径或相对路径。这里用的是相对路径。相对路径指引入require.js的页面为参考点，这里是index.html。</p>\n\n<p>把目录r2放到apache或其它web服务器上，访问index.html。</p>\n\n<h2 id=\"\">网络请求如下</h2>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012052309381828.png\" alt=\"\" /></p>\n\n<p>main.js和selector.js都请求下来了。</p>\n\n<p>selector.js下载后使用query获取页面class为“.wrapper”的元素，控制台输出了该元素。如下</p>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012052309390448.png\" alt=\"\" /></p>\n\n<h2 id=\"\">总结</h2>\n\n<ul>\n<li>使用baseUrl来配置模块根目录，baseUrl可以是绝对路径也可以是相对路径</li>\n<li>使用define定义一个函数类型模块，RequireJS的模块可以是JS对象，函数或其它任何类型（CommonJS/SeaJS则只能是JS对象）</li>\n</ul>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701590509,"created_by":1,"updated_at":1495701642046,"updated_by":1,"published_at":1475549640000,"published_by":1},{"id":29,"uuid":"cbf4880a-dabe-40fe-a60d-ba7d6566e634","title":"使用RequireJS进行模块化开发","slug":"requirejs-dev","markdown":"在之前的项目中一直用的是seajs，感觉seajs是挺好用的，但是有个问题就是把现有的js框架打包成seajs模块略麻烦，官方文档里面也没有对这一块作详细的介绍，虽然有spm build，但还是觉得不太方便。因此便在新的项目中用了requirejs。\n\n\n![requirejs](http://blog.u.qiniudn.com/uploads%2Frequirejs.png)\n\n用requirejs其实还有另一个原因就是项目中用到了百度的图表库[echarts](http://echarts.baidu.com/ \"echarts\")，根据其官方文档的描述是不建议使用基于CMD规范的seajs来加载的，因为echarts是基于AMD模块化的，虽然网上有人改了可以用seajs加载，但是我最后还是选择用requirejs来加载，同时也是想尝试一下requirejs。\n\n**自定义构建echarts**\n\n`echarts`的构建是用的`r.js`，因此我在这里先讲一下。\n\n自定义构建`echarts`还必须下载`zrender`，下载完成之后，把`echarts`的目录和`zrender`目录放在同级目录下，然后进入`echarts`的`build`目录进行自定义`build`（需要node.js环境），下面是我的build命令：\n\n```bash\nnode build.js optimize=true exclude=force,scatter,k,radar,chord,gauge,funnel,map  output=echarts1.js\n```\n\n上面命令的意思是排除`exclude`的之后的那些模块，因为我只用到了`echarts`的折线图、柱状图和饼状图。\n\n执行完成之后就可以在build目录看到刚才合并的`echarts1.js`\n\n**requirejs模块加载配置**\n\n`requirejs`引入主模块的方法是通过在script标签里面添加`data-main`属性，如我的引入代码：\n\n```html\n<script data-main=\"js/main\" src=\"js/lib/requirejs/require.js\"></script>\n```\n\n`main.js`是程序的入口js文件，然后我们在`main.js`里面进行模块的加载配置：\n\n```javascript\nrequirejs.config({\n\t//开发专用，阻止浏览器缓存\n\turlArgs: \"v=\" + Date.now(),\n\t//js文件的目录，相对于引入main.js的那个文件的目录\n\tbaseUrl: 'js',\n\t//对于默认不兼容AMD规范的模块通过shim来配置\n\t//deps数组，表明该模块的依赖性，\n\t//exports值，表明这个模块外部调用时的名称\n\t//下面代码里面包含了如何加载库和插件\n\tshim: {\n    \t'backbone': {\n       \t \tdeps: ['underscore', 'jquery'],\n        \texports: 'Backbone'\n    \t},\n    \t'underscore': {\n        \texports: '_'\n    \t},\n    \t'backbone.localStorage': {\n  \t\t\tdeps: ['backbone'],\n  \t\t\texports: 'Backbone'\n\t\t},\n\t\t'bootstrap.modal': {\n        \tdeps: ['jquery'],\n        \texports: 'jQuery.fn.modal'\n    \t}\n\t},\n\t//模块的加载路径（不要加.js后缀，因为默认就是加载js，加了会报错）\n\t//路径是相对于上面的baseUrl\n\tpaths: {\n\t\tjquery: 'lib/jquery/jquery-1.11.1.min',\n\t\tunderscore: 'lib/underscore/underscore-min',\n\t\t...\n\t\ttext: 'lib/requirejs/plugins/text',\n\t\techarts:'lib/echarts/echarts',\n    \t'echarts/chart/bar' : 'lib/echarts/echarts',\n\t\tconfig: 'modules/common/config'\n\t}\t\n});\n\n//下面开始加载执行\nrequire(['backbone', 'modules/app'], function (Backbone, AppRouter) {\n\tnew AppRouter();\n\tBackbone.history.start();\n});\n```\n\n\n**requirejs模块定义与加载**\n\n`requirejs`定义一个模块相当简单，下面是一个简单的例子:\n\n```javascript\ndefine(['backbone'], function(Backbone){\n\tvar AppRouter = Backbone.Router.extend({\n\t\t...\n\t});\n\n\t//导出对象\n\treturn AppRouter;\n});\n```\n\n我们也可以动态加载模块：\n\n```javascript\ndefine(['backbone'], function(Backbone){\n\tvar AppRouter = Backbone.Router.extend({\n\t\t...\n\t\tindex： function(){\n\t\t\trequire(['echarts', 'echarts/chart/bar'], function(ec){\n\t\t\t\t...\n\t\t\t});\n\t\t}\n\t});\n\n\t//导出对象\n\treturn AppRouter;\n});\n```\n\n如果你已经用习惯了`seajs`的模块加载方法的话，你也可以像`seajs`里面那样去加载模块：\n\n```javascript\ndefine(function (require) {\n\tvar $ = require('jquery');\n\n\treturn function () {\n\t    ...\n\t};\n});\n```\n\n或者`CommonJS`的方式也ok:\n\t\n```javascript\ndefine(function(require, exports, module) {\n\t...\n});\n```\n\n`requirejs`提供一个加载文本的插件`text.js`，细心的话你可能已经看到我在`requirejs.config`里面已经配置了，使用也很简单：\n\n```javascript\n// 注意这里自定义模块的加载路径\n// 可以写相对路径，那就是相对于当前js文件的路径\n// 也可以写绝对路径，就是相对于baseUrl的路径\ndefine(['backbone','text!../tmpl/index.html'], function(Backbone, html){\n\t\n});\n```\n\n**requirejs构建工具r.js**\n\n当项目上线的时候，我们可能需要对模块代码进行压缩合并的操作，这时我们就会用到`requirejs`的构建工具`r.js`。首先我们在项目根目录创建一个`build`的文件夹和`dist`的文件夹，分别用来存放模块合并相关配置和合并后的代码的文件目录，在`build`目录里面存放`r.js`，并新建一个压缩合并的配置文件`config.js`,下面是`config.js`的配置示例：\n\n```javascript\n//config.js\n{\n\t//requirejs.cofig文件的路径,它会自动读取main.js里面的配置信息\n\tmainConfigFile : \"../js/main.js\",\n\tbaseUrl: '../js',\n\tname: \"main\",\n\t//输出文件的路径和名称\n\tout: \"../dist/js/main.js\",\n\t//默认情况写r.js会把相关的依赖文件拷贝到输出目录里面去\n\t//设置为true之后r.js就不会进行这一操作\n\tremoveCombined: true,\n\t//findNestedDependencies设置为true表示将所有相关的依赖模块也合并进来，默认为false只会对main.js进行压缩合并的操作\n\tfindNestedDependencies: true\n}\n```\n\n然后在命令行执行：\n\n```bash\nnode r.js -o config.js\n```\n\n执行完成之后便会在`dist/js/`目录下面生成一个合并后的`main.js`\n\n你会发现这个`main.js`可能会非常大，而在实际项目中，像通用的一些jquery、backbone等有时候我们可能没有必要把它压缩进来，我们只需要压缩自己写的一些代码，于是我们再次开始配置我们的`config.js`：\n\n```javascript\n{\n\tmainConfigFile : \"../js/main.js\",\n\tbaseUrl: \"../js\",\n\tremoveCombined: true,\n\tfindNestedDependencies: true,\n\tdir: \"../dist/js\",\n\tmodules: [{\n\t\tname: \"main\",\n        exclude: [\n            \"backbone\",\n\t\t\t\"underscore\",\n            \"jquery\",\n            \"text\",\n\t\t\t...\n        ]\n    }]\n}\n```\n\n再次运行压缩合并命令将会发现在`exclude`数组里面的项不会被合并。\n\n然而我觉得更好的做法是把通用的一些库，如jquery,bacnbone等合并到一个文件里面，我们自己的代码合并到了一个文件，因此，我们重新进行配置。\n\n首先我们新建一个js文件，这个js文件啥也不用做，就是为了引用所有通用的库，这样方便我们进行排除，如下：\n\n```javascript\n//libs.js\n\t\ndefine([\n\t\"jquery\",\n\t\"underscore\",\n\t\"backbone\",\n\t...\n\t\"text\"\n], function() {});\n```\n\n然后我们的`config.js`变成了这样：\n\n```javascript\n{\n\tmainConfigFile : \"../js/main.js\",\n\tbaseUrl: \"../js\",\n\tremoveCombined: true,\n\tfindNestedDependencies: true,\n\tdir: \"../dist/js\",\n\tmodules: [\n    \t{\n       \t name: \"main\",\n        \texclude: [\n            \t\"libs\"\n        \t]\n    \t},\n   \t\t{\n       \t\tname: \"libs\"\n   \t \t}\n\t]\n}\n```\n\n现在，我们的`build`操作终于完美了。\n\n但是，如果我们的js直接通过cdn引用的呢？如果我们直接运行上面的压缩配置，`r.js`将会报错。因此，对于从cdn引入的js，我们作如下配置：\n\n```javascript\nrequirejs.config({\n\tpaths: {\n\t\t//如果cdn挂点，通过本地加载jquery\n    \tjquery: ['http://cdn.staticfile.org/jquery/1.11.1/jquery.min.js', 'lib/jquery/jquery-1.11.1.min'],\n    \tunderscore: 'lib/underscore/underscore-min',\n    \t...\n    \ttext: 'lib/requirejs/plugins/text',\n    \techarts:'lib/echarts/echarts',\n    \t'echarts/chart/bar' : 'lib/echarts/echarts',\n    \tconfig: 'modules/common/config'\n\t}  \n});\n\n//修改config.js\n{\n\tmainConfigFile : \"../js/main.js\",\n\tbaseUrl: \"../js\",\n\tremoveCombined: true,\n\tfindNestedDependencies: true,\n\tdir: \"../dist/js\",\n\tmodules: [\n    \t{\n       \t name: \"main\",\n        \texclude: [\n            \t\"libs\"\n        \t]\n    \t},\n   \t\t{\n       \t\tname: \"libs\"\n   \t \t}\n\t],\n\tpaths: {\n    \tjquery: \"empty:\"\n\t}\n}\n```\n\n我们再次运行合并的操作`node r.js -o config.js`会发现此时`r.js`没有把`jquery`合并进来，因为它是通过cdn加载的。\n\n**css的压缩合并配置**\n\n虽然我的项目中没有用到，但在这里还是说一下吧。\n\n项目中可能引用了多个css文件，如：\n\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/bootstrap.css\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\">\n```\n\n如果我们只想引用一个css文件，我们可以这样：\n\n```css\n@import url('/css/bootstrap.css');\n/* style.css content here…. */\n```\n\n然后在压缩合并的时候进行配置：\n\n```javascript\n//config.js\n{\n\tmainConfigFile : \"../js/main.js\",\n\tappDir: \"../\",\n\tbaseUrl: \"js\",\n\tremoveCombined: true,\n\tfindNestedDependencies: true,\n\tdir: \"../dist\",\n\toptimizeCss: \"standard\",\n\tmodules: [\n    \t{\n       \t name: \"main\",\n        \texclude: [\n            \t\"libs\"\n        \t]\n    \t},\n   \t\t{\n       \t\tname: \"libs\"\n   \t \t}\n\t],\n\tpaths: {\n    \tjquery: \"empty:\"\n\t}，\n\t//匹配到的文件或者目录不会被拷贝到dist目录\n\tfileExclusionRegExp: /(^\\.|build|dist|sass|config.rb)/,\n\tgenerateSourceMaps: true\n}\n```\n\n> `appDir`：项目根目录\n> \n> `optimizeCss` ：css压缩规则，有四种，分别是：`none` 、`standard` 、`standard.keeplines`、`standard.keepComments`、`standard.keepComments.keeplines`。具体意思我就不一一解释了。\n> \n> `generateSourceMaps`：生成map文件，把压缩过的js与未压缩的作映射","html":"<p>在之前的项目中一直用的是seajs，感觉seajs是挺好用的，但是有个问题就是把现有的js框架打包成seajs模块略麻烦，官方文档里面也没有对这一块作详细的介绍，虽然有spm build，但还是觉得不太方便。因此便在新的项目中用了requirejs。</p>\n\n<p><img src=\"http://blog.u.qiniudn.com/uploads%2Frequirejs.png\" alt=\"requirejs\" /></p>\n\n<p>用requirejs其实还有另一个原因就是项目中用到了百度的图表库<a href=\"http://echarts.baidu.com/\" title=\"echarts\">echarts</a>，根据其官方文档的描述是不建议使用基于CMD规范的seajs来加载的，因为echarts是基于AMD模块化的，虽然网上有人改了可以用seajs加载，但是我最后还是选择用requirejs来加载，同时也是想尝试一下requirejs。</p>\n\n<p><strong>自定义构建echarts</strong></p>\n\n<p><code>echarts</code>的构建是用的<code>r.js</code>，因此我在这里先讲一下。</p>\n\n<p>自定义构建<code>echarts</code>还必须下载<code>zrender</code>，下载完成之后，把<code>echarts</code>的目录和<code>zrender</code>目录放在同级目录下，然后进入<code>echarts</code>的<code>build</code>目录进行自定义<code>build</code>（需要node.js环境），下面是我的build命令：</p>\n\n<pre><code class=\"language-bash\">node build.js optimize=true exclude=force,scatter,k,radar,chord,gauge,funnel,map  output=echarts1.js  \n</code></pre>\n\n<p>上面命令的意思是排除<code>exclude</code>的之后的那些模块，因为我只用到了<code>echarts</code>的折线图、柱状图和饼状图。</p>\n\n<p>执行完成之后就可以在build目录看到刚才合并的<code>echarts1.js</code></p>\n\n<p><strong>requirejs模块加载配置</strong></p>\n\n<p><code>requirejs</code>引入主模块的方法是通过在script标签里面添加<code>data-main</code>属性，如我的引入代码：</p>\n\n<pre><code class=\"language-html\">&lt;script data-main=\"js/main\" src=\"js/lib/requirejs/require.js\"&gt;&lt;/script&gt;  \n</code></pre>\n\n<p><code>main.js</code>是程序的入口js文件，然后我们在<code>main.js</code>里面进行模块的加载配置：</p>\n\n<pre><code class=\"language-javascript\">requirejs.config({  \n    //开发专用，阻止浏览器缓存\n    urlArgs: \"v=\" + Date.now(),\n    //js文件的目录，相对于引入main.js的那个文件的目录\n    baseUrl: 'js',\n    //对于默认不兼容AMD规范的模块通过shim来配置\n    //deps数组，表明该模块的依赖性，\n    //exports值，表明这个模块外部调用时的名称\n    //下面代码里面包含了如何加载库和插件\n    shim: {\n        'backbone': {\n               deps: ['underscore', 'jquery'],\n            exports: 'Backbone'\n        },\n        'underscore': {\n            exports: '_'\n        },\n        'backbone.localStorage': {\n              deps: ['backbone'],\n              exports: 'Backbone'\n        },\n        'bootstrap.modal': {\n            deps: ['jquery'],\n            exports: 'jQuery.fn.modal'\n        }\n    },\n    //模块的加载路径（不要加.js后缀，因为默认就是加载js，加了会报错）\n    //路径是相对于上面的baseUrl\n    paths: {\n        jquery: 'lib/jquery/jquery-1.11.1.min',\n        underscore: 'lib/underscore/underscore-min',\n        ...\n        text: 'lib/requirejs/plugins/text',\n        echarts:'lib/echarts/echarts',\n        'echarts/chart/bar' : 'lib/echarts/echarts',\n        config: 'modules/common/config'\n    }   \n});\n\n//下面开始加载执行\nrequire(['backbone', 'modules/app'], function (Backbone, AppRouter) {  \n    new AppRouter();\n    Backbone.history.start();\n});\n</code></pre>\n\n<p><strong>requirejs模块定义与加载</strong></p>\n\n<p><code>requirejs</code>定义一个模块相当简单，下面是一个简单的例子:</p>\n\n<pre><code class=\"language-javascript\">define(['backbone'], function(Backbone){  \n    var AppRouter = Backbone.Router.extend({\n        ...\n    });\n\n    //导出对象\n    return AppRouter;\n});\n</code></pre>\n\n<p>我们也可以动态加载模块：</p>\n\n<pre><code class=\"language-javascript\">define(['backbone'], function(Backbone){  \n    var AppRouter = Backbone.Router.extend({\n        ...\n        index： function(){\n            require(['echarts', 'echarts/chart/bar'], function(ec){\n                ...\n            });\n        }\n    });\n\n    //导出对象\n    return AppRouter;\n});\n</code></pre>\n\n<p>如果你已经用习惯了<code>seajs</code>的模块加载方法的话，你也可以像<code>seajs</code>里面那样去加载模块：</p>\n\n<pre><code class=\"language-javascript\">define(function (require) {  \n    var $ = require('jquery');\n\n    return function () {\n        ...\n    };\n});\n</code></pre>\n\n<p>或者<code>CommonJS</code>的方式也ok:</p>\n\n<pre><code class=\"language-javascript\">define(function(require, exports, module) {  \n    ...\n});\n</code></pre>\n\n<p><code>requirejs</code>提供一个加载文本的插件<code>text.js</code>，细心的话你可能已经看到我在<code>requirejs.config</code>里面已经配置了，使用也很简单：</p>\n\n<pre><code class=\"language-javascript\">// 注意这里自定义模块的加载路径\n// 可以写相对路径，那就是相对于当前js文件的路径\n// 也可以写绝对路径，就是相对于baseUrl的路径\ndefine(['backbone','text!../tmpl/index.html'], function(Backbone, html){\n\n});\n</code></pre>\n\n<p><strong>requirejs构建工具r.js</strong></p>\n\n<p>当项目上线的时候，我们可能需要对模块代码进行压缩合并的操作，这时我们就会用到<code>requirejs</code>的构建工具<code>r.js</code>。首先我们在项目根目录创建一个<code>build</code>的文件夹和<code>dist</code>的文件夹，分别用来存放模块合并相关配置和合并后的代码的文件目录，在<code>build</code>目录里面存放<code>r.js</code>，并新建一个压缩合并的配置文件<code>config.js</code>,下面是<code>config.js</code>的配置示例：</p>\n\n<pre><code class=\"language-javascript\">//config.js\n{\n    //requirejs.cofig文件的路径,它会自动读取main.js里面的配置信息\n    mainConfigFile : \"../js/main.js\",\n    baseUrl: '../js',\n    name: \"main\",\n    //输出文件的路径和名称\n    out: \"../dist/js/main.js\",\n    //默认情况写r.js会把相关的依赖文件拷贝到输出目录里面去\n    //设置为true之后r.js就不会进行这一操作\n    removeCombined: true,\n    //findNestedDependencies设置为true表示将所有相关的依赖模块也合并进来，默认为false只会对main.js进行压缩合并的操作\n    findNestedDependencies: true\n}\n</code></pre>\n\n<p>然后在命令行执行：</p>\n\n<pre><code class=\"language-bash\">node r.js -o config.js  \n</code></pre>\n\n<p>执行完成之后便会在<code>dist/js/</code>目录下面生成一个合并后的<code>main.js</code></p>\n\n<p>你会发现这个<code>main.js</code>可能会非常大，而在实际项目中，像通用的一些jquery、backbone等有时候我们可能没有必要把它压缩进来，我们只需要压缩自己写的一些代码，于是我们再次开始配置我们的<code>config.js</code>：</p>\n\n<pre><code class=\"language-javascript\">{\n    mainConfigFile : \"../js/main.js\",\n    baseUrl: \"../js\",\n    removeCombined: true,\n    findNestedDependencies: true,\n    dir: \"../dist/js\",\n    modules: [{\n        name: \"main\",\n        exclude: [\n            \"backbone\",\n            \"underscore\",\n            \"jquery\",\n            \"text\",\n            ...\n        ]\n    }]\n}\n</code></pre>\n\n<p>再次运行压缩合并命令将会发现在<code>exclude</code>数组里面的项不会被合并。</p>\n\n<p>然而我觉得更好的做法是把通用的一些库，如jquery,bacnbone等合并到一个文件里面，我们自己的代码合并到了一个文件，因此，我们重新进行配置。</p>\n\n<p>首先我们新建一个js文件，这个js文件啥也不用做，就是为了引用所有通用的库，这样方便我们进行排除，如下：</p>\n\n<pre><code class=\"language-javascript\">//libs.js\n\ndefine([  \n    \"jquery\",\n    \"underscore\",\n    \"backbone\",\n    ...\n    \"text\"\n], function() {});\n</code></pre>\n\n<p>然后我们的<code>config.js</code>变成了这样：</p>\n\n<pre><code class=\"language-javascript\">{\n    mainConfigFile : \"../js/main.js\",\n    baseUrl: \"../js\",\n    removeCombined: true,\n    findNestedDependencies: true,\n    dir: \"../dist/js\",\n    modules: [\n        {\n            name: \"main\",\n            exclude: [\n                \"libs\"\n            ]\n        },\n           {\n               name: \"libs\"\n           }\n    ]\n}\n</code></pre>\n\n<p>现在，我们的<code>build</code>操作终于完美了。</p>\n\n<p>但是，如果我们的js直接通过cdn引用的呢？如果我们直接运行上面的压缩配置，<code>r.js</code>将会报错。因此，对于从cdn引入的js，我们作如下配置：</p>\n\n<pre><code class=\"language-javascript\">requirejs.config({  \n    paths: {\n        //如果cdn挂点，通过本地加载jquery\n        jquery: ['http://cdn.staticfile.org/jquery/1.11.1/jquery.min.js', 'lib/jquery/jquery-1.11.1.min'],\n        underscore: 'lib/underscore/underscore-min',\n        ...\n        text: 'lib/requirejs/plugins/text',\n        echarts:'lib/echarts/echarts',\n        'echarts/chart/bar' : 'lib/echarts/echarts',\n        config: 'modules/common/config'\n    }  \n});\n\n//修改config.js\n{\n    mainConfigFile : \"../js/main.js\",\n    baseUrl: \"../js\",\n    removeCombined: true,\n    findNestedDependencies: true,\n    dir: \"../dist/js\",\n    modules: [\n        {\n            name: \"main\",\n            exclude: [\n                \"libs\"\n            ]\n        },\n           {\n               name: \"libs\"\n           }\n    ],\n    paths: {\n        jquery: \"empty:\"\n    }\n}\n</code></pre>\n\n<p>我们再次运行合并的操作<code>node r.js -o config.js</code>会发现此时<code>r.js</code>没有把<code>jquery</code>合并进来，因为它是通过cdn加载的。</p>\n\n<p><strong>css的压缩合并配置</strong></p>\n\n<p>虽然我的项目中没有用到，但在这里还是说一下吧。</p>\n\n<p>项目中可能引用了多个css文件，如：</p>\n\n<pre><code class=\"language-html\">&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/bootstrap.css\"&gt;  \n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\"&gt;  \n</code></pre>\n\n<p>如果我们只想引用一个css文件，我们可以这样：</p>\n\n<pre><code class=\"language-css\">@import url('/css/bootstrap.css');\n/* style.css content here…. */\n</code></pre>\n\n<p>然后在压缩合并的时候进行配置：</p>\n\n<pre><code class=\"language-javascript\">//config.js\n{\n    mainConfigFile : \"../js/main.js\",\n    appDir: \"../\",\n    baseUrl: \"js\",\n    removeCombined: true,\n    findNestedDependencies: true,\n    dir: \"../dist\",\n    optimizeCss: \"standard\",\n    modules: [\n        {\n            name: \"main\",\n            exclude: [\n                \"libs\"\n            ]\n        },\n           {\n               name: \"libs\"\n           }\n    ],\n    paths: {\n        jquery: \"empty:\"\n    }，\n    //匹配到的文件或者目录不会被拷贝到dist目录\n    fileExclusionRegExp: /(^\\.|build|dist|sass|config.rb)/,\n    generateSourceMaps: true\n}\n</code></pre>\n\n<blockquote>\n  <p><code>appDir</code>：项目根目录</p>\n  \n  <p><code>optimizeCss</code> ：css压缩规则，有四种，分别是：<code>none</code> 、<code>standard</code> 、<code>standard.keeplines</code>、<code>standard.keepComments</code>、<code>standard.keepComments.keeplines</code>。具体意思我就不一一解释了。</p>\n  \n  <p><code>generateSourceMaps</code>：生成map文件，把压缩过的js与未压缩的作映射</p>\n</blockquote>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701648924,"created_by":1,"updated_at":1495701711847,"updated_by":1,"published_at":1476086040000,"published_by":1},{"id":30,"uuid":"fcd61022-0403-4b78-8f11-a1e3e9eb5a84","title":"RequireJS入门(三)","slug":"requirejs-3","markdown":"前面两篇讲述了r.js如何通过命令行把所有的模块压缩为一个js文件或把所有的css压缩为一个css文件。其中包括一些压缩配置参数的使用。\n\n但以上两种方式有几个问题\n\n* 通过命令手动配置压缩选项显得很呆板\n* 都仅合并为一个文件\n\n对于最后只生成一个文件的库来说，这种方式并无不妥。比如jQuery，它的工程中小文件有20多个，打包后只有一个jquery-1.x.x.js。对于多数实际应用项目来说，可能打包后需要生成多个js文件。有些是页面打开时就要用到的，有些是用户点击或输入时按需加载的。\n\nr.js有另外一种方式来合并压缩，即通过一个配置文件（如build.js）。配置文件内部采用前端工程师非常熟悉JSON格式。这样当项目开发目录固定后，配置文件也相应固定。通过配置文件就很好的隔离了开发环境及上线环境。\n\n这次我们创建的目录中包含所有前端资源，js，css，图片。\n\n![](http://pic002.cnblogs.com/images/2012/114013/2012060811392032.png)\n\n其中有两个页面page1.html，page2.html。这两个页面分别使用page1.js和page2.js。\n\npage1.js依赖于event和selector，page2.js依赖于event、selector和jQuery。jQuery是非本地的，没有合并前我们直接访问这两个页面，那么单个的js文件会依次下载。\n\n![](http://pic002.cnblogs.com/images/2012/114013/2012060811401231.png)\n\n![](http://pic002.cnblogs.com/images/2012/114013/2012060811402732.png)\n\n现在使用r.js来合并压缩，使每个页面除下载require.js外只下载各自合并的大文件page1.js和page2.js。\n\n## build.js如下\n```js\n({\n    appDir: \"./\",\n    baseUrl: \"js\",\n    dir: \"../r6-built\",\n    paths: {\n        jquery: 'empty:'\n    },\n    modules: [\n        {\n            name: \"page1\"\n        },\n        {\n            name: \"page2\"\n        }\n    ]\n})\n```\n\n## 进入命令行输入如下命令\n```js\nnode r.js -o build.js\n```\n\n![](http://pic002.cnblogs.com/images/2012/114013/2012060811423490.png)\n\n会发现在和r6同级的目录生成了r6-built目录\n\n![](http://pic002.cnblogs.com/images/2012/114013/2012060811435458.png)\n\n该目录包含于r6一样的层级结构，这时访问该目录中的page1.html，page2.html。\n\n![](http://pic002.cnblogs.com/images/2012/114013/2012060811442195.png)\n\n![](http://pic002.cnblogs.com/images/2012/114013/2012060811443268.png)\n\n这时的page1.js和page2.js就是其它模块文件的合并。另外在r6-built中其它的模块文件也被压缩了。\n在build.js中可以配置很多其它参数，可以在这个示例文件中找到更多配置选项。这里不一一列举。\n\n## 总结\n通过配置文件方式可以实现更加强大，灵活的合并工作。可以生成多个合并文件，包括不同页面的js、css。\n","html":"<p>前面两篇讲述了r.js如何通过命令行把所有的模块压缩为一个js文件或把所有的css压缩为一个css文件。其中包括一些压缩配置参数的使用。</p>\n\n<p>但以上两种方式有几个问题</p>\n\n<ul>\n<li>通过命令手动配置压缩选项显得很呆板</li>\n<li>都仅合并为一个文件</li>\n</ul>\n\n<p>对于最后只生成一个文件的库来说，这种方式并无不妥。比如jQuery，它的工程中小文件有20多个，打包后只有一个jquery-1.x.x.js。对于多数实际应用项目来说，可能打包后需要生成多个js文件。有些是页面打开时就要用到的，有些是用户点击或输入时按需加载的。</p>\n\n<p>r.js有另外一种方式来合并压缩，即通过一个配置文件（如build.js）。配置文件内部采用前端工程师非常熟悉JSON格式。这样当项目开发目录固定后，配置文件也相应固定。通过配置文件就很好的隔离了开发环境及上线环境。</p>\n\n<p>这次我们创建的目录中包含所有前端资源，js，css，图片。</p>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012060811392032.png\" alt=\"\" /></p>\n\n<p>其中有两个页面page1.html，page2.html。这两个页面分别使用page1.js和page2.js。</p>\n\n<p>page1.js依赖于event和selector，page2.js依赖于event、selector和jQuery。jQuery是非本地的，没有合并前我们直接访问这两个页面，那么单个的js文件会依次下载。</p>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012060811401231.png\" alt=\"\" /></p>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012060811402732.png\" alt=\"\" /></p>\n\n<p>现在使用r.js来合并压缩，使每个页面除下载require.js外只下载各自合并的大文件page1.js和page2.js。</p>\n\n<h2 id=\"buildjs\">build.js如下</h2>\n\n<pre><code class=\"language-js\">({\n    appDir: \"./\",\n    baseUrl: \"js\",\n    dir: \"../r6-built\",\n    paths: {\n        jquery: 'empty:'\n    },\n    modules: [\n        {\n            name: \"page1\"\n        },\n        {\n            name: \"page2\"\n        }\n    ]\n})\n</code></pre>\n\n<h2 id=\"\">进入命令行输入如下命令</h2>\n\n<pre><code class=\"language-js\">node r.js -o build.js  \n</code></pre>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012060811423490.png\" alt=\"\" /></p>\n\n<p>会发现在和r6同级的目录生成了r6-built目录</p>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012060811435458.png\" alt=\"\" /></p>\n\n<p>该目录包含于r6一样的层级结构，这时访问该目录中的page1.html，page2.html。</p>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012060811442195.png\" alt=\"\" /></p>\n\n<p><img src=\"http://pic002.cnblogs.com/images/2012/114013/2012060811443268.png\" alt=\"\" /></p>\n\n<p>这时的page1.js和page2.js就是其它模块文件的合并。另外在r6-built中其它的模块文件也被压缩了。\n在build.js中可以配置很多其它参数，可以在这个示例文件中找到更多配置选项。这里不一一列举。</p>\n\n<h2 id=\"\">总结</h2>\n\n<p>通过配置文件方式可以实现更加强大，灵活的合并工作。可以生成多个合并文件，包括不同页面的js、css。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701719395,"created_by":1,"updated_at":1495701758288,"updated_by":1,"published_at":1475762040000,"published_by":1},{"id":31,"uuid":"d1a4e2b7-b20a-4382-9584-af38f46e0f1c","title":"Shadowrocket科学上网使用教程","slug":"shadowrocket-ss","markdown":"它与Surge的区别不在于代理形式，而是操作界面及自定义部分，配置文件适配Surge的可以快速扩大使用人群及降低使用成本，而且可以对Proxy和DNS部分做单独区别，并且可以强制本机的DNS，我们知道在iOS使用移动网络下是无法自定义DNS的，在运营商DNS已经干扰得不成样的情况下，如果借助外部DNS还是会对网络体验有很大提升。\n其次，我们可以指定DNS做转发，有条件的人可以自己做个专属的DNS转发服务器，扶墙最简单的方式莫过于此，从根本省却了SS这么复杂的方式。\n最后是价格低，每个人都能买到，这就是足够的理由了，虽然还有部分BUG，相信作者也会尽快修复的，多给人鼓励包容，让这类工具多出现总是好的。\n\n\n## 1、准备工作\n* 1、首先你得有一台iPhone, 并且系统一定要在iOS9以上。\n* 2、然后你要安装有 Shadowrocket 这款APP。\n - ①.去AppStore购买: 6元\n - ②.用第三方助手下载: 0元\n* 3、然后你还得有一个SS帐号，可以自己在服务器上搭建，也可以购买，我这里不提供、也不出售。\n\n## 2、添加规则文件\n### 方法1：\n* 进入``Settings``=>``Config``=>``右上角+``，\n* 在地址栏输入``http://joe-10005639.file.myqcloud.com/fuck_gfw_sr.conf``\n* 然后点击``Local files``，选择``Use Config``，也就是选定配置文件。\n\n### 方法2：\n* 进入``Settings``=>``Config``=>``Scan QR code``，扫描以下二维码：\n\n![](http://i1.piimg.com/567571/ba5763a9ced7428f.png)\n\n* 然后点击``Remote files``，选择``Use Config``，也就是选定配置文件。\n\n## 3、填写SS信息\n* 回到主界面，从``Choose A Configuration``里面配置SS信息，如图：\n\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ahl64sutk5j1tpk1dda5068fea.png)\n\n## 4、启动软件\n* 点击连接，出现``VPN``标志表示工作正常。\n\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ahl67481r3c1ch32jo1dtb1mga.png)","html":"<p>它与Surge的区别不在于代理形式，而是操作界面及自定义部分，配置文件适配Surge的可以快速扩大使用人群及降低使用成本，而且可以对Proxy和DNS部分做单独区别，并且可以强制本机的DNS，我们知道在iOS使用移动网络下是无法自定义DNS的，在运营商DNS已经干扰得不成样的情况下，如果借助外部DNS还是会对网络体验有很大提升。\n其次，我们可以指定DNS做转发，有条件的人可以自己做个专属的DNS转发服务器，扶墙最简单的方式莫过于此，从根本省却了SS这么复杂的方式。\n最后是价格低，每个人都能买到，这就是足够的理由了，虽然还有部分BUG，相信作者也会尽快修复的，多给人鼓励包容，让这类工具多出现总是好的。</p>\n\n<h2 id=\"1\">1、准备工作</h2>\n\n<ul>\n<li>1、首先你得有一台iPhone, 并且系统一定要在iOS9以上。</li>\n<li>2、然后你要安装有 Shadowrocket 这款APP。\n<ul><li>①.去AppStore购买: 6元</li>\n<li>②.用第三方助手下载: 0元</li></ul></li>\n<li>3、然后你还得有一个SS帐号，可以自己在服务器上搭建，也可以购买，我这里不提供、也不出售。</li>\n</ul>\n\n<h2 id=\"2\">2、添加规则文件</h2>\n\n<h3 id=\"1\">方法1：</h3>\n\n<ul>\n<li>进入<code>Settings</code>=><code>Config</code>=><code>右上角+</code>，</li>\n<li>在地址栏输入<code>http://joe-10005639.file.myqcloud.com/fuck_gfw_sr.conf</code></li>\n<li>然后点击<code>Local files</code>，选择<code>Use Config</code>，也就是选定配置文件。</li>\n</ul>\n\n<h3 id=\"2\">方法2：</h3>\n\n<ul>\n<li>进入<code>Settings</code>=><code>Config</code>=><code>Scan QR code</code>，扫描以下二维码：</li>\n</ul>\n\n<p><img src=\"http://i1.piimg.com/567571/ba5763a9ced7428f.png\" alt=\"\" /></p>\n\n<ul>\n<li>然后点击<code>Remote files</code>，选择<code>Use Config</code>，也就是选定配置文件。</li>\n</ul>\n\n<h2 id=\"3ss\">3、填写SS信息</h2>\n\n<ul>\n<li>回到主界面，从<code>Choose A Configuration</code>里面配置SS信息，如图：</li>\n</ul>\n\n<p><img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ahl64sutk5j1tpk1dda5068fea.png\" alt=\"\" /></p>\n\n<h2 id=\"4\">4、启动软件</h2>\n\n<ul>\n<li>点击连接，出现<code>VPN</code>标志表示工作正常。</li>\n</ul>\n\n<p><img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ahl67481r3c1ch32jo1dtb1mga.png\" alt=\"\" /></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701775381,"created_by":1,"updated_at":1495701814689,"updated_by":1,"published_at":1472796000000,"published_by":1},{"id":32,"uuid":"b030a5c8-e11a-40b8-9a55-79bbc8adbe98","title":"Surge搭配Shadowsocks科学上网教程","slug":"surge-ss","markdown":"## 1、准备工作\n* 1、首先你得有一台iPhone, 并且系统一定要在`iOS9`以上。\n* 2、然后你要安装有`Surge`这款App。\n\t- ①.去AppStore购买: 328元。\n\t- ②.用第三方助手下载: 0元\n* 3、然后你还得有一个Shadowsocks帐号，可以自己在服务器上搭建，也可以购买，我这里不提供、也不出售。\n* 4、本教程适用于`1.20 Build 511及以上版本`，低版请尽快升级。\n\n\n## 2、添加Surge规则文件\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ag5cqtsg1lg3n95j2lj1j1865a.jpg)\n备用规则文件地址：``http://joe-10005639.file.myqcloud.com/fuck_gfw.conf``\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ag8505tj1bojblffp91bj7bvma.jpg)\n\n## 3、配置Shadowsocks帐号\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ag5cv5pqobn7s9g191ongejra.jpg)\n![](http://7xoatu.com1.z0.glb.clouddn.com/o_1ahl6v9he127v1dp1m8222811n9a.jpg)\n\n## 4、启动Surge\n#### 第一次运行，会出现下面的提示:\n![](http://images.weiphone.net/data/attachment/forum/201511/22/114258hjbbk66gfzbbabdb.jpg)\n![](http://images.weiphone.net/data/attachment/forum/201511/22/114300r1cmzn22vruscavg.jpg)\n![](http://images.weiphone.net/data/attachment/forum/201511/22/114302kpvpumupvpkzmkvr.jpg)\n![](http://images.weiphone.net/data/attachment/forum/201511/22/114300cpeeorhjkoliovss.jpg)\n![](http://images.weiphone.net/data/attachment/forum/201511/22/114302o6bw6vbsyio336vi.jpg)\n#### 点击`Start`之后，出现`VPN`标志后表示成功。\n\n## 5、常见问题\nQ：主要作用？\n`A：科学上网、加速苹果商城，屏蔽优酷、土豆、乐视等广告。`\nQ：速度会慢吗？\n`A：不会，和你平时用Shadowsocks完全一样。`\nQ：能添加多条线路吗？\n`A：你可以自行修改[Proxy]和[Proxy Group]。`\nQ：会耗电吗？\n`A：自己使用过程中，没有任何耗电的感觉，也不会发热。`\nnQ：使用微信什么的，要断开吗？\n`A：完全不需要，因为微信、QQ什么的统统都不走代理。`\nQ：锁屏会断开吗？\n`A：不会。`\nQ：代理了所有的网络，那么用这个软件安全吗？\n`A：只能表示本人倾向于信任它。Surge本身就是一款网络调试工具，高级一点的玩法可以通过Surge来分析其他APP的网络活动。`\nQ：怎么样快速开启和停止？\n`A：Surge提供了通知中心Widget，在Widget里面调出来，很方便的进行开启和停止。`\nQ：上面显示VPN图标了，怎么还是打开不了谷歌？\n`A：显示VPN图标，只能说明Surge接管了你的网络，但是不代表你的SS账号和服务器是正常的，建议检查SS的设置。`","html":"<h2 id=\"1\">1、准备工作</h2>\n\n<ul>\n<li>1、首先你得有一台iPhone, 并且系统一定要在<code>iOS9</code>以上。</li>\n<li>2、然后你要安装有<code>Surge</code>这款App。\n<ul><li>①.去AppStore购买: 328元。</li>\n<li>②.用第三方助手下载: 0元</li></ul></li>\n<li>3、然后你还得有一个Shadowsocks帐号，可以自己在服务器上搭建，也可以购买，我这里不提供、也不出售。</li>\n<li>4、本教程适用于<code>1.20 Build 511及以上版本</code>，低版请尽快升级。</li>\n</ul>\n\n<h2 id=\"2surge\">2、添加Surge规则文件</h2>\n\n<p><img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ag5cqtsg1lg3n95j2lj1j1865a.jpg\" alt=\"\" />\n备用规则文件地址：<code>http://joe-10005639.file.myqcloud.com/fuck_gfw.conf</code>\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ag8505tj1bojblffp91bj7bvma.jpg\" alt=\"\" /></p>\n\n<h2 id=\"3shadowsocks\">3、配置Shadowsocks帐号</h2>\n\n<p><img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ag5cv5pqobn7s9g191ongejra.jpg\" alt=\"\" />\n<img src=\"http://7xoatu.com1.z0.glb.clouddn.com/o_1ahl6v9he127v1dp1m8222811n9a.jpg\" alt=\"\" /></p>\n\n<h2 id=\"4surge\">4、启动Surge</h2>\n\n<h4 id=\"\">第一次运行，会出现下面的提示:</h4>\n\n<p><img src=\"http://images.weiphone.net/data/attachment/forum/201511/22/114258hjbbk66gfzbbabdb.jpg\" alt=\"\" />\n<img src=\"http://images.weiphone.net/data/attachment/forum/201511/22/114300r1cmzn22vruscavg.jpg\" alt=\"\" />\n<img src=\"http://images.weiphone.net/data/attachment/forum/201511/22/114302kpvpumupvpkzmkvr.jpg\" alt=\"\" />\n<img src=\"http://images.weiphone.net/data/attachment/forum/201511/22/114300cpeeorhjkoliovss.jpg\" alt=\"\" />\n<img src=\"http://images.weiphone.net/data/attachment/forum/201511/22/114302o6bw6vbsyio336vi.jpg\" alt=\"\" /></p>\n\n<h4 id=\"startvpn\">点击<code>Start</code>之后，出现<code>VPN</code>标志后表示成功。</h4>\n\n<h2 id=\"5\">5、常见问题</h2>\n\n<p>Q：主要作用？ <br />\n<code>A：科学上网、加速苹果商城，屏蔽优酷、土豆、乐视等广告。</code>\nQ：速度会慢吗？ <br />\n<code>A：不会，和你平时用Shadowsocks完全一样。</code>\nQ：能添加多条线路吗？ <br />\n<code>A：你可以自行修改[Proxy]和[Proxy Group]。</code>\nQ：会耗电吗？ <br />\n<code>A：自己使用过程中，没有任何耗电的感觉，也不会发热。</code>\nnQ：使用微信什么的，要断开吗？ <br />\n<code>A：完全不需要，因为微信、QQ什么的统统都不走代理。</code>\nQ：锁屏会断开吗？ <br />\n<code>A：不会。</code>\nQ：代理了所有的网络，那么用这个软件安全吗？ <br />\n<code>A：只能表示本人倾向于信任它。Surge本身就是一款网络调试工具，高级一点的玩法可以通过Surge来分析其他APP的网络活动。</code>\nQ：怎么样快速开启和停止？ <br />\n<code>A：Surge提供了通知中心Widget，在Widget里面调出来，很方便的进行开启和停止。</code>\nQ：上面显示VPN图标了，怎么还是打开不了谷歌？ <br />\n<code>A：显示VPN图标，只能说明Surge接管了你的网络，但是不代表你的SS账号和服务器是正常的，建议检查SS的设置。</code></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701823825,"created_by":1,"updated_at":1495701863867,"updated_by":1,"published_at":1472800440000,"published_by":1},{"id":33,"uuid":"767784b7-39f9-49d5-844b-325dc6d71d77","title":"webpack+gulp 静态文件打包并自动上传到七牛云存储","slug":"webpack-gulp-qiniu-cdn","markdown":"经过几天的瞎折腾实现了webpack可以与gulp完美结合的进行打包静态文件，并将静态文件上传到七牛云存储，当然也可以传到你想传的云存储了，这里只分享一个七牛的云存储方案。\n\n关于如何使用webpack打包静态代码，这个可以参考我之前的一些文章和方案。\n\n这里只分享一下gulp这边的操作，然后给一个例子实现如何一条命令打包静态文件并更新CDN文件的方法。\n\n```js\nconst gulp = require('gulp');\nconst uglify = require('gulp-uglify');\nconst concat = require('gulp-concat');\nconst shrink = require('gulp-cssshrink');\nconst webpack = require('gulp-webpack');\nconst qn = require('gulp-qn');\n\nconst rev = require('gulp-rev-qn');\nconst revCollector = require('gulp-rev-collector');\nconst runSequence = require('run-sequence');\nconst config = require('./webpack.config');\nconst qiniu_options = {\n  accessKey: 'xxxxxxxxxx',\n  secretKey: 'xxxxxxxxxx',\n  bucket: 'xxxxxxxxxxxxx',\n  domain: 'http://xxxxx.com'\n};\ngulp.task('publish-js', function () {\n  return gulp.src(['./build/js/*.js'])\n    .pipe(uglify())\n    .pipe(rev())\n    .pipe(gulp.dest('./build/js'))\n    .pipe(qn({\n      qiniu: qiniu_options,\n      prefix: 'js'\n    }))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('./build/rev/js'));\n});\ngulp.task('publish-font', function () {\n  return gulp.src(['./build/js/*.woff2','./build/js/*.ttf','./build/js/*.eot','./build/js/*.woff'])\n    .pipe(qn({\n      qiniu: qiniu_options,\n      prefix: 'js'\n    }));\n});\ngulp.task('publish-css', function () {\n  return gulp.src(['./build/js/*.css'])\n    .pipe(rev())\n    .pipe(gulp.dest('./build/js'))\n    .pipe(qn({\n      qiniu: qiniu_options,\n      prefix: 'css'\n    }))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('./build/rev/css'));\n});\ngulp.task('publish-html', function () {\n  return gulp.src(['./build/rev/**/*.json', './build/views/*.html'])\n    .pipe(revCollector({\n      dirReplacements: {\n        '/js/': ''\n      }\n    }))\n    .pipe(gulp.dest('./build/views'));\n});\ngulp.task('default',function(callback){\n  runSequence(\n    ['publish-css','publish-js','publish-font'],\n    'publish-html',\n    callback);\n});\n```\n## PS:\npublish-js：将js文件进行版本更新并上传到七牛。\n\npublish-css：将css文件进行版本更新并上传到七牛。\n\npublish-font：将字体文件上传到七牛。\n\npublish-html：将html文件中对应的js路径进行替换。","html":"<p>经过几天的瞎折腾实现了webpack可以与gulp完美结合的进行打包静态文件，并将静态文件上传到七牛云存储，当然也可以传到你想传的云存储了，这里只分享一个七牛的云存储方案。</p>\n\n<p>关于如何使用webpack打包静态代码，这个可以参考我之前的一些文章和方案。</p>\n\n<p>这里只分享一下gulp这边的操作，然后给一个例子实现如何一条命令打包静态文件并更新CDN文件的方法。</p>\n\n<pre><code class=\"language-js\">const gulp = require('gulp');  \nconst uglify = require('gulp-uglify');  \nconst concat = require('gulp-concat');  \nconst shrink = require('gulp-cssshrink');  \nconst webpack = require('gulp-webpack');  \nconst qn = require('gulp-qn');\n\nconst rev = require('gulp-rev-qn');  \nconst revCollector = require('gulp-rev-collector');  \nconst runSequence = require('run-sequence');  \nconst config = require('./webpack.config');  \nconst qiniu_options = {  \n  accessKey: 'xxxxxxxxxx',\n  secretKey: 'xxxxxxxxxx',\n  bucket: 'xxxxxxxxxxxxx',\n  domain: 'http://xxxxx.com'\n};\ngulp.task('publish-js', function () {  \n  return gulp.src(['./build/js/*.js'])\n    .pipe(uglify())\n    .pipe(rev())\n    .pipe(gulp.dest('./build/js'))\n    .pipe(qn({\n      qiniu: qiniu_options,\n      prefix: 'js'\n    }))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('./build/rev/js'));\n});\ngulp.task('publish-font', function () {  \n  return gulp.src(['./build/js/*.woff2','./build/js/*.ttf','./build/js/*.eot','./build/js/*.woff'])\n    .pipe(qn({\n      qiniu: qiniu_options,\n      prefix: 'js'\n    }));\n});\ngulp.task('publish-css', function () {  \n  return gulp.src(['./build/js/*.css'])\n    .pipe(rev())\n    .pipe(gulp.dest('./build/js'))\n    .pipe(qn({\n      qiniu: qiniu_options,\n      prefix: 'css'\n    }))\n    .pipe(rev.manifest())\n    .pipe(gulp.dest('./build/rev/css'));\n});\ngulp.task('publish-html', function () {  \n  return gulp.src(['./build/rev/**/*.json', './build/views/*.html'])\n    .pipe(revCollector({\n      dirReplacements: {\n        '/js/': ''\n      }\n    }))\n    .pipe(gulp.dest('./build/views'));\n});\ngulp.task('default',function(callback){  \n  runSequence(\n    ['publish-css','publish-js','publish-font'],\n    'publish-html',\n    callback);\n});\n</code></pre>\n\n<h2 id=\"ps\">PS:</h2>\n\n<p>publish-js：将js文件进行版本更新并上传到七牛。</p>\n\n<p>publish-css：将css文件进行版本更新并上传到七牛。</p>\n\n<p>publish-font：将字体文件上传到七牛。</p>\n\n<p>publish-html：将html文件中对应的js路径进行替换。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701872615,"created_by":1,"updated_at":1495701936392,"updated_by":1,"published_at":1480097820000,"published_by":1},{"id":34,"uuid":"d926b142-8470-4343-a8e0-5234e0afe0a3","title":"Webpack分离css单独打包","slug":"webpack-css","markdown":"这个操作很简单的，只需要一个插件就好了，就是extract-text-webpack-plugin\n\n## 1、安装extract-text-webpack-plugin\n```js\ncnpm install extract-text-webpack-plugin --save-dev\n```\n<!-- more -->\n\n## 2、配置文件添加对应配置\n\n首先require一下\n```js\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n```\nplugins里面添加\n```js\nnew ExtractTextPlugin(\"styles.css\"),\n```\n我这里如下：\n```json\nplugins: [\n  new webpack.optimize.CommonsChunkPlugin('common.js'),\n  new ExtractTextPlugin(\"styles.css\"),\n],\n```\nmodules里面对css的处理修改为\n```js\n{test:/\\.css$/, loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\")},\n```\n千万不要重复了，不然会不起作用的\n\n我这里如下：\n```json\nmodule: {\n  loaders: [\n    {test:/\\.css$/, loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\")},\n    {test: /\\.scss$/, loader: \"style!css!sass\"},\n    {test: /\\.less$/, loader: \"style!css!less\"},\n  ]\n},\n```\n## 3、在引入文件里面添加需要的css\n```js\nrequire('../less/app.less');\nrequire('./bower_components/bootstrap-select/dist/css/bootstrap-select.min.css');\nrequire('./bower_components/fancybox/source/jquery.fancybox.css');\n```","html":"<p>这个操作很简单的，只需要一个插件就好了，就是extract-text-webpack-plugin</p>\n\n<h2 id=\"1extracttextwebpackplugin\">1、安装extract-text-webpack-plugin</h2>\n\n<pre><code class=\"language-js\">cnpm install extract-text-webpack-plugin --save-dev  \n</code></pre>\n\n<!-- more -->\n\n<h2 id=\"2\">2、配置文件添加对应配置</h2>\n\n<p>首先require一下</p>\n\n<pre><code class=\"language-js\">var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");  \n</code></pre>\n\n<p>plugins里面添加  </p>\n\n<pre><code class=\"language-js\">new ExtractTextPlugin(\"styles.css\"),  \n</code></pre>\n\n<p>我这里如下：</p>\n\n<pre><code class=\"language-json\">plugins: [  \n  new webpack.optimize.CommonsChunkPlugin('common.js'),\n  new ExtractTextPlugin(\"styles.css\"),\n],\n</code></pre>\n\n<p>modules里面对css的处理修改为  </p>\n\n<pre><code class=\"language-js\">{test:/\\.css$/, loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\")},\n</code></pre>\n\n<p>千万不要重复了，不然会不起作用的</p>\n\n<p>我这里如下：</p>\n\n<pre><code class=\"language-json\">module: {  \n  loaders: [\n    {test:/\\.css$/, loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\")},\n    {test: /\\.scss$/, loader: \"style!css!sass\"},\n    {test: /\\.less$/, loader: \"style!css!less\"},\n  ]\n},\n</code></pre>\n\n<h2 id=\"3css\">3、在引入文件里面添加需要的css</h2>\n\n<pre><code class=\"language-js\">require('../less/app.less');  \nrequire('./bower_components/bootstrap-select/dist/css/bootstrap-select.min.css');  \nrequire('./bower_components/fancybox/source/jquery.fancybox.css');  \n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701941424,"created_by":1,"updated_at":1495701986698,"updated_by":1,"published_at":1481102100000,"published_by":1},{"id":35,"uuid":"38fd4ed8-145b-4817-bcbd-2f4bb14d9228","title":"Webpack 入门及实践","slug":"webpack-basic","markdown":"React自发布以来吸引了越来越多的开发者，React开发和模块管理的主流工具webpack也被大家所熟知。那么webpack有哪些优势，可以成为最主流的React开发工具呢？本文和大家一起探讨一下。\n\n# webpack是什么？\n\nweb开发中常用到的静态资源主要有JavaScript、CSS、图片、Jade等文件，webpack中将静态资源文件称之为模块。webpack是一个模块打包工具，其可以兼容多种js书写规范，且可以处理模块间的依赖关系，具有更强大的js模块化的功能。 官方网站中用下图清晰的描述了webpack采用不同的loader加载不同的资源文件，打包生成多个js文件，也可以根据设置生成独立的图片、css文件等。\n\n# why webpack？\n\n在以往的开发过程中，经常会遇到以下三种情况：\n\n* 项目中资源多样性和依赖性 - js、css、png、less、jade等 为了方便开发，我们经常会使用不同的语法来编写文档，用less、sass、jade等会提高开发效率，但同时我们需要借助gulp或grunt来编写任务编译文件或对图片进行压缩等。\n* js模块规范复杂化 - AMD、CommonJS、UMD、ES6等 requireJS主要用来处理AMD规范的js文件，若使用CommonJS规范的js库文件，需进行AMD规范的封装，才能正常使用。而browserify主要处理CommonJS规范的文件，其他规范也需要进行转化。近期ES6的兴起，前面两种打包工具已经不能满足我们的需求了。\n* 开发与线上文件不一致性（打包压缩造成影响）\n\nwebpack可以很好地解决上面的问题，它具有Grunt、Gulp对于静态资源自动化构建的能力，是一个出色的前端自动化构建工具、模块化工具、资源管理工具。\n\n# webpack 特性\n\nwebpack具有requireJs和browserify的功能，但仍有很多自己的新特性：\n\n1. 对 CommonJS 、 AMD 、ES6的语法做了兼容\n2. 对js、css、图片等资源文件都支持打包\n3. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持\n4. 有独立的配置文件webpack.config.js\n5. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间\n6. 支持 SourceUrls 和 SourceMaps，易于调试\n7. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活\n8. webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快\n\n# webpack 安装及使用\n\nwebpack 可以作为全局的npm模块安装，也可以在当前项目中安装。\n\n```js\nnpm install -g webpack\n```\n\n```js\nnpm install --save-dev webpack\n```\n\nwebpack的使用通常有三种方式：\n\n* 命令行使用：webpack <entry.js> <result.js> 其中entry.js是入口文件，result.js是打包后的输出文件\n* node.js API使用：\n```js\nvar webpack = require('webpack');\nwebpack({\n//configuration\n}, function(err, stats){});\n```\n默认使用当前目录的webpack.config.js作为配置文件。如果要指定另外的配置文件，可以执行：webpack --config webpack.custom.config.js\n\n# webpack 常用命令\n\nwebpack的使用和browserify有些类似，下面列举几个常用命令：\n\n* ``webpack`` 最基本的启动webpack命令\n* ``webpack -w`` 提供watch方法，实时进行打包更新\n* ``webpack -p`` 对打包后的文件进行压缩\n* ``webpack -d`` 提供SourceMaps，方便调试\n* ``webpack --colors`` 输出结果带彩色，比如：会用红色显示耗时较长的步骤\n* ``webpack --profile`` 输出性能数据，可以看到每一步的耗时\n* ``webpack --display-modules`` 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块\n前面的四个命令比较基础，使用频率会比较大，后面的命令主要是用来定位打包时间较长的原因，方便改进配置文件，提高打包效率。\n\n# webpack 配置文件\n\n项目中静态资源文件较多，使用配置文件进行打包会方便很多。最简单的Webpack配置文件webpack.config.js如下所示：\n```js\nmodule.exports = {\n  entry:[\n    './entry.js',\n    ...\n  ],\n  output: {\n    path: __dirname + '/output/',\n    publicPath: \"/output/\",\n    filename: 'result.js'\n  }\n};\n```\n\n* 其中entry参数定义了打包后的入口文件，数组中的所有文件会打包生成一个filename文件\n* output参数定义了输出文件的位置及名字，其中参数path是指文件的绝对路径，publicPath是指访问路径，filename是指输出的文件名。\n\n开发中需要将多个页面的公用模块独立打包，从而可以利用浏览器缓存机制来提高页面加载效率，减少页面初次加载时间，只有当某功能被用到时，才去动态的加载。这就需要使用webpack中的CommonsChunkPlugin插件。具体配置如下：\n\n```js\nvar CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");\nmodule.exports = {\n  entry: { a: \"./a\", b: \"./b\" },\n  output: { filename: \"[name].js\" },\n  plugins: [ new CommonsChunkPlugin(\"common.js\") ]\n}\n```\n在文件中根据下面的方式引用即可。\n```html\n<script src=\"common.js\"></script>\n<script src=\"a.js\"></script>\n<script src=\"b.js\"></script>\n```\n# webpack 模块加载器\n\n在webpack中JavaScript，CSS，LESS，TypeScript，JSX，CoffeeScript，图片等静态文件都是模块，不同模块的加载是通过模块加载器（webpack-loader）来统一管理的。loaders之间是可以串联的，一个加载器的输出可以作为下一个加载器的输入，最终返回到JavaScript上。loader的配置可以写在配置文件中，通过正则表达式的方式对文件进行匹配，具体可参见下面的示例：\n```js\nmodule: {\n    loaders: [{\n        test: /\\.less/,\n        loader:  'style-loader!css-loader!less-loader'\n    }, {\n      test: /\\.(png|jpg)$/,\n      loader: 'url-loader?limit=10000&name=build/[name].[ext]'\n    }]\n}\n```\nloader也支持在js文件中通过require的方式进行加载，只需要在require资源path的前面指定loader，用！来串联不同的loader和资源即可。\n\n```js\nrequire(\"style!css!less!./mystyles.less\");\n```\n\n# css文件独立打包\n\n在webpack中编写js文件时，可以通过require的方式引入其他的静态资源，可通过loader对文件自动解析并打包文件。通常会将js文件打包合并，css文件会在页面的header中嵌入style的方式载入页面。但开发过程中我们并不想将样式打在脚本中，最好可以独立生成css文件，以外链的形式加载。这时extract-text-webpack-plugin插件可以帮我们达到想要的效果。需要使用npm的方式加载插件，然后参见下面的配置，就可以将js中的css文件提取，并以指定的文件名来进行加载。\n\n```js\nnpm install extract-text-webpack-plugin –save-dev\n```\n```js\nplugins: [\n    new ExtractTextPlugin('styles.css')\n]\n```\n# 图片打包\n\nwebpack中对于图片的处理，可以通过url-loader来实现图片的压缩。\n```js\ndiv.img{\n    background: url(../image/xxx.jpg)\n}\n\n//或者\nvar img = document.createElement(\"img\");\nimg.src = require(\"../image/xxx.jpg\");\ndocument.body.appendChild(img);\n```\n针对上面的两种使用方式，loader可以自动识别并处理。根据loader中的设置，webpack会将小于指点大小的文件转化成 base64 格式的 dataUrl，其他图片会做适当的压缩并存放在指定目录中。\n```js\nmodule: {\n    {\n      test: /\\.(png|jpg)$/,\n      loader: 'url-loader?limit=10000&name=build/[name].[ext]'\n    }]\n}\n```\n对于上面的配置，如果图片资源小于10kb就会转化成 base64 格式的 dataUrl，其他的图片会存放在build/文件夹下。\n\n# webpack-dev-server\n\nwebpack除了可以对模块进行打包，还提供了一个开发服务器。它的特点是：\n\n* 基于Node.js Express框架的轻量开发服务器\n* 静态资源Web服务器\n* 开发中会监听文件的变化在内存中实时打包\n\nwebpack-dev-server需要单独安装，命令如下：\n\n```js\nnpm install -g webpack-dev-server\n```\n\n可以使用webpack-dev-server直接启动，也可以增加参数来获取更多的功能，具体配置可以参见[官方文档](http://webpack.github.io/docs/webpack-dev-server.html)。默认启动端口8080，通过localhost:8080/webpack-dev-server/可以访问页面，文件修改后保存时会在页面头部看到sever的状态变化，并且会进行热替换，实现页面的自动刷新。\n\n# 双服务器模式\n\n项目开发中，仅有一台静态服务器是不能满足需求的，我们需要另启一台web服务器，且将静态服务器集成到web服务器中，就可以使用webpack的打包和加载功能。我们只需要修改一下配置文件就可以实现服务器的集成。\n```js\n entry: [\n    './src/page/main.js',\n    'webpack/hot/dev-server',\n    'webpack-dev-server/client?http://127.0.0.1:8080'\n  ]\n  output: {\n    path: __dirname,\n    filename: '[name].js',\n    publicPath: \"http://127.0.0.1:8080/assets/\"\n  }\n  plugins: [\n    new webpack.HotModuleReplacementPlugin()\n  ]\n```\n如果在开发中启动两个服务器并不是一个很好地选择，webpack提供了一个中间件webpack-dev-middleware，但其只能在生产环境中使用，可以实现在内存中实时打包生成虚拟文件，供浏览器访问以及调试。使用方式如下：\n```js\nvar webpackDevMiddleware = require(\"webpack-dev-middleware\");\nvar webpack = require(\"webpack\");\n\nvar compiler = webpack({\n    // configuration\n    output: { path: '/' }\n});\n\napp.use(webpackDevMiddleware(compiler, {\n    // options\n}));\n```\n# PS\n\n通过上面的介绍，基本涵盖了webpack的各个特性及简单的使用方法。最近出了个``hjs-webpack``，可以简化webpack中复杂的配置项，只需要安装开发中所需的loader，无需再module中配置，即可正确使用。有兴趣的同学可以尝试一下。","html":"<p>React自发布以来吸引了越来越多的开发者，React开发和模块管理的主流工具webpack也被大家所熟知。那么webpack有哪些优势，可以成为最主流的React开发工具呢？本文和大家一起探讨一下。</p>\n\n<h1 id=\"webpack\">webpack是什么？</h1>\n\n<p>web开发中常用到的静态资源主要有JavaScript、CSS、图片、Jade等文件，webpack中将静态资源文件称之为模块。webpack是一个模块打包工具，其可以兼容多种js书写规范，且可以处理模块间的依赖关系，具有更强大的js模块化的功能。 官方网站中用下图清晰的描述了webpack采用不同的loader加载不同的资源文件，打包生成多个js文件，也可以根据设置生成独立的图片、css文件等。</p>\n\n<h1 id=\"whywebpack\">why webpack？</h1>\n\n<p>在以往的开发过程中，经常会遇到以下三种情况：</p>\n\n<ul>\n<li>项目中资源多样性和依赖性 - js、css、png、less、jade等 为了方便开发，我们经常会使用不同的语法来编写文档，用less、sass、jade等会提高开发效率，但同时我们需要借助gulp或grunt来编写任务编译文件或对图片进行压缩等。</li>\n<li>js模块规范复杂化 - AMD、CommonJS、UMD、ES6等 requireJS主要用来处理AMD规范的js文件，若使用CommonJS规范的js库文件，需进行AMD规范的封装，才能正常使用。而browserify主要处理CommonJS规范的文件，其他规范也需要进行转化。近期ES6的兴起，前面两种打包工具已经不能满足我们的需求了。</li>\n<li>开发与线上文件不一致性（打包压缩造成影响）</li>\n</ul>\n\n<p>webpack可以很好地解决上面的问题，它具有Grunt、Gulp对于静态资源自动化构建的能力，是一个出色的前端自动化构建工具、模块化工具、资源管理工具。</p>\n\n<h1 id=\"webpack\">webpack 特性</h1>\n\n<p>webpack具有requireJs和browserify的功能，但仍有很多自己的新特性：</p>\n\n<ol>\n<li>对 CommonJS 、 AMD 、ES6的语法做了兼容  </li>\n<li>对js、css、图片等资源文件都支持打包  </li>\n<li>串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持  </li>\n<li>有独立的配置文件webpack.config.js  </li>\n<li>可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间  </li>\n<li>支持 SourceUrls 和 SourceMaps，易于调试  </li>\n<li>具有强大的Plugin接口，大多是内部插件，使用起来比较灵活  </li>\n<li>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</li>\n</ol>\n\n<h1 id=\"webpack\">webpack 安装及使用</h1>\n\n<p>webpack 可以作为全局的npm模块安装，也可以在当前项目中安装。</p>\n\n<pre><code class=\"language-js\">npm install -g webpack  \n</code></pre>\n\n<pre><code class=\"language-js\">npm install --save-dev webpack  \n</code></pre>\n\n<p>webpack的使用通常有三种方式：</p>\n\n<ul>\n<li>命令行使用：webpack <entry.js> <result.js> 其中entry.js是入口文件，result.js是打包后的输出文件</li>\n<li>node.js API使用：</li>\n</ul>\n\n<pre><code class=\"language-js\">var webpack = require('webpack');  \nwebpack({  \n//configuration\n}, function(err, stats){});\n</code></pre>\n\n<p>默认使用当前目录的webpack.config.js作为配置文件。如果要指定另外的配置文件，可以执行：webpack --config webpack.custom.config.js</p>\n\n<h1 id=\"webpack\">webpack 常用命令</h1>\n\n<p>webpack的使用和browserify有些类似，下面列举几个常用命令：</p>\n\n<ul>\n<li><code>webpack</code> 最基本的启动webpack命令</li>\n<li><code>webpack -w</code> 提供watch方法，实时进行打包更新</li>\n<li><code>webpack -p</code> 对打包后的文件进行压缩</li>\n<li><code>webpack -d</code> 提供SourceMaps，方便调试</li>\n<li><code>webpack --colors</code> 输出结果带彩色，比如：会用红色显示耗时较长的步骤</li>\n<li><code>webpack --profile</code> 输出性能数据，可以看到每一步的耗时</li>\n<li><code>webpack --display-modules</code> 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块\n前面的四个命令比较基础，使用频率会比较大，后面的命令主要是用来定位打包时间较长的原因，方便改进配置文件，提高打包效率。</li>\n</ul>\n\n<h1 id=\"webpack\">webpack 配置文件</h1>\n\n<p>项目中静态资源文件较多，使用配置文件进行打包会方便很多。最简单的Webpack配置文件webpack.config.js如下所示：</p>\n\n<pre><code class=\"language-js\">module.exports = {  \n  entry:[\n    './entry.js',\n    ...\n  ],\n  output: {\n    path: __dirname + '/output/',\n    publicPath: \"/output/\",\n    filename: 'result.js'\n  }\n};\n</code></pre>\n\n<ul>\n<li>其中entry参数定义了打包后的入口文件，数组中的所有文件会打包生成一个filename文件</li>\n<li>output参数定义了输出文件的位置及名字，其中参数path是指文件的绝对路径，publicPath是指访问路径，filename是指输出的文件名。</li>\n</ul>\n\n<p>开发中需要将多个页面的公用模块独立打包，从而可以利用浏览器缓存机制来提高页面加载效率，减少页面初次加载时间，只有当某功能被用到时，才去动态的加载。这就需要使用webpack中的CommonsChunkPlugin插件。具体配置如下：</p>\n\n<pre><code class=\"language-js\">var CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");  \nmodule.exports = {  \n  entry: { a: \"./a\", b: \"./b\" },\n  output: { filename: \"[name].js\" },\n  plugins: [ new CommonsChunkPlugin(\"common.js\") ]\n}\n</code></pre>\n\n<p>在文件中根据下面的方式引用即可。</p>\n\n<pre><code class=\"language-html\">&lt;script src=\"common.js\"&gt;&lt;/script&gt;  \n&lt;script src=\"a.js\"&gt;&lt;/script&gt;  \n&lt;script src=\"b.js\"&gt;&lt;/script&gt;  \n</code></pre>\n\n<h1 id=\"webpack\">webpack 模块加载器</h1>\n\n<p>在webpack中JavaScript，CSS，LESS，TypeScript，JSX，CoffeeScript，图片等静态文件都是模块，不同模块的加载是通过模块加载器（webpack-loader）来统一管理的。loaders之间是可以串联的，一个加载器的输出可以作为下一个加载器的输入，最终返回到JavaScript上。loader的配置可以写在配置文件中，通过正则表达式的方式对文件进行匹配，具体可参见下面的示例：</p>\n\n<pre><code class=\"language-js\">module: {  \n    loaders: [{\n        test: /\\.less/,\n        loader:  'style-loader!css-loader!less-loader'\n    }, {\n      test: /\\.(png|jpg)$/,\n      loader: 'url-loader?limit=10000&amp;name=build/[name].[ext]'\n    }]\n}\n</code></pre>\n\n<p>loader也支持在js文件中通过require的方式进行加载，只需要在require资源path的前面指定loader，用！来串联不同的loader和资源即可。</p>\n\n<pre><code class=\"language-js\">require(\"style!css!less!./mystyles.less\");  \n</code></pre>\n\n<h1 id=\"css\">css文件独立打包</h1>\n\n<p>在webpack中编写js文件时，可以通过require的方式引入其他的静态资源，可通过loader对文件自动解析并打包文件。通常会将js文件打包合并，css文件会在页面的header中嵌入style的方式载入页面。但开发过程中我们并不想将样式打在脚本中，最好可以独立生成css文件，以外链的形式加载。这时extract-text-webpack-plugin插件可以帮我们达到想要的效果。需要使用npm的方式加载插件，然后参见下面的配置，就可以将js中的css文件提取，并以指定的文件名来进行加载。</p>\n\n<pre><code class=\"language-js\">npm install extract-text-webpack-plugin –save-dev  \n</code></pre>\n\n<pre><code class=\"language-js\">plugins: [  \n    new ExtractTextPlugin('styles.css')\n]\n</code></pre>\n\n<h1 id=\"\">图片打包</h1>\n\n<p>webpack中对于图片的处理，可以通过url-loader来实现图片的压缩。  </p>\n\n<pre><code class=\"language-js\">div.img{  \n    background: url(../image/xxx.jpg)\n}\n\n//或者\nvar img = document.createElement(\"img\");  \nimg.src = require(\"../image/xxx.jpg\");  \ndocument.body.appendChild(img);  \n</code></pre>\n\n<p>针对上面的两种使用方式，loader可以自动识别并处理。根据loader中的设置，webpack会将小于指点大小的文件转化成 base64 格式的 dataUrl，其他图片会做适当的压缩并存放在指定目录中。</p>\n\n<pre><code class=\"language-js\">module: {  \n    {\n      test: /\\.(png|jpg)$/,\n      loader: 'url-loader?limit=10000&amp;name=build/[name].[ext]'\n    }]\n}\n</code></pre>\n\n<p>对于上面的配置，如果图片资源小于10kb就会转化成 base64 格式的 dataUrl，其他的图片会存放在build/文件夹下。</p>\n\n<h1 id=\"webpackdevserver\">webpack-dev-server</h1>\n\n<p>webpack除了可以对模块进行打包，还提供了一个开发服务器。它的特点是：</p>\n\n<ul>\n<li>基于Node.js Express框架的轻量开发服务器</li>\n<li>静态资源Web服务器</li>\n<li>开发中会监听文件的变化在内存中实时打包</li>\n</ul>\n\n<p>webpack-dev-server需要单独安装，命令如下：</p>\n\n<pre><code class=\"language-js\">npm install -g webpack-dev-server  \n</code></pre>\n\n<p>可以使用webpack-dev-server直接启动，也可以增加参数来获取更多的功能，具体配置可以参见<a href=\"http://webpack.github.io/docs/webpack-dev-server.html\">官方文档</a>。默认启动端口8080，通过localhost:8080/webpack-dev-server/可以访问页面，文件修改后保存时会在页面头部看到sever的状态变化，并且会进行热替换，实现页面的自动刷新。</p>\n\n<h1 id=\"\">双服务器模式</h1>\n\n<p>项目开发中，仅有一台静态服务器是不能满足需求的，我们需要另启一台web服务器，且将静态服务器集成到web服务器中，就可以使用webpack的打包和加载功能。我们只需要修改一下配置文件就可以实现服务器的集成。</p>\n\n<pre><code class=\"language-js\"> entry: [\n    './src/page/main.js',\n    'webpack/hot/dev-server',\n    'webpack-dev-server/client?http://127.0.0.1:8080'\n  ]\n  output: {\n    path: __dirname,\n    filename: '[name].js',\n    publicPath: \"http://127.0.0.1:8080/assets/\"\n  }\n  plugins: [\n    new webpack.HotModuleReplacementPlugin()\n  ]\n</code></pre>\n\n<p>如果在开发中启动两个服务器并不是一个很好地选择，webpack提供了一个中间件webpack-dev-middleware，但其只能在生产环境中使用，可以实现在内存中实时打包生成虚拟文件，供浏览器访问以及调试。使用方式如下：</p>\n\n<pre><code class=\"language-js\">var webpackDevMiddleware = require(\"webpack-dev-middleware\");  \nvar webpack = require(\"webpack\");\n\nvar compiler = webpack({  \n    // configuration\n    output: { path: '/' }\n});\n\napp.use(webpackDevMiddleware(compiler, {  \n    // options\n}));\n</code></pre>\n\n<h1 id=\"ps\">PS</h1>\n\n<p>通过上面的介绍，基本涵盖了webpack的各个特性及简单的使用方法。最近出了个<code>hjs-webpack</code>，可以简化webpack中复杂的配置项，只需要安装开发中所需的loader，无需再module中配置，即可正确使用。有兴趣的同学可以尝试一下。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495701999767,"created_by":1,"updated_at":1495702039699,"updated_by":1,"published_at":1473759960000,"published_by":1},{"id":36,"uuid":"6c9076f8-390c-4ed0-b348-5bddc5aa40e4","title":"初探全新的 Node.js 包管理器 Yarn","slug":"yarn-preview","markdown":"就在前几天， Facebook 发布了新的 node.js 包管理器 Yarn 用以替代 npm 。这个和 Exponent, Google, 以及 Tilde 合作完成的项目。 咱虽然是个半桶水的咸鱼前端，不过也得跟上 Javascript 这股潮 (zhuang) 流 (bi) 的脚步，所以便有了下面这篇文章。大概的浅尝了一下这个自称是又快又可信赖又安全的包管理，所以写的内容不会很详细，更多的可能只是针对这个全新的包管理与 npm 的不同之处来对比。也可能有些地方写得不对，如果有的话，欢(lai)迎(da)指(wo)正(a)。\n<!-- more -->\n![](http://img.blog.csdn.net/20161012124212953)\n## Installation\n\n首先当然是安装啦。跟 npm 这种被钦点而随 nodejs 一起被安装的包管理器不同， Yarn 需要自行手动安装。这也可以理解吧，毕竟是全新的东西。不过老实说，安装体验是不太好的……吧。\n\n为什么怎么说呢……因为我的开发环境是 Arch Linux ，而官方文档只提供了 apt-get 系 Linux 和 yum 系 Linux 的安装方式……\n\n既然志在取代 npm ，那么肯定有全平台的兼容方案咯，果然有适用于所有发行版的手动安装脚本，于是我就尝试这个，可是装了三次没有一次成功，各种问题……\n\n最后发现，其实 yarn 可以直接像装模块那样用 npm 装：\n\n```js\nnpm install -g yarn\n```\n\n啊嘞？一个要取代 npm 的东西，居然还要用 npm 来装？ excuse me ？好吧，不管怎么讲总之是这样装上了，所以我说安装体验一般般……也许可能对其他的发行版来说会好一些吧，可能对于一些大众的发行版和 macOS 来说，安装就是一条命令打进终端的事情。\n\n虽然截止到我写这篇文章的时候，已经有了 Arch Linux 上的安装方式，不过是通过 yaourt(AUR) 的方式，不过我并不觉得对于新手来说手动装一下 yaourt 再装 yarn 比直接装 nodejs 然后 npm install 简单。也许在现阶段，相比什么 Debian/Ubuntu/CentOS 来说 Arch 还是个小众的发行版吧……\n\n## Dependencies Management\n\n安装部分就这样告一段落。既然作为一个包管理，就要做好自己的职责。接下来就想要试试这个新包管理是否真的有它所宣传的那样神奇。接下来我在同样的环境下，将 yarn 和 npm 以及 cnpm 做对比。由于墙内的特殊环境，已将 npm 的 registry 更换为 https://registry.npm.taobao.org 。\n\n## FASTER\n\n在对比之前，我觉得这个对比对 yarn 来说有些不公平，因为 npm 已经设置了国内的镜像，而截止此文章发布的时候 yarn 并没有国内镜像，所以并没有对 yarn 进行特殊的设置。我有些担心这样会不会对测试的结果造成误差。\n\nYarn 既然是 Facebook 家的东西，那我们就首先试一下安装他家的 React 好了：\n\n首先当然是主角 yarn 啦。需要注意的是 yarn 安装依赖的方式不同于 npm ，你需要执行以下命令来安装依赖：\n\n```js\nyarn add react\n```\n\n接下来是 npm 。因为 npm 并不显示命令时间，所以我掐了一下秒表，大概 45s 的样子，是 yarn 的好几倍多。好像比起 npm 来说， yarn 的速度确实快了一些呢，而且 npm 用的还是国内的源。\n\n不过 cnpm 的速度就更快了，只用了 4s 便完成了整个安装过程。但是毕竟 cnpm 是 npm 的衍生产物，处于情理之中。既然这东西可以改善 npm 的速度，谁知道以后会不会有 cyarn 呢？但是通过这个测试我们可以看出， yarn 的速度相比原生 npm 着实是一个质的飞跃，FASTER 并不是浪得虚名。\n\n接下来我又尝试了安装其他的包，多次对比了一下， 平均下来 yarn 会比 npm 快上 3–6 倍（这是安装体积小一些的包的情况）。\n\n## RELIABLE/SECURE\n\n至于这个包管理是否 reliable/secure ，这个我暂时没想到怎么测试。我只知道在我用的时候，偶尔有几率会报一些莫名其妙的错误，但是反复执行两遍命令，就又正常工作了。毕竟 yarn 是新出的东西嘛，可以理解。不过就在这一天之内，yarn 的 GitHub 项目主页已经赢得了 9K star，issues 和 pull request 也有了上千个，可见其火热的程度，所以对于它的前景，我还是很看好的。\n\n## Offline mode\n\nYarn 的一个亮点就是可以离线安装依赖，当然，前提是曾经安装过这个依赖。 Yarn 会缓存安装过的包，下次安装的时候如果指定了 -offline 参数， Yarn 就会直接从缓存中取出这个包，这样将大大缩短安装依赖的时间。\n\n遗憾的是，尽管官方文档我看了一遍又一遍，这个功能还是无法正常在我的环境上工作。我会找一下原因，这一段稍后补充。\n\n但是这个 feature 真的是让人眼前一亮，可以说解决了 npm 的一个短板，很致命的短板。有了这样的功能之后，以后在没有网络的环境下也能够安装已有的依赖的。而且省去了下载的时间，大大提高了效率。想象一下以后执行 react-native init 的时候不用漫长等待 15 分钟了，是不是很开心（当然，什么时候 Facebook 把 react-native init 的安装依赖过程换成自家的包管理安装还是未知数喔）。\n\n## yarn.lock\n\nYarn 通过一个 yarn.lock 文件，来使得你的程序得以在不同的机器上获得一致的体验。虽然这个解释很牵强，好歹我没有机翻给大家看，已经很良心了（雾）。感觉这好像是个很高端的东西，其实主要是对 package.json 的一个补充。\n\n忽如一夜春风来，千树万树梨花开。有时候就是眼睛一睁一闭之间，一个新的东西就这样在你全然不知的时候悄然面世了。今天出了 yarn，明天指不定又会出现什么。庆幸的是，我们还能赶上这个新玩意的早班车。\n\n记得近几日的一篇高端黑文（大雾），描述了在 2016 年学习 Javascript 这门语言的感受，确实，这门语言单单一年的发展，就足以呛死不少人。\n\n但是必须要说 yarn 的出现确实是有进步意义的，他解决了 npm 已知的一些问题，拓展出了新的特性。既然如此，它就是值得去接触和学习的。尽管距离取代 npm 还有好长的一段时间，走好长的一段路，但是可以预见它的前途将是一片的光明。\n\n所以，来吧，你需要尝试一些新的东西。 yarn 未来的成长，将由我们共同见证。","html":"就在前几天， Facebook 发布了新的 node.js 包管理器 Yarn 用以替代 npm 。这个和 Exponent, Google, 以及 Tilde 合作完成的项目。 咱虽然是个半桶水的咸鱼前端，不过也得跟上 Javascript 这股潮 (zhuang) 流 (bi) 的脚步，所以便有了下面这篇文章。大概的浅尝了一下这个自称是又快又可信赖又安全的包管理，所以写的内容不会很详细，更多的可能只是针对这个全新的包管理与 npm 的不同之处来对比。也可能有些地方写得不对，如果有的话，欢(lai)迎(da)指(wo)正(a)。\n<!-- more -->  \n\n<p><img src=\"http://img.blog.csdn.net/20161012124212953\" alt=\"\" /></p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>首先当然是安装啦。跟 npm 这种被钦点而随 nodejs 一起被安装的包管理器不同， Yarn 需要自行手动安装。这也可以理解吧，毕竟是全新的东西。不过老实说，安装体验是不太好的……吧。</p>\n\n<p>为什么怎么说呢……因为我的开发环境是 Arch Linux ，而官方文档只提供了 apt-get 系 Linux 和 yum 系 Linux 的安装方式……</p>\n\n<p>既然志在取代 npm ，那么肯定有全平台的兼容方案咯，果然有适用于所有发行版的手动安装脚本，于是我就尝试这个，可是装了三次没有一次成功，各种问题……</p>\n\n<p>最后发现，其实 yarn 可以直接像装模块那样用 npm 装：</p>\n\n<pre><code class=\"language-js\">npm install -g yarn  \n</code></pre>\n\n<p>啊嘞？一个要取代 npm 的东西，居然还要用 npm 来装？ excuse me ？好吧，不管怎么讲总之是这样装上了，所以我说安装体验一般般……也许可能对其他的发行版来说会好一些吧，可能对于一些大众的发行版和 macOS 来说，安装就是一条命令打进终端的事情。</p>\n\n<p>虽然截止到我写这篇文章的时候，已经有了 Arch Linux 上的安装方式，不过是通过 yaourt(AUR) 的方式，不过我并不觉得对于新手来说手动装一下 yaourt 再装 yarn 比直接装 nodejs 然后 npm install 简单。也许在现阶段，相比什么 Debian/Ubuntu/CentOS 来说 Arch 还是个小众的发行版吧……</p>\n\n<h2 id=\"dependenciesmanagement\">Dependencies Management</h2>\n\n<p>安装部分就这样告一段落。既然作为一个包管理，就要做好自己的职责。接下来就想要试试这个新包管理是否真的有它所宣传的那样神奇。接下来我在同样的环境下，将 yarn 和 npm 以及 cnpm 做对比。由于墙内的特殊环境，已将 npm 的 registry 更换为 <a href=\"https://registry.npm.taobao.org\">https://registry.npm.taobao.org</a> 。</p>\n\n<h2 id=\"faster\">FASTER</h2>\n\n<p>在对比之前，我觉得这个对比对 yarn 来说有些不公平，因为 npm 已经设置了国内的镜像，而截止此文章发布的时候 yarn 并没有国内镜像，所以并没有对 yarn 进行特殊的设置。我有些担心这样会不会对测试的结果造成误差。</p>\n\n<p>Yarn 既然是 Facebook 家的东西，那我们就首先试一下安装他家的 React 好了：</p>\n\n<p>首先当然是主角 yarn 啦。需要注意的是 yarn 安装依赖的方式不同于 npm ，你需要执行以下命令来安装依赖：</p>\n\n<pre><code class=\"language-js\">yarn add react  \n</code></pre>\n\n<p>接下来是 npm 。因为 npm 并不显示命令时间，所以我掐了一下秒表，大概 45s 的样子，是 yarn 的好几倍多。好像比起 npm 来说， yarn 的速度确实快了一些呢，而且 npm 用的还是国内的源。</p>\n\n<p>不过 cnpm 的速度就更快了，只用了 4s 便完成了整个安装过程。但是毕竟 cnpm 是 npm 的衍生产物，处于情理之中。既然这东西可以改善 npm 的速度，谁知道以后会不会有 cyarn 呢？但是通过这个测试我们可以看出， yarn 的速度相比原生 npm 着实是一个质的飞跃，FASTER 并不是浪得虚名。</p>\n\n<p>接下来我又尝试了安装其他的包，多次对比了一下， 平均下来 yarn 会比 npm 快上 3–6 倍（这是安装体积小一些的包的情况）。</p>\n\n<h2 id=\"reliablesecure\">RELIABLE/SECURE</h2>\n\n<p>至于这个包管理是否 reliable/secure ，这个我暂时没想到怎么测试。我只知道在我用的时候，偶尔有几率会报一些莫名其妙的错误，但是反复执行两遍命令，就又正常工作了。毕竟 yarn 是新出的东西嘛，可以理解。不过就在这一天之内，yarn 的 GitHub 项目主页已经赢得了 9K star，issues 和 pull request 也有了上千个，可见其火热的程度，所以对于它的前景，我还是很看好的。</p>\n\n<h2 id=\"offlinemode\">Offline mode</h2>\n\n<p>Yarn 的一个亮点就是可以离线安装依赖，当然，前提是曾经安装过这个依赖。 Yarn 会缓存安装过的包，下次安装的时候如果指定了 -offline 参数， Yarn 就会直接从缓存中取出这个包，这样将大大缩短安装依赖的时间。</p>\n\n<p>遗憾的是，尽管官方文档我看了一遍又一遍，这个功能还是无法正常在我的环境上工作。我会找一下原因，这一段稍后补充。</p>\n\n<p>但是这个 feature 真的是让人眼前一亮，可以说解决了 npm 的一个短板，很致命的短板。有了这样的功能之后，以后在没有网络的环境下也能够安装已有的依赖的。而且省去了下载的时间，大大提高了效率。想象一下以后执行 react-native init 的时候不用漫长等待 15 分钟了，是不是很开心（当然，什么时候 Facebook 把 react-native init 的安装依赖过程换成自家的包管理安装还是未知数喔）。</p>\n\n<h2 id=\"yarnlock\">yarn.lock</h2>\n\n<p>Yarn 通过一个 yarn.lock 文件，来使得你的程序得以在不同的机器上获得一致的体验。虽然这个解释很牵强，好歹我没有机翻给大家看，已经很良心了（雾）。感觉这好像是个很高端的东西，其实主要是对 package.json 的一个补充。</p>\n\n<p>忽如一夜春风来，千树万树梨花开。有时候就是眼睛一睁一闭之间，一个新的东西就这样在你全然不知的时候悄然面世了。今天出了 yarn，明天指不定又会出现什么。庆幸的是，我们还能赶上这个新玩意的早班车。</p>\n\n<p>记得近几日的一篇高端黑文（大雾），描述了在 2016 年学习 Javascript 这门语言的感受，确实，这门语言单单一年的发展，就足以呛死不少人。</p>\n\n<p>但是必须要说 yarn 的出现确实是有进步意义的，他解决了 npm 已知的一些问题，拓展出了新的特性。既然如此，它就是值得去接触和学习的。尽管距离取代 npm 还有好长的一段时间，走好长的一段路，但是可以预见它的前途将是一片的光明。</p>\n\n<p>所以，来吧，你需要尝试一些新的东西。 yarn 未来的成长，将由我们共同见证。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1495702047136,"created_by":1,"updated_at":1495702133731,"updated_by":1,"published_at":1476523020000,"published_by":1}],"users":[{"id":1,"uuid":"8e95c50a-9592-48fd-a0df-8e95f54cac56","name":"江矿宝宝.","slug":"jkbb","password":"$2a$10$TP2un1y0AgqbJO5JBoR8GepvdOLzrnLjc6teItsodBB1v7bY2wkP6","email":"274158741@qq.com","image":"https://joe-10005639.cossh.myqcloud.com/jkbb.jpg","cover":"","bio":"伪前端攻城狮, 喜欢钻研新技术.","website":"https://joname1.github.io","location":"Nanning, GX","accessibility":null,"status":"active","language":"en_US","meta_title":null,"meta_description":null,"tour":null,"last_login":1495622828393,"created_at":1495607638150,"created_by":1,"updated_at":1495770927103,"updated_by":1}],"roles":[{"id":1,"uuid":"15f86754-7144-4f80-9666-3851bcc95691","name":"Administrator","description":"Administrators","created_at":1495607626079,"created_by":1,"updated_at":1495607626079,"updated_by":1},{"id":2,"uuid":"98131394-f032-4ae5-bdaf-516935efdc3a","name":"Editor","description":"Editors","created_at":1495607626079,"created_by":1,"updated_at":1495607626079,"updated_by":1},{"id":3,"uuid":"a12b9580-c433-4ca2-b55c-57f3f07ea1a4","name":"Author","description":"Authors","created_at":1495607626079,"created_by":1,"updated_at":1495607626079,"updated_by":1},{"id":4,"uuid":"a80c2aa8-6954-498e-8f5a-95d3ea45a5da","name":"Owner","description":"Blog Owner","created_at":1495607626079,"created_by":1,"updated_at":1495607626079,"updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"permissions":[{"id":1,"uuid":"78aa671b-cc9f-41fd-956a-145f813bdf51","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":1495607627069,"created_by":1,"updated_at":1495607627069,"updated_by":1},{"id":2,"uuid":"47986818-b086-4ae6-bc2f-40473cd6168a","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":1495607627168,"created_by":1,"updated_at":1495607627168,"updated_by":1},{"id":3,"uuid":"ad39d6b8-b4cc-4dfd-b73a-5d7d2e7a6046","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":1495607627290,"created_by":1,"updated_at":1495607627290,"updated_by":1},{"id":4,"uuid":"d95d3257-d2ee-473e-8791-e70288a0c7e2","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":1495607627397,"created_by":1,"updated_at":1495607627397,"updated_by":1},{"id":5,"uuid":"d58dfd05-067b-4055-831d-7c00153e7bf8","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":1495607627505,"created_by":1,"updated_at":1495607627505,"updated_by":1},{"id":6,"uuid":"393be871-80e1-4456-9d27-676ecbada29d","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":1495607627590,"created_by":1,"updated_at":1495607627590,"updated_by":1},{"id":7,"uuid":"530e2d47-fa0d-4853-b9c7-36e8c3c2f3be","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":1495607627690,"created_by":1,"updated_at":1495607627690,"updated_by":1},{"id":8,"uuid":"8a5e2774-7714-433a-98d2-b55dbe359b2b","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":1495607627774,"created_by":1,"updated_at":1495607627774,"updated_by":1},{"id":9,"uuid":"47f5a243-6fe8-4a5a-a38f-25671f531e43","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":1495607627875,"created_by":1,"updated_at":1495607627875,"updated_by":1},{"id":10,"uuid":"add0afea-f2f9-4e6e-b959-5a49d157278e","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":1495607627959,"created_by":1,"updated_at":1495607627959,"updated_by":1},{"id":11,"uuid":"7a47ddfa-79be-43b4-8dfc-edd0929420ec","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":1495607628060,"created_by":1,"updated_at":1495607628060,"updated_by":1},{"id":12,"uuid":"105e3ffc-79cc-4aee-a52a-80d02b779b3e","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":1495607628153,"created_by":1,"updated_at":1495607628153,"updated_by":1},{"id":13,"uuid":"d528bd19-b0f6-4855-93a9-ab0ce4414bf8","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":1495607628380,"created_by":1,"updated_at":1495607628380,"updated_by":1},{"id":14,"uuid":"0866f624-737e-4d62-932a-45effa6bbf3f","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":1495607628472,"created_by":1,"updated_at":1495607628472,"updated_by":1},{"id":15,"uuid":"b201b71b-0533-456b-9c22-c5bb5e7eebc5","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":1495607628606,"created_by":1,"updated_at":1495607628606,"updated_by":1},{"id":16,"uuid":"cb87a410-c071-4196-8050-1d8c50865c96","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":1495607628699,"created_by":1,"updated_at":1495607628699,"updated_by":1},{"id":17,"uuid":"2fe8f33b-f1d2-47c9-84eb-d642d3232ebd","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":1495607628808,"created_by":1,"updated_at":1495607628808,"updated_by":1},{"id":18,"uuid":"311ea150-686a-46f9-be61-d85b69d58ec0","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":1495607628901,"created_by":1,"updated_at":1495607628901,"updated_by":1},{"id":19,"uuid":"3e6be27b-9c4c-40e1-a004-e5e2cbfe8db9","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":1495607629011,"created_by":1,"updated_at":1495607629011,"updated_by":1},{"id":20,"uuid":"09a06764-6c83-42b9-9e39-ee2dcad5b943","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":1495607629119,"created_by":1,"updated_at":1495607629119,"updated_by":1},{"id":21,"uuid":"851ca000-0cd7-48a3-b7cc-93caa9a3f141","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":1495607629211,"created_by":1,"updated_at":1495607629211,"updated_by":1},{"id":22,"uuid":"83e3a9f5-2741-4634-9629-d4ad211d0550","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":1495607629871,"created_by":1,"updated_at":1495607629871,"updated_by":1},{"id":23,"uuid":"f4fd0076-d125-4756-8699-3f88a52b18c9","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":1495607629982,"created_by":1,"updated_at":1495607629982,"updated_by":1},{"id":24,"uuid":"6bcdf469-b611-44cf-acb3-75387ea9cb5e","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":1495607630124,"created_by":1,"updated_at":1495607630124,"updated_by":1},{"id":25,"uuid":"cae58219-5c1b-4a55-a772-d654a259305d","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":1495607630258,"created_by":1,"updated_at":1495607630258,"updated_by":1},{"id":26,"uuid":"f187db8e-6904-4777-a647-8560ad29df6e","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":1495607630384,"created_by":1,"updated_at":1495607630384,"updated_by":1},{"id":27,"uuid":"5fd045e0-c82a-4846-9e79-3d76fe6b4156","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":1495607630492,"created_by":1,"updated_at":1495607630492,"updated_by":1},{"id":28,"uuid":"d9f7c69c-0699-488f-862f-9014d4d13b30","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":1495607630585,"created_by":1,"updated_at":1495607630585,"updated_by":1},{"id":29,"uuid":"9e6a551a-2b11-4753-88b6-e0beb701f633","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":1495607630702,"created_by":1,"updated_at":1495607630702,"updated_by":1},{"id":30,"uuid":"10e785a2-a26a-49ac-bb72-209f7fbcbda5","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":1495607630795,"created_by":1,"updated_at":1495607630795,"updated_by":1}],"permissions_users":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":2,"permission_id":8},{"id":32,"role_id":2,"permission_id":9},{"id":33,"role_id":2,"permission_id":10},{"id":34,"role_id":2,"permission_id":11},{"id":35,"role_id":2,"permission_id":12},{"id":36,"role_id":2,"permission_id":13},{"id":37,"role_id":2,"permission_id":14},{"id":38,"role_id":2,"permission_id":16},{"id":39,"role_id":2,"permission_id":17},{"id":40,"role_id":2,"permission_id":18},{"id":41,"role_id":2,"permission_id":19},{"id":42,"role_id":2,"permission_id":20},{"id":43,"role_id":2,"permission_id":21},{"id":44,"role_id":2,"permission_id":24},{"id":45,"role_id":2,"permission_id":25},{"id":46,"role_id":2,"permission_id":26},{"id":47,"role_id":2,"permission_id":27},{"id":48,"role_id":2,"permission_id":28},{"id":49,"role_id":2,"permission_id":29},{"id":50,"role_id":2,"permission_id":30},{"id":51,"role_id":3,"permission_id":8},{"id":52,"role_id":3,"permission_id":9},{"id":53,"role_id":3,"permission_id":11},{"id":54,"role_id":3,"permission_id":13},{"id":55,"role_id":3,"permission_id":14},{"id":56,"role_id":3,"permission_id":16},{"id":57,"role_id":3,"permission_id":17},{"id":58,"role_id":3,"permission_id":18},{"id":59,"role_id":3,"permission_id":20},{"id":60,"role_id":3,"permission_id":24},{"id":61,"role_id":3,"permission_id":25},{"id":62,"role_id":3,"permission_id":30}],"permissions_apps":[],"settings":[{"id":1,"uuid":"7e1e1fe6-4c95-4870-ba71-0a450d7753d4","key":"databaseVersion","value":"004","type":"core","created_at":1495607638421,"created_by":1,"updated_at":1495607638421,"updated_by":1},{"id":2,"uuid":"72487972-ea59-4ba2-b24d-de9dfaca18c9","key":"dbHash","value":"cc9d032e-f501-420a-81f6-78da036cc0c3","type":"core","created_at":1495607638422,"created_by":1,"updated_at":1495607640967,"updated_by":1},{"id":3,"uuid":"b6146c22-2651-4eef-9f98-3e8dd8c01720","key":"nextUpdateCheck","value":"1495781256","type":"core","created_at":1495607638422,"created_by":1,"updated_at":1495694856883,"updated_by":1},{"id":4,"uuid":"57a645b7-7716-481d-a484-7052253cdef0","key":"displayUpdateNotification","value":"0.11.9","type":"core","created_at":1495607638422,"created_by":1,"updated_at":1495694856885,"updated_by":1},{"id":5,"uuid":"cb3dab7a-4a0e-47bb-aa67-bb73a476920a","key":"title","value":"江矿宝宝的博客.","type":"blog","created_at":1495607638422,"created_by":1,"updated_at":1495769055702,"updated_by":1},{"id":6,"uuid":"7fffeb93-3846-4c98-a414-5a4e20393149","key":"description","value":"Just be nice, always think twice!","type":"blog","created_at":1495607638422,"created_by":1,"updated_at":1495769055705,"updated_by":1},{"id":7,"uuid":"1d0258bd-39f2-48a8-92ea-54c550567ccd","key":"logo","value":"","type":"blog","created_at":1495607638422,"created_by":1,"updated_at":1495769055710,"updated_by":1},{"id":8,"uuid":"22abe0e0-bd65-40e6-9ae2-d29bb340da8b","key":"cover","value":"https://joe-10005639.cossh.myqcloud.com/bg.jpg","type":"blog","created_at":1495607638423,"created_by":1,"updated_at":1495769055711,"updated_by":1},{"id":9,"uuid":"62398801-e615-484f-b5bb-241397d924c4","key":"defaultLang","value":"en_US","type":"blog","created_at":1495607638423,"created_by":1,"updated_at":1495769055712,"updated_by":1},{"id":10,"uuid":"b734d2a4-b365-4a32-a784-10b59225c2e6","key":"postsPerPage","value":"8","type":"blog","created_at":1495607638424,"created_by":1,"updated_at":1495769055713,"updated_by":1},{"id":11,"uuid":"3a4b4e8c-fb0f-45fd-bccc-8bf42ed4f6f7","key":"forceI18n","value":"true","type":"blog","created_at":1495607638424,"created_by":1,"updated_at":1495769055714,"updated_by":1},{"id":12,"uuid":"381aa523-5a4c-4fa1-a8c7-cea36e71b02d","key":"permalinks","value":"/:slug/","type":"blog","created_at":1495607638425,"created_by":1,"updated_at":1495769055715,"updated_by":1},{"id":13,"uuid":"e2d6fb05-e3ca-4aca-9ed8-24cf8c6e923e","key":"ghost_head","value":"","type":"blog","created_at":1495607638425,"created_by":1,"updated_at":1495769055718,"updated_by":1},{"id":14,"uuid":"3b6d6761-8f7b-4a4a-859b-a15ae6e03d9d","key":"ghost_foot","value":"","type":"blog","created_at":1495607638425,"created_by":1,"updated_at":1495769055719,"updated_by":1},{"id":15,"uuid":"b82d53ad-06d3-4f75-8fb3-bc166220f8f9","key":"labs","value":"{\"publicAPI\":true}","type":"blog","created_at":1495607638425,"created_by":1,"updated_at":1495769055719,"updated_by":1},{"id":16,"uuid":"7c8d8c36-20da-4e7d-8a2b-9b08d7557909","key":"navigation","value":"[]","type":"blog","created_at":1495607638425,"created_by":1,"updated_at":1495769055746,"updated_by":1},{"id":17,"uuid":"f9bf7dc8-b6d5-4b9d-b1f3-314818ea71f5","key":"activeApps","value":"[]","type":"app","created_at":1495607638426,"created_by":1,"updated_at":1495607638426,"updated_by":1},{"id":18,"uuid":"59a96975-5a01-4835-9769-fedfa62d3da6","key":"installedApps","value":"[]","type":"app","created_at":"2017-05-24 06:33:58","created_by":1,"updated_at":"2017-05-27 05:44:08","updated_by":1},{"id":19,"uuid":"b61c823b-b5ac-40bc-895a-b1a5b837c4ab","key":"isPrivate","value":"false","type":"private","created_at":1495607638426,"created_by":1,"updated_at":1495769055747,"updated_by":1},{"id":20,"uuid":"70e9ede9-78c2-49bb-8c22-ede75f33abf2","key":"password","value":"","type":"private","created_at":1495607638426,"created_by":1,"updated_at":1495769055749,"updated_by":1},{"id":21,"uuid":"763d1c52-d205-43a3-8d25-c7eaac004188","key":"activeTheme","value":"casper","type":"theme","created_at":1495607638426,"created_by":1,"updated_at":1495769055717,"updated_by":1},{"id":22,"uuid":"63f25722-5383-4762-8232-f62bc239de98","key":"seenNotifications","value":"[]","type":"core","created_at":"2017-05-27 05:44:07","created_by":1,"updated_at":"2017-05-27 05:44:07","updated_by":1},{"id":23,"uuid":"a567a59e-53a7-445d-a3b7-ac3e27c97943","key":"migrations","value":"{}","type":"core","created_at":"2017-05-27 05:44:07","created_by":1,"updated_at":"2017-05-27 05:44:07","updated_by":1},{"id":24,"uuid":"d3838c53-eaf2-4f8f-8ef5-b7cba6bbef0a","key":"activeTimezone","value":"Etc/UTC","type":"blog","created_at":"2017-05-27 05:44:07","created_by":1,"updated_at":"2017-05-27 05:44:07","updated_by":1},{"id":25,"uuid":"2385a371-85b8-4a53-a005-5647a96d7a7f","key":"amp","value":"true","type":"blog","created_at":"2017-05-27 05:44:07","created_by":1,"updated_at":"2017-05-27 05:44:07","updated_by":1},{"id":26,"uuid":"963c7e33-b0e6-43e7-b34a-745d13ca4666","key":"facebook","value":"","type":"blog","created_at":"2017-05-27 05:44:07","created_by":1,"updated_at":"2017-05-27 05:44:07","updated_by":1},{"id":27,"uuid":"a0e26669-bbcf-482d-8285-5b64dc5b6206","key":"twitter","value":"","type":"blog","created_at":"2017-05-27 05:44:07","created_by":1,"updated_at":"2017-05-27 05:44:07","updated_by":1},{"id":28,"uuid":"ff59ee78-91b1-4e42-9730-b14f41b75007","key":"slack","value":"[{\"url\":\"\"}]","type":"blog","created_at":"2017-05-27 05:44:07","created_by":1,"updated_at":"2017-05-27 05:44:07","updated_by":1}],"tags":[],"posts_tags":[],"apps":[],"app_settings":[],"app_fields":[]}}