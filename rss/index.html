<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[江矿宝宝的博客.]]></title><description><![CDATA[Just be nice, always think twice!]]></description><link>http://localhost:2368/</link><generator>Ghost 0.11</generator><lastBuildDate>Thu, 21 Sep 2017 08:12:09 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[吼啊! Vue2.4组件间通信新姿势]]></title><description><![CDATA[<p>Vue应用在组件化之后，通常存在着 父子组件、兄弟组件、跨级组件 等组件关系，那么组件之间如何进行通信；Vue2.4提供了两种新的组件通讯方法。</p>

<p>在 Vue 中，父子组件的关系可以总结为 props down、events up。</p>

<ul>
<li>父子组件通信 ：父组件通过 props 向下传递数据给子组件</li>
<li><p>子父组件通信 ：子组件通过 events 给父组件发送消息</p>

<ul><li>使用 $on(eventName) 监听事件 </li>
<li>使用 $emit(eventName) 触发事件</li></ul></li>
<li><p>非父子组件通信 ：使用一个空的 Vue 实例作为中央事件总线</p></li>
</ul>

<p>在Vue 2.4 版本引入了组件通讯的新方式。</p>

<h4 id="1sync">1. 重新引入 .sync 修饰符</h4>

<p>熟悉 Vue1.x 的朋友一定对 .sync</p>]]></description><link>http://localhost:2368/vue-component-transmit/</link><guid isPermaLink="false">2ea992d0-7e99-4436-9f18-95b3c7674f35</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Thu, 17 Aug 2017 08:09:00 GMT</pubDate><content:encoded><![CDATA[<p>Vue应用在组件化之后，通常存在着 父子组件、兄弟组件、跨级组件 等组件关系，那么组件之间如何进行通信；Vue2.4提供了两种新的组件通讯方法。</p>

<p>在 Vue 中，父子组件的关系可以总结为 props down、events up。</p>

<ul>
<li>父子组件通信 ：父组件通过 props 向下传递数据给子组件</li>
<li><p>子父组件通信 ：子组件通过 events 给父组件发送消息</p>

<ul><li>使用 $on(eventName) 监听事件 </li>
<li>使用 $emit(eventName) 触发事件</li></ul></li>
<li><p>非父子组件通信 ：使用一个空的 Vue 实例作为中央事件总线</p></li>
</ul>

<p>在Vue 2.4 版本引入了组件通讯的新方式。</p>

<h4 id="1sync">1. 重新引入 .sync 修饰符</h4>

<p>熟悉 Vue1.x 的朋友一定对 .sync 修饰器并不陌生。在Vue1.x 中我们可能会需要对一个 prop 进行『双向绑定』。当一个 子组件 改变了一个 prop的值时，这个变化也会 同步到父组件中 所绑定的值。</p>

<p>因为它破坏了『单向数据流』的假设， .sync 在2.0版本被移除，引起了广泛的讨论。在2.3.0版本 .sync 又回来了，不过与1.x不同。</p>

<p>这次只是原有语法的语法糖(syntax sugar)包装而成，其背后实现原理是，在组件上自动扩充一个额外的 v-on 监听器：</p>

<p>代码如下：</p>

<pre><code class="language-html">&lt;comp:foo.sync="bar"&gt;&lt;/comp&gt;  
</code></pre>

<p>会被扩充为：</p>

<pre><code class="language-html">&lt;child:bar="foo"@update:bar="e =&gt; foo = e"&gt;  
</code></pre>

<p>对于子组件，如果想要更新 foo 的值，则需要显式地触发一个事件，而不是直接修改 prop：</p>

<pre><code class="language-js">this.$emit('update:bar', newValue)  
</code></pre>

<h4 id="2dattrsdlisteners">2. $attrs 与 $listeners</h4>

<p>多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点杀鸡用牛刀。Vue 2.4 版本提供了另一种方法，使用 v-bind=”$attrs”, 将父组件中不被认为 props特性绑定的属性传入子组件中，通常配合 interitAttrs 选项一起使用。</p>

<ul>
<li>2.1 interitAttrs</li>
</ul>

<p>在版本 2.4 之前，默认情况下父作用域的不被作为props特性绑定的属性，将会作为普通的 HTML 属性，应用在跟元素上。</p>

<pre><code class="language-html"> // parent.vue
&lt;template&gt;  
    &lt;child-commpent:foo="f":boo="b"&gt;&lt;/child-comment&gt;
&lt;/template&gt;

&lt;script&gt;  
const childComment = ()=&gt; import('./childCom.vue')  
export default {  
    data () {
      return {
        f: 'Hello world!'
        b: 'Hello Vue!'
      }  
    }
}
&lt;/script&gt;  
</code></pre>

<pre><code class="language-html">// childComment.vue
&lt;template&gt;  
    &lt;div&gt;{{ foo }}&lt;div&gt;
&lt;/template&gt;

&lt;script&gt;  
export default {  
    props: ['foo'] //父作用域的boo不被作为props绑定
}
&lt;/script&gt;  
</code></pre>

<p>//boo会作为普通的 HTML 属性，应用在跟元素上。</p>

<pre><code class="language-html">&lt;div boo="Hello Vue!"&gt;Hello world!&lt;/div&gt;  
</code></pre>

<p>html
设置 interitAttrs 为 false，之后，不会应用到跟元素上。</p>

<pre><code class="language-html">// childCom.vue
&lt;template&gt;  
    &lt;div&gt;{{ foo }}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;  
  export default {
    props: ['foo'],
    inheritAttrs: false
  }
&lt;/script&gt;  
</code></pre>

<p>//boo会作为普通的 HTML 属性，应用在跟元素上。</p>

<pre><code class="language-html">&lt;div&gt;Hello world!&lt;/div&gt;  
</code></pre>

<ul>
<li>2.2 $attrs, $listeners</li>
</ul>

<p>在Vue 2.4 版本,配合 interitAttrs选项， 父组件中未被props(v-on)绑定的属性(事件) 可以在子组件中，通过 $attrs ， $listeners 获取。</p>

<pre><code class="language-html">// demo.vue
  &lt;template&gt;
    &lt;div&gt;
      &lt;child-com:foo="foo":boo="boo":coo="coo":doo="doo"&gt;&lt;/child-com&gt;
    &lt;/div&gt;
  &lt;/tempalte&gt;
  &lt;script&gt;
  const childCom = ()=&gt; import('./childCom1.vue')
  export default {
    data () {
      return {
        foo: 'Hello World!',
        boo: 'Hello Javascript!',
        coo: 'Hello Vue',
        doo: 'Last'
      }
    },
    components: { childCom }
  }
  &lt;/script&gt;
</code></pre>

<pre><code class="language-html">// childCom1.vue
&lt;template&gt;  
  &lt;div&gt;
    &lt;p&gt;foo: {{ foo }}&lt;/p&gt;
    &lt;p&gt;attrs: {{ $attrs }}&lt;/p&gt;
    &lt;child-com2v-bind="$attrs"&gt;&lt;/child-com2&gt;
  &lt;/div&gt;
&lt;/template&gt;  
&lt;script&gt;  
const childCom2 = ()=&gt; import('./childCom2.vue')  
export default {  
  props: ['foo'],  // foo作为props属性绑定
  inheritAttrs: false,
  created () {
    console.log(this.$attrs) // { boo: 'Hello Javascript!', coo: 'Hello Vue', doo: 'Last' }
  }
}
&lt;/script&gt;  
</code></pre>

<pre><code class="language-html">// childCom2.vue
&lt;template&gt;  
  &lt;div&gt;
   &lt;p&gt;boo: {{ boo }}&lt;/p&gt;
   &lt;p&gt;attrs: {{ $attrs }}&lt;/p&gt;
   &lt;child-com3v-bind="$attrs"&gt;&lt;/child-com3&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;  
const childCom3 = ()=&gt; import('./childCom3.vue')  
export default {  
  props: ['boo'] // boo作为props属性绑定
  inheritAttrs: false,
  created () {
    console.log(this.$attrs) // { coo: 'Hello Vue', doo: 'Last' }
  }
}
&lt;/script&gt;  
</code></pre>

<h4 id="">小结</h4>

<p>在Vue2.0被移除的 .sync 被重新加入到2.4版本，不同的是需要显式地触发一个事件，而不是直接修改 prop。
Vue2.4提供了 $attrs , $listeners 来传递数据与事件，跨级组件之间的通讯变得更简单。</p>]]></content:encoded></item><item><title><![CDATA[Vuex 学习总结]]></title><description><![CDATA[<p>对于很多新手来说，只是阅读文档是不好消化，我的建议是看看 vuex 的实例，通过研究实例来学习vuex。这样就会好理解多了。如果还是不能理解，最好办法就是先把store 的四个属性：state， getters, mutations, actions 记下来，然后再分析四个属性的特点，什么地方会用到，是怎样连接在一起的？通过这样问自己问题来进行学习。</p>

<p>简单来说，vuex 就是使用一个 store 对象来包含所有的应用层级状态，也就是数据的来源。当然如果应用比较庞大，我们可以将 store 模块化，也就是每个模块都有自己的 store。一个 store 有四个属性：state, getters, mutations, actions。</p>

<h4 id="1state">1、State</h4>

<p>state 上存放的，说的简单一些就是变量，也就是所谓的状态。没有使用 state 的时候，我们都是直接在 data 中进行初始化的，</p>]]></description><link>http://localhost:2368/vuex-summary/</link><guid isPermaLink="false">05067534-6cc0-442e-b8ac-a38e0ff762df</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Sat, 15 Jul 2017 07:48:00 GMT</pubDate><content:encoded><![CDATA[<p>对于很多新手来说，只是阅读文档是不好消化，我的建议是看看 vuex 的实例，通过研究实例来学习vuex。这样就会好理解多了。如果还是不能理解，最好办法就是先把store 的四个属性：state， getters, mutations, actions 记下来，然后再分析四个属性的特点，什么地方会用到，是怎样连接在一起的？通过这样问自己问题来进行学习。</p>

<p>简单来说，vuex 就是使用一个 store 对象来包含所有的应用层级状态，也就是数据的来源。当然如果应用比较庞大，我们可以将 store 模块化，也就是每个模块都有自己的 store。一个 store 有四个属性：state, getters, mutations, actions。</p>

<h4 id="1state">1、State</h4>

<p>state 上存放的，说的简单一些就是变量，也就是所谓的状态。没有使用 state 的时候，我们都是直接在 data 中进行初始化的，但是有了 state 之后，我们就把 data 上的数据转移到 state 上去了。当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：</p>

<p>其实就是把 state 上保存的变量转移到计算属性上。当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</p>

<pre><code class="language-js">computed: mapState([  
  // 映射 this.count 为 store.state.count
  'count'
])
</code></pre>

<p>为了更好地理解这个函数的作用，我们可以看看它的源代码。
可以看到，mapstate 即可以接受对象，也可以接受数组。最终返回的是一个对象。并且 res[key] 的值都是来于 store 里的，红色那条代码就是。这样就把两个不相关的属性连接起来了,这也是映射。其他几个辅助函数也是类似的。</p>

<h4 id="2getters">2、Getters</h4>

<p>getters上简单来说就是存放一些公共函数供组件调用。getters 会暴露为 store.getters 对象，也就是说可以通过 store .getters[属性]来进行相应的调用。mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性，其实也就是从 getters 中获取对应的属性，跟解构类似。具体如下图这样我们就可以将 getters 中的 evenOrOdd 属性值传给对应组件中的 evenOrOdd 上。Getters 接受 state 作为其第一个参数，Getters 也可以接受其他 getters 作为第二个参数。</p>

<h4 id="3mutations">3、Mutations</h4>

<p>mutations 与事件类似，更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。所以 mutations 上存放的一般就是我们要改变 state 的一些方法。</p>

<pre><code class="language-js">const store = new Vuex.Store({  
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // 变更状态
      state.count++
    }
  }
})
</code></pre>

<p>我们不能直接调用一个 mutation handler。 这个选项更像是事件注册 ：“当触发一个类型为 increment 的 mutation 时，调用此函数 。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：</p>

<pre><code class="language-js">store.commit('increment')  
</code></pre>

<p>当 mutation 事件类型比较多的时候，我们可以使用常量替代 mutation 事件类型。同时把这些常量放在单独的文件中可以让我们的代码合作者对整个 app 包含的 mutation 一目了然：
一条重要的原则就是要记住 mutation 必须是同步函数 。</p>

<h4 id="4actions">4、Actions</h4>

<p>前面说了， mutation 像事件注册，需要相应的触发条件。而 Action 就那个管理触发条件的。
Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。  </p>

<pre><code class="language-js">actions: {  
    increment (context) {
      context.commit('increment')
    }
  }
</code></pre>

<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p>

<p>实践中，我们会经常会用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）</p>

<pre><code class="language-js">actions: {  
  increment ({ commit }) {
    commit('increment')
  }
}
</code></pre>

<p>还记得我们前面说过 mutation 像事件类型吗？因此需要我们给定某个动作来进行触发。而这就是分发 action。Action 通过 store.dispatch 方法触发：</p>

<pre><code class="language-js">store.dispatch('increment')  
</code></pre>

<p>此外，我们还可以在我们可以在 action 内部执行 异步 操作：</p>

<pre><code class="language-js">actions: {  
  incrementAsync ({ commit }) {
    setTimeout(() =&gt; {
      commit('increment')
    }, 1000)
  }
}
</code></pre>

<p>你在组件中使用<code>this.$store.dispatch('xxx')</code> 分发 action，或者使用<code>mapActions</code>辅助函数将组件的 methods 映射为<code>store.dispatch</code>调用（需要先在根节点注入 store ）：</p>

<pre><code class="language-js">import { mapActions } from 'vuex'  
export default {  
  // ...
  methods: {
    ...mapActions([
      'increment' // 映射 this.increment() 为 this.$store.dispatch('increment')
    ]),
    ...mapActions({
      add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment')
    })
  }
}
</code></pre>

<p>这句话意思其实是，当你使用了 <code>mapActions</code>， 你就不需要再次使用 <code>this.$store.dispatch('xxx')</code>，当你没使用的话，你可以需要手动去分法。
什么时候用大家要根据情况而定的。</p>]]></content:encoded></item><item><title><![CDATA[Vue用$emit与$on来进行兄弟组件之间的通信]]></title><description><![CDATA[<pre><code class="language-html">&lt;template&gt;  
  &lt;div id="app"&gt;
    &lt;dom-a&gt;&lt;/dom-a&gt;   
    &lt;dom-b&gt;&lt;/dom-b&gt;   
    &lt;dom-c&gt;&lt;/dom-c&gt;   
  &lt;/div&gt;
&lt;/template&gt;  
</code></pre>

<pre><code class="language-js">  &lt;script&gt;
  var Event = new Vue();

  //组件A
  var A = {
    template: `
      &lt;div&gt;
        &lt;span&gt;我是A组件的数据-&</code></pre>]]></description><link>http://localhost:2368/vue-emit-on/</link><guid isPermaLink="false">2682fb59-655b-4fa1-b1b3-cbf652038c44</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Sat, 01 Jul 2017 09:38:00 GMT</pubDate><content:encoded><![CDATA[<pre><code class="language-html">&lt;template&gt;  
  &lt;div id="app"&gt;
    &lt;dom-a&gt;&lt;/dom-a&gt;   
    &lt;dom-b&gt;&lt;/dom-b&gt;   
    &lt;dom-c&gt;&lt;/dom-c&gt;   
  &lt;/div&gt;
&lt;/template&gt;  
</code></pre>

<pre><code class="language-js">  &lt;script&gt;
  var Event = new Vue();

  //组件A
  var A = {
    template: `
      &lt;div&gt;
        &lt;span&gt;我是A组件的数据-&gt;{{a}}&lt;/span&gt;
        &lt;input type="button" value="把A数据传给C" @click="send"&gt;
      &lt;/div&gt;
    `,
    methods: {
      send () {
        Event.$emit("a-msg", this.a);
      }
    },
    data () {
      return {
        a: "我是a组件中数据"
      }
    }
  };
  //组件B
  var B = {
    template: `
      &lt;div&gt;
        &lt;span&gt;我是B组件的数据-&gt;{{a}}&lt;/span&gt;
        &lt;input type="button" value="把B数据传给C" @click = "send"&gt;
      &lt;/div&gt;
    `,
    methods: {
      send () {
        Event.$emit("b-msg", this.a);
      }
    },
    data () {
      return {
        a: "我是b组件中数据"
      }
    }
  };
  //组件C
  var C = {
    template: `
      &lt;div&gt;
        &lt;h3&gt;我是C组件&lt;/h3&gt;
        &lt;span&gt;接收过来A的数据为: {{a}}&lt;/span&gt;
        &lt;br&gt;
        &lt;span&gt;接收过来B的数据为: {{b}}&lt;/span&gt;
      &lt;/div&gt;
    `,
    mounted () {
      //接收A组件的数据
      Event.$on("a-msg", function (a) {
        this.a = a;
      }.bind(this));

      //接收B组件的数据
      Event.$on("b-msg", function (a) {
        this.b = a;
      }.bind(this));
    },
    data () {
      return {
        a: "",
        b: ""
      }
    }
  };
  window.onload = function () {
    new Vue({
      el: "#app",
      components: {
        "dom-a": A,
        "dom-b": B,
        "dom-c": C
      }
    });
  };
  &lt;/script&gt;
</code></pre>

<p>Vue用$emit与$on来进行跨页面之间的数据传输通信 <br>
on和emit的事件必须是在一个公共的实例上，才能触发。  </p>

<pre><code class="language-js">import Vue from 'vue'

export var bus = new Vue()  
App.vue里created方法里定义事件  
import { bus } from 'bus.js'

created () {  
  bus.$on('tip', (text) =&gt; {
    alert(text)
  })
}
Test.vue组件内调用  
import { bus } from 'bus.js'  
bus.$emit('tip', '123')  
</code></pre>]]></content:encoded></item><item><title><![CDATA[Vue组件($children,$refs,$parent)的使用]]></title><description><![CDATA[<p>如果项目很大，组件很多，怎么样才能准确的、快速的寻找到我们想要的组件了？？</p>

<h4 id="1drefs">1、$refs</h4>

<p>首先你的给子组件做标记。</p>

<pre><code class="language-html">&lt;firstchild ref="one"&gt;&lt;/firstchild&gt;  
</code></pre>

<p>然后在父组件中，通过this.$refs.one就可以访问了这个自组件了，包括访问自组件的data里面的数据，调用它的函数</p>

<h4 id="2dchildren">2、$children</h4>

<p>他返回的是一个组件集合，如果你能清楚的知道子组件的顺序，你也可以使用下标来操作；</p>

<pre><code class="language-js">for(let i=0;i&lt;this.$children.length;i++){  
       console.log(this.$children[i].msg); //输出子组件的msg数据；
 }
</code></pre>

<p>接下来就来一个点的demo</p>

<p>首先定义一个父组件：parentcomponent，</p>

<p>在父组件中我又是使用了两个自组件（假如有一百个自组件） [明确一点，组件只能有一个根节点</p>]]></description><link>http://localhost:2368/vue-children-refs-parent/</link><guid isPermaLink="false">1687d7fb-e06a-4cd6-bab7-522277dde419</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Mon, 29 May 2017 09:00:00 GMT</pubDate><content:encoded><![CDATA[<p>如果项目很大，组件很多，怎么样才能准确的、快速的寻找到我们想要的组件了？？</p>

<h4 id="1drefs">1、$refs</h4>

<p>首先你的给子组件做标记。</p>

<pre><code class="language-html">&lt;firstchild ref="one"&gt;&lt;/firstchild&gt;  
</code></pre>

<p>然后在父组件中，通过this.$refs.one就可以访问了这个自组件了，包括访问自组件的data里面的数据，调用它的函数</p>

<h4 id="2dchildren">2、$children</h4>

<p>他返回的是一个组件集合，如果你能清楚的知道子组件的顺序，你也可以使用下标来操作；</p>

<pre><code class="language-js">for(let i=0;i&lt;this.$children.length;i++){  
       console.log(this.$children[i].msg); //输出子组件的msg数据；
 }
</code></pre>

<p>接下来就来一个点的demo</p>

<p>首先定义一个父组件：parentcomponent，</p>

<p>在父组件中我又是使用了两个自组件（假如有一百个自组件） [明确一点，组件只能有一个根节点 ]，根节点是啥，我不知道。。。。。。</p>

<pre><code class="language-html">&lt;template id="parentcomponent"&gt;  
    &lt;div &gt;
        &lt;p&gt;this is a parent-component&lt;/p&gt;
        &lt;firstchild  ref="f1"&gt;&lt;/firstchild&gt;
        &lt;secondchild ref="f2"&gt;&lt;/secondchild&gt;
        &lt;button @click='show_child_of_parents'&gt;show child msg&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;  
</code></pre>

<p>分别给出两个字组件的定义：（第2个使用的是template,第1个是script）</p>

<pre><code class="language-html">&lt;script type="text/x-template" id="childOne"&gt;  
    &lt;div&gt;
        &lt;p&gt;this is first child&lt;/p&gt;

        //使用stop阻止默认事件（vue的事件处理机制）
        &lt;button @click.stop='getParent'&gt;get parent msg&lt;/button&gt;
    &lt;/div&gt;
&lt;/script&gt;

&lt;template id="childSec"&gt;  
    &lt;div&gt;
        &lt;p&gt;this is second child&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;  
</code></pre>

<p>组件模板定义好了，就是用：</p>

<ul>
<li>挂在元素：</li>
</ul>

<pre><code class="language-js">&lt;script&gt;  
    new Vue({
        el:"#app",
        data:{},
        components:{
            "parent-component":{
                template:'#parentcomponent', 
                data(){
                    return{msg:'这是父组件中的内容'}                    
                },
                methods:{
                    show_child_of_parents(){
                        //children方式访问自组件
　　　　　　　　　　　　　　 for(let i=0;i&lt;this.$children.length;i++){
                                console.log(this.$children[i].msg);
                        }
　　　　　　　　　　　　　　　//通过$ref打标记，访问子组件　
                        console.log(this.$refs.f1.msg);
 　　　　　　　　　　　　　　this.$refs.f1.getParent();
                    },                                    
                },    
　　　　　　　　　　     
                components:{
                    'firstchild':{
                        template:'#childOne',
                        data(){
                            return {msg:'这是第一个子组件'};
                        },
                        methods:{
                            getParent(){
                                let a=1;
                                console.log(a);
                                alert(this.$parent.msg);

                            }
                        },
                    },

                    'secondchild':{
                        template:'#childSec',
                        data(){
                            return {msg:"这是第二个组件"};
                        }
                    }

                }

            }
        }

    });

&lt;/script&gt;  
</code></pre>

<ul>
<li>使用父组件了</li>
</ul>

<pre><code class="language-html">    &lt;body&gt;
        &lt;p&gt;&lt;strong&gt;可以通过$refs访问父组件的子组件&lt;/strong&gt;&lt;/p&gt;
        &lt;div id="app"&gt;
            &lt;parent-component&gt;&lt;/parent-component&gt;
        &lt;/div&gt;
    &lt;/body&gt;
</code></pre>

<h4 id="">小结</h4>

<ul>
<li><p>组件只能一个根节点</p></li>
<li><p>可以在自组件中使用this.$parent.属性值，或者函数</p></li>
<li><p>在父组件中可以使用this.$refs.组件的标记访问子组件，或者this.$children[i].属性访问子组件</p></li>
<li><p>你需要注意this的指向</p></li>
</ul>]]></content:encoded></item><item><title><![CDATA[webpack+vue项目中常用ES6语法总结]]></title><description><![CDATA[<h3 id="babel">Babel</h3>

<p>ES6标准虽然已经发布了，但是很多浏览器环境都还不支持，webpack是通过Babel这个转码器将ES6代码转为ES5，从而在现有环境执行。babel是在webpack的配置文件webpack.config.js的module参数中的loaders中配置，如下：  </p>

<pre><code class="language-js">module.exports = {  
    ...
    module: {
        loaders: [
        {
            test: /\.js$/,
            loader: 'babel',
            exclude: /node_modules/
        },
        ...
        ]
    }
}
</code></pre>

<p>配置完成后还需要安装”babel-loader”模块</p>

<pre><code class="language-js">npm i babel-loader -D  
</code></pre>

<p>然后webpack就可以对用了ES6语法的js文件进行转码了。下面总结一些常用到的ES6语法。</p>

<h3 id="letconst">let和const命令</h3>

<ul>
<li>let命令</li>
</ul>

<p>ES6中let命令用来声明变量，用法类似于var，但是let所声明的变量是局部变量，只在let命令所在的代码块内有效。所以在for循环中很适合用let变量做计数器。 <br>
let变量不会像var变量那样会进行变量提升，变量一定要在声明后使用，否则会报错。 <br>
只要块级作用域内存在let命令，它所声明的所有变量都绑定这个作业域，不收外部变量的影响，即形成了一个封闭的作用域。
let不允许在相同作用域内重复声明同一个变量。可以看出，let变量实际上为JavaScript新增了块级作用域</p>

<ul>
<li>const命令</li>
</ul>

<p>const声明一个只读的常量，一旦声明，值就不能改变。</p>]]></description><link>http://localhost:2368/webpack-vue-es6/</link><guid isPermaLink="false">cfec3ed8-4933-4a85-a47d-debc2796436b</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Sat, 27 May 2017 02:46:00 GMT</pubDate><content:encoded><![CDATA[<h3 id="babel">Babel</h3>

<p>ES6标准虽然已经发布了，但是很多浏览器环境都还不支持，webpack是通过Babel这个转码器将ES6代码转为ES5，从而在现有环境执行。babel是在webpack的配置文件webpack.config.js的module参数中的loaders中配置，如下：  </p>

<pre><code class="language-js">module.exports = {  
    ...
    module: {
        loaders: [
        {
            test: /\.js$/,
            loader: 'babel',
            exclude: /node_modules/
        },
        ...
        ]
    }
}
</code></pre>

<p>配置完成后还需要安装”babel-loader”模块</p>

<pre><code class="language-js">npm i babel-loader -D  
</code></pre>

<p>然后webpack就可以对用了ES6语法的js文件进行转码了。下面总结一些常用到的ES6语法。</p>

<h3 id="letconst">let和const命令</h3>

<ul>
<li>let命令</li>
</ul>

<p>ES6中let命令用来声明变量，用法类似于var，但是let所声明的变量是局部变量，只在let命令所在的代码块内有效。所以在for循环中很适合用let变量做计数器。 <br>
let变量不会像var变量那样会进行变量提升，变量一定要在声明后使用，否则会报错。 <br>
只要块级作用域内存在let命令，它所声明的所有变量都绑定这个作业域，不收外部变量的影响，即形成了一个封闭的作用域。
let不允许在相同作用域内重复声明同一个变量。可以看出，let变量实际上为JavaScript新增了块级作用域</p>

<ul>
<li>const命令</li>
</ul>

<p>const声明一个只读的常量，一旦声明，值就不能改变。所以，const一旦声明就必须立即初始化，不能只声明不初始化。 <br>
const作用域和let命令相同，只在声明所在的块级作用域中有效。const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>

<h3 id="">函数的扩展</h3>

<ul>
<li>函数参数的默认值</li>
</ul>

<p>在ES6之前不能直接为函数的参数指定默认值，只能采用变通的方法。ES6允许为函数参数设置默认值，直接写在参数定义的后面。</p>

<pre><code class="language-js">function log(x, y='World') {  
    console.log(x, y);
}
log('Hello')  
</code></pre>

<ul>
<li>参数默认值的位置</li>
</ul>

<p>通常定义了默认值的参数应该是函数的尾参数，如果是非尾部的参数设置默认值，实际上这个参数是没法省略的。除非显式输入undefined。</p>

<ul>
<li>箭头函数</li>
</ul>

<p>ES6允许使用“箭头”（=>）定义函数。</p>

<pre><code class="language-js">var f = v =&gt; v;  
</code></pre>

<p>上述函数等同于：</p>

<pre><code class="language-js">var f = function(v) {  
    return v;
};
</code></pre>

<p>若箭头函数不需要参数或者需要多于一个参数，就使用一个圆括号代表参数部分。</p>

<pre><code class="language-js">var f = () =&gt; 5;  
// 等同于
var f = function() {  
    return 5;
}
</code></pre>

<pre><code class="language-js">var sum = (num1, num2) =&gt; num1 + num2;  
// 等同于
var sum = function(num1, num2) {  
    return num1 + num2;
}
</code></pre>

<p>若箭头函数的代码部分多于一条语句，就要使用大括号将他们括起来，并且使用return语句返回。</p>

<pre><code class="language-js">var sum = (num1, num2) =&gt; { return num1 + num2; }  
</code></pre>

<h4 id="">使用注意点</h4>

<p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
不可当做构造函数，不可以使用new命令，否则会抛出错误。
不可使用arguments对象，该对象在函数体内不存在，可以用Rest参数代替。</p>

<h3 id="module">Module</h3>

<p>ES6之前，JavaScript一直没有模块（module）体系，ES6在语言规格的层面上，实现了模块功能，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 <br>
ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时采用静态命令的形式。  </p>

<pre><code class="language-js">import {stat, exists, readFile} from 'fs';  
</code></pre>

<p>上面代码就是从fs模块加载3个方法，其他方法不加载。这种加载成为“编译时加载”。ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。</p>

<h3 id="export">export命令</h3>

<p>模块功能主要由两个命令构成，export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>

<pre><code class="language-js">export var firstName = 'Michael';  
export var lastName = 'Jackson';  
export var year = 1958;  
</code></pre>

<p>还可以如下写：</p>

<pre><code class="language-js">var firstName = 'Michael';  
var lastName = 'Jackson';  
var year = 1958;  
export {firstName, lastName, year};  
</code></pre>

<p>export除了输出变量通用可以输出函数或者类，export输出的变量还可以用as关键字重命名。  </p>

<pre><code class="language-js">function v1() { ... }  
function v2() { ... }  
export {  
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
</code></pre>

<h3 id="import">import命令</h3>

<p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。用法上面已经有介绍，如果想为输入的变量重命名，使用as关键字。</p>

<pre><code class="language-js">import { lastName as surname } from './profile';  
</code></pre>]]></content:encoded></item><item><title><![CDATA[AngularJS动态加载Controller]]></title><description><![CDATA[<p>AngularJS原生并不支持动态加载Controller的方法，但是却提供注册Controller的方法。接下来就来看下如何实现动态加载Controller。</p>

<!-- more -->

<p>我们把实现动态加载Controller方法封装到一个通用的模块里面，并命名这个模块为<code>ngCommon</code>。</p>

<pre><code class="language-javascript">(function (angular) {'use strict';
    var CommonApp = angular.module('ngCommon');
    ...
})(angular);
</code></pre>

<p>接下来我们实现一个动态加载js的方法<code>$require</code>。</p>

<pre><code class="language-javascript">/* 记录已加载的js */
var loaded = {};  
/* 检测是否加载 */
var checkLoaded = function (url) {  
    return !url || !angular.isString(url) || loaded[url];
};

CommonApp.factory('$require', ['$document', '$q', '$rootScope', function ($document, $q, $rootScope) {  
    return function (url)</code></pre>]]></description><link>http://localhost:2368/angularjs-controller/</link><guid isPermaLink="false">b97f8410-a4cd-401c-b6bc-82220ce261ac</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Thu, 25 May 2017 08:24:25 GMT</pubDate><content:encoded><![CDATA[<p>AngularJS原生并不支持动态加载Controller的方法，但是却提供注册Controller的方法。接下来就来看下如何实现动态加载Controller。</p>

<!-- more -->

<p>我们把实现动态加载Controller方法封装到一个通用的模块里面，并命名这个模块为<code>ngCommon</code>。</p>

<pre><code class="language-javascript">(function (angular) {'use strict';
    var CommonApp = angular.module('ngCommon');
    ...
})(angular);
</code></pre>

<p>接下来我们实现一个动态加载js的方法<code>$require</code>。</p>

<pre><code class="language-javascript">/* 记录已加载的js */
var loaded = {};  
/* 检测是否加载 */
var checkLoaded = function (url) {  
    return !url || !angular.isString(url) || loaded[url];
};

CommonApp.factory('$require', ['$document', '$q', '$rootScope', function ($document, $q, $rootScope) {  
    return function (url) {
        var script = null;
        var onload = null;
        var doc = $document[0];
        var body = doc.body;
        var deferred = $q.defer();
        if (checkLoaded(url)) {
            deferred.resolve();
        } else {
            script = doc.createElement('script');
            onload = function (info) {
                if (info === 1) {
                    deferred.reject();
                } else {
                    loaded[url] = 1;
                    /* AngularJS &lt; 1.2.x 请使用$timeout */
                    $rootScope.$evalAsync(function () {
                        deferred.resolve();
                    });
                }
                script.onload = script.onerror = null;
                body.removeChild(script);
                script = null;
            };
            script.onload = onload;
            script.onerror = function () {
                onload(1);
            };
            script.async = true;
            script.src = url;
            body.appendChild(script);
        }
        return deferred.promise;
    };
}]);
</code></pre>

<p>然后重点来了，通过<code>$routeProvider route</code>的<code>resolve</code>功能来实现动态加载Controller。</p>

<pre><code class="language-javascript">CommonApp.provider('$routeResolver', function () {  
    this.$get = function () {
        return this;
    };
    this.route = function (routeCnf) {
        var controller = routeCnf.controller;
        var controllerUrl = routeCnf.controllerUrl;
        if (controllerUrl) {
            routeCnf.reloadOnSearch = routeCnf.reloadOnSearch || false;
            routeCnf.resolve = {
                load: ['$route', '$require', 'ControllerChecker',
                    function ($route, $require, ControllerChecker) {
                        var controllerName = angular.isFunction(controller) ? controller($route.current.params) : controller;
                        var url = angular.isFunction(controllerUrl) ? controllerUrl($route.current.params) : controllerUrl;
                        if (checkLoaded(url) || (controllerName &amp;&amp; ControllerChecker.exists(controllerName))) {
                            loaded[url] = true;
                            return;
                        }
                        return $require(url);
                }]
            };
        }
        return routeCnf;
    };
})
</code></pre>

<p>看上面的代码中还注入了一个叫<code>ControllerChecker</code>的，这个是用来检测当前Controller是否已经注册了，如果未注册，那么我们就加载相关js注册新的Controller。
代码如下：</p>

<pre><code class="language-javascript">CommonApp.service('ControllerChecker', ['$controller', function ($controller) {  
    return {
        exists: function (controllerName) {
            if (angular.isFunction(window[controllerName])) {
                return true;
            }
            try {
                $controller(controllerName, {}, true);
                return true;
            } catch (e) {
                return false;
            }
        }
    };
}]);
</code></pre>

<p>最后我们来添加一个注动态册的方法。</p>

<pre><code class="language-javascript">CommonApp.setupRegister = function (module) {  
    module.config([
        '$controllerProvider',
        '$compileProvider',
        '$filterProvider',
        '$provide',
        function ($controllerProvider, $compileProvider, $filterProvider, $provide) {
            module.register = {
                controller: $controllerProvider.register,
                directive: $compileProvider.directive,
                filter: $filterProvider.register,
                factory: $provide.factory,
                service: $provide.service,
                value: $provide.value,
                constant: $provide.constant
            };
        }
    ]);
};
</code></pre>

<p>到此已经基本完成了，如何使用呢？</p>

<pre><code class="language-javascript">var DemoApp = angular.module('DemoApp',['ngRoute','ngCommon']);  
/* 调用动态注册方法，为当前模块添加动态注册方法 */
angular.module('ngCommon').setupRegister(DemoApp);  
DemoApp.config(['$routeProvider', '$routeResolverProvider', function ($routeProvider, $routeResolverProvider) {  
    var route = $routeResolverProvider.route;
    $routeProvider.when('/index', route({
        templateUrl: './view/index.html'),
        controller: 'IndexController', /* 在此申明了controller就不需要再html里面申明ng-controller了 */
        controllerUrl: './controller/index.js')
    }))
    .otherwise('/index');

/* ./controller/index.js */
DemoApp.register.controller('IndexController', ['$scope', '$require', function($scope, $require) {  
    ...
    /* 动态加载某个js文件 */
    $require(url).then(function () {
        ...
    });
}]);
</code></pre>]]></content:encoded></item><item><title><![CDATA[Webpack分离css单独打包]]></title><description><![CDATA[<p>这个操作很简单的，只需要一个插件就好了，就是extract-text-webpack-plugin</p>

<h2 id="1extracttextwebpackplugin">1、安装extract-text-webpack-plugin</h2>

<pre><code class="language-js">cnpm install extract-text-webpack-plugin --save-dev  
</code></pre>

<!-- more -->

<h2 id="2">2、配置文件添加对应配置</h2>

<p>首先require一下</p>

<pre><code class="language-js">var ExtractTextPlugin = require("extract-text-webpack-plugin");  
</code></pre>

<p>plugins里面添加  </p>

<pre><code class="language-js">new ExtractTextPlugin("styles.css"),  
</code></pre>

<p>我这里如下：</p>

<pre><code class="language-json">plugins: [  
  new webpack.optimize.CommonsChunkPlugin('common.js'),
  new ExtractTextPlugin("styles.css"),
],
</code></pre>

<p>modules里面对css的处理修改为  </p>

<pre><code class="language-js">{test:/\.css$/, loader: ExtractTextPlugin.extract("style-loader", "css-loader")},
</code></pre>

<p>千万不要重复了，不然会不起作用的</p>

<p>我这里如下：</p>

<pre><code class="language-json">module: {  
  loaders: [
    {test:/\.css$/, loader: ExtractTextPlugin.</code></pre>]]></description><link>http://localhost:2368/webpack-css/</link><guid isPermaLink="false">d926b142-8470-4343-a8e0-5234e0afe0a3</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Wed, 07 Dec 2016 09:15:00 GMT</pubDate><content:encoded><![CDATA[<p>这个操作很简单的，只需要一个插件就好了，就是extract-text-webpack-plugin</p>

<h2 id="1extracttextwebpackplugin">1、安装extract-text-webpack-plugin</h2>

<pre><code class="language-js">cnpm install extract-text-webpack-plugin --save-dev  
</code></pre>

<!-- more -->

<h2 id="2">2、配置文件添加对应配置</h2>

<p>首先require一下</p>

<pre><code class="language-js">var ExtractTextPlugin = require("extract-text-webpack-plugin");  
</code></pre>

<p>plugins里面添加  </p>

<pre><code class="language-js">new ExtractTextPlugin("styles.css"),  
</code></pre>

<p>我这里如下：</p>

<pre><code class="language-json">plugins: [  
  new webpack.optimize.CommonsChunkPlugin('common.js'),
  new ExtractTextPlugin("styles.css"),
],
</code></pre>

<p>modules里面对css的处理修改为  </p>

<pre><code class="language-js">{test:/\.css$/, loader: ExtractTextPlugin.extract("style-loader", "css-loader")},
</code></pre>

<p>千万不要重复了，不然会不起作用的</p>

<p>我这里如下：</p>

<pre><code class="language-json">module: {  
  loaders: [
    {test:/\.css$/, loader: ExtractTextPlugin.extract("style-loader", "css-loader")},
    {test: /\.scss$/, loader: "style!css!sass"},
    {test: /\.less$/, loader: "style!css!less"},
  ]
},
</code></pre>

<h2 id="3css">3、在引入文件里面添加需要的css</h2>

<pre><code class="language-js">require('../less/app.less');  
require('./bower_components/bootstrap-select/dist/css/bootstrap-select.min.css');  
require('./bower_components/fancybox/source/jquery.fancybox.css');  
</code></pre>]]></content:encoded></item><item><title><![CDATA[webpack+gulp 静态文件打包并自动上传到七牛云存储]]></title><description><![CDATA[<p>经过几天的瞎折腾实现了webpack可以与gulp完美结合的进行打包静态文件，并将静态文件上传到七牛云存储，当然也可以传到你想传的云存储了，这里只分享一个七牛的云存储方案。</p>

<p>关于如何使用webpack打包静态代码，这个可以参考我之前的一些文章和方案。</p>

<p>这里只分享一下gulp这边的操作，然后给一个例子实现如何一条命令打包静态文件并更新CDN文件的方法。</p>

<pre><code class="language-js">const gulp = require('gulp');  
const uglify = require('gulp-uglify');  
const concat = require('gulp-concat');  
const shrink = require('gulp-cssshrink');  
const webpack = require('gulp-webpack');  
const qn = require('gulp-qn');

const rev = require('gulp-rev-qn');  
const revCollector = require('gulp-rev-collector');  
const runSequence = require('run-sequence');  
const config = require('./webpack.config')</code></pre>]]></description><link>http://localhost:2368/webpack-gulp-qiniu-cdn/</link><guid isPermaLink="false">767784b7-39f9-49d5-844b-325dc6d71d77</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Fri, 25 Nov 2016 18:17:00 GMT</pubDate><content:encoded><![CDATA[<p>经过几天的瞎折腾实现了webpack可以与gulp完美结合的进行打包静态文件，并将静态文件上传到七牛云存储，当然也可以传到你想传的云存储了，这里只分享一个七牛的云存储方案。</p>

<p>关于如何使用webpack打包静态代码，这个可以参考我之前的一些文章和方案。</p>

<p>这里只分享一下gulp这边的操作，然后给一个例子实现如何一条命令打包静态文件并更新CDN文件的方法。</p>

<pre><code class="language-js">const gulp = require('gulp');  
const uglify = require('gulp-uglify');  
const concat = require('gulp-concat');  
const shrink = require('gulp-cssshrink');  
const webpack = require('gulp-webpack');  
const qn = require('gulp-qn');

const rev = require('gulp-rev-qn');  
const revCollector = require('gulp-rev-collector');  
const runSequence = require('run-sequence');  
const config = require('./webpack.config');  
const qiniu_options = {  
  accessKey: 'xxxxxxxxxx',
  secretKey: 'xxxxxxxxxx',
  bucket: 'xxxxxxxxxxxxx',
  domain: 'http://xxxxx.com'
};
gulp.task('publish-js', function () {  
  return gulp.src(['./build/js/*.js'])
    .pipe(uglify())
    .pipe(rev())
    .pipe(gulp.dest('./build/js'))
    .pipe(qn({
      qiniu: qiniu_options,
      prefix: 'js'
    }))
    .pipe(rev.manifest())
    .pipe(gulp.dest('./build/rev/js'));
});
gulp.task('publish-font', function () {  
  return gulp.src(['./build/js/*.woff2','./build/js/*.ttf','./build/js/*.eot','./build/js/*.woff'])
    .pipe(qn({
      qiniu: qiniu_options,
      prefix: 'js'
    }));
});
gulp.task('publish-css', function () {  
  return gulp.src(['./build/js/*.css'])
    .pipe(rev())
    .pipe(gulp.dest('./build/js'))
    .pipe(qn({
      qiniu: qiniu_options,
      prefix: 'css'
    }))
    .pipe(rev.manifest())
    .pipe(gulp.dest('./build/rev/css'));
});
gulp.task('publish-html', function () {  
  return gulp.src(['./build/rev/**/*.json', './build/views/*.html'])
    .pipe(revCollector({
      dirReplacements: {
        '/js/': ''
      }
    }))
    .pipe(gulp.dest('./build/views'));
});
gulp.task('default',function(callback){  
  runSequence(
    ['publish-css','publish-js','publish-font'],
    'publish-html',
    callback);
});
</code></pre>

<h2 id="ps">PS:</h2>

<p>publish-js：将js文件进行版本更新并上传到七牛。</p>

<p>publish-css：将css文件进行版本更新并上传到七牛。</p>

<p>publish-font：将字体文件上传到七牛。</p>

<p>publish-html：将html文件中对应的js路径进行替换。</p>]]></content:encoded></item><item><title><![CDATA[初探全新的 Node.js 包管理器 Yarn]]></title><description><![CDATA[就在前几天， Facebook 发布了新的 node.js 包管理器 Yarn 用以替代 npm 。这个和 Exponent, Google, 以及 Tilde 合作完成的项目。 咱虽然是个半桶水的咸鱼前端，不过也得跟上 Javascript 这股潮 (zhuang) 流 (bi) 的脚步，所以便有了下面这篇文章。大概的浅尝了一下这个自称是又快又可信赖又安全的包管理，所以写的内容不会很详细，更多的可能只是针对这个全新的包管理与 npm 的不同之处来对比。也可能有些地方写得不对，如果有的话，欢(lai)迎(da)指(wo)正(a)。
<!-- more -->  

<p><img src="http://img.blog.csdn.net/20161012124212953" alt=""></p>

<h2 id="installation">Installation</h2>

<p>首先当然是安装啦。跟 npm 这种被钦点而随 nodejs 一起被安装的包管理器不同， Yarn 需要自行手动安装。这也可以理解吧，毕竟是全新的东西。</p>]]></description><link>http://localhost:2368/yarn-preview/</link><guid isPermaLink="false">6c9076f8-390c-4ed0-b348-5bddc5aa40e4</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Sat, 15 Oct 2016 09:17:00 GMT</pubDate><content:encoded><![CDATA[就在前几天， Facebook 发布了新的 node.js 包管理器 Yarn 用以替代 npm 。这个和 Exponent, Google, 以及 Tilde 合作完成的项目。 咱虽然是个半桶水的咸鱼前端，不过也得跟上 Javascript 这股潮 (zhuang) 流 (bi) 的脚步，所以便有了下面这篇文章。大概的浅尝了一下这个自称是又快又可信赖又安全的包管理，所以写的内容不会很详细，更多的可能只是针对这个全新的包管理与 npm 的不同之处来对比。也可能有些地方写得不对，如果有的话，欢(lai)迎(da)指(wo)正(a)。
<!-- more -->  

<p><img src="http://img.blog.csdn.net/20161012124212953" alt=""></p>

<h2 id="installation">Installation</h2>

<p>首先当然是安装啦。跟 npm 这种被钦点而随 nodejs 一起被安装的包管理器不同， Yarn 需要自行手动安装。这也可以理解吧，毕竟是全新的东西。不过老实说，安装体验是不太好的……吧。</p>

<p>为什么怎么说呢……因为我的开发环境是 Arch Linux ，而官方文档只提供了 apt-get 系 Linux 和 yum 系 Linux 的安装方式……</p>

<p>既然志在取代 npm ，那么肯定有全平台的兼容方案咯，果然有适用于所有发行版的手动安装脚本，于是我就尝试这个，可是装了三次没有一次成功，各种问题……</p>

<p>最后发现，其实 yarn 可以直接像装模块那样用 npm 装：</p>

<pre><code class="language-js">npm install -g yarn  
</code></pre>

<p>啊嘞？一个要取代 npm 的东西，居然还要用 npm 来装？ excuse me ？好吧，不管怎么讲总之是这样装上了，所以我说安装体验一般般……也许可能对其他的发行版来说会好一些吧，可能对于一些大众的发行版和 macOS 来说，安装就是一条命令打进终端的事情。</p>

<p>虽然截止到我写这篇文章的时候，已经有了 Arch Linux 上的安装方式，不过是通过 yaourt(AUR) 的方式，不过我并不觉得对于新手来说手动装一下 yaourt 再装 yarn 比直接装 nodejs 然后 npm install 简单。也许在现阶段，相比什么 Debian/Ubuntu/CentOS 来说 Arch 还是个小众的发行版吧……</p>

<h2 id="dependenciesmanagement">Dependencies Management</h2>

<p>安装部分就这样告一段落。既然作为一个包管理，就要做好自己的职责。接下来就想要试试这个新包管理是否真的有它所宣传的那样神奇。接下来我在同样的环境下，将 yarn 和 npm 以及 cnpm 做对比。由于墙内的特殊环境，已将 npm 的 registry 更换为 <a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a> 。</p>

<h2 id="faster">FASTER</h2>

<p>在对比之前，我觉得这个对比对 yarn 来说有些不公平，因为 npm 已经设置了国内的镜像，而截止此文章发布的时候 yarn 并没有国内镜像，所以并没有对 yarn 进行特殊的设置。我有些担心这样会不会对测试的结果造成误差。</p>

<p>Yarn 既然是 Facebook 家的东西，那我们就首先试一下安装他家的 React 好了：</p>

<p>首先当然是主角 yarn 啦。需要注意的是 yarn 安装依赖的方式不同于 npm ，你需要执行以下命令来安装依赖：</p>

<pre><code class="language-js">yarn add react  
</code></pre>

<p>接下来是 npm 。因为 npm 并不显示命令时间，所以我掐了一下秒表，大概 45s 的样子，是 yarn 的好几倍多。好像比起 npm 来说， yarn 的速度确实快了一些呢，而且 npm 用的还是国内的源。</p>

<p>不过 cnpm 的速度就更快了，只用了 4s 便完成了整个安装过程。但是毕竟 cnpm 是 npm 的衍生产物，处于情理之中。既然这东西可以改善 npm 的速度，谁知道以后会不会有 cyarn 呢？但是通过这个测试我们可以看出， yarn 的速度相比原生 npm 着实是一个质的飞跃，FASTER 并不是浪得虚名。</p>

<p>接下来我又尝试了安装其他的包，多次对比了一下， 平均下来 yarn 会比 npm 快上 3–6 倍（这是安装体积小一些的包的情况）。</p>

<h2 id="reliablesecure">RELIABLE/SECURE</h2>

<p>至于这个包管理是否 reliable/secure ，这个我暂时没想到怎么测试。我只知道在我用的时候，偶尔有几率会报一些莫名其妙的错误，但是反复执行两遍命令，就又正常工作了。毕竟 yarn 是新出的东西嘛，可以理解。不过就在这一天之内，yarn 的 GitHub 项目主页已经赢得了 9K star，issues 和 pull request 也有了上千个，可见其火热的程度，所以对于它的前景，我还是很看好的。</p>

<h2 id="offlinemode">Offline mode</h2>

<p>Yarn 的一个亮点就是可以离线安装依赖，当然，前提是曾经安装过这个依赖。 Yarn 会缓存安装过的包，下次安装的时候如果指定了 -offline 参数， Yarn 就会直接从缓存中取出这个包，这样将大大缩短安装依赖的时间。</p>

<p>遗憾的是，尽管官方文档我看了一遍又一遍，这个功能还是无法正常在我的环境上工作。我会找一下原因，这一段稍后补充。</p>

<p>但是这个 feature 真的是让人眼前一亮，可以说解决了 npm 的一个短板，很致命的短板。有了这样的功能之后，以后在没有网络的环境下也能够安装已有的依赖的。而且省去了下载的时间，大大提高了效率。想象一下以后执行 react-native init 的时候不用漫长等待 15 分钟了，是不是很开心（当然，什么时候 Facebook 把 react-native init 的安装依赖过程换成自家的包管理安装还是未知数喔）。</p>

<h2 id="yarnlock">yarn.lock</h2>

<p>Yarn 通过一个 yarn.lock 文件，来使得你的程序得以在不同的机器上获得一致的体验。虽然这个解释很牵强，好歹我没有机翻给大家看，已经很良心了（雾）。感觉这好像是个很高端的东西，其实主要是对 package.json 的一个补充。</p>

<p>忽如一夜春风来，千树万树梨花开。有时候就是眼睛一睁一闭之间，一个新的东西就这样在你全然不知的时候悄然面世了。今天出了 yarn，明天指不定又会出现什么。庆幸的是，我们还能赶上这个新玩意的早班车。</p>

<p>记得近几日的一篇高端黑文（大雾），描述了在 2016 年学习 Javascript 这门语言的感受，确实，这门语言单单一年的发展，就足以呛死不少人。</p>

<p>但是必须要说 yarn 的出现确实是有进步意义的，他解决了 npm 已知的一些问题，拓展出了新的特性。既然如此，它就是值得去接触和学习的。尽管距离取代 npm 还有好长的一段时间，走好长的一段路，但是可以预见它的前途将是一片的光明。</p>

<p>所以，来吧，你需要尝试一些新的东西。 yarn 未来的成长，将由我们共同见证。</p>]]></content:encoded></item><item><title><![CDATA[JavaScript ES6核心特性概述]]></title><description><![CDATA[<p>JavaScript在过去几年里发生了很大的变化。这里有12个新功能，您可以学习使用它们！</p>

<p><img src="http://css88.b0.upaiyun.com/css88/2016/10/es6-core-features-overview-large.png" alt=""></p>

<h2 id="javascript">JavaScript历史</h2>

<p>新增加的语言称为ECMAScript 6。它也称为ES6或ES2015 +。</p>

<p>自从 1995年提出的JavaScript构想以来，发展进展非常缓慢。每隔几年新增一次。1997年以来 ECMAScript 一直作为JavaScript实现的基础，引导JavaScript 发展。它已经发布了好几个版本，如ES3，ES5，ES6等。</p>

<blockquote>
  <p>ECMAScript与JavaScript的关系：</p>
  
  <p>ECMA-262标准的描述如下：“ ECMAScript 可以为不同种类的宿主环境提供核心的脚本编程能力，因此核心的脚本语言时与任何特定的宿主环境分开进行规定的。”简单地说，ECMAScript描述了以下内容：语法、类型、语句、关键字、保留字、运算符、对象等。</p>
  
  <p>ECMAScript是JavaScript的一个重要标准，但它并不是JavaScript唯一的部分，当然，也不是唯一被标准化的部分。比如在WEB前端开发中，Web浏览器对于ECMAScript来说是一个宿主环境，但它并不是唯一的宿主环境。事实上，还有不计其数的其他各种环境(例如目前很火的Node.js
  )。一个完整的JavaScript实现是由以下3个不同部分组成的：核心(ECMAScript)、文档对象模型(DOM)</p></blockquote>]]></description><link>http://localhost:2368/javascript-es6/</link><guid isPermaLink="false">12f014a0-f53b-4213-9a82-ca4d4bff4f0f</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Mon, 10 Oct 2016 07:58:00 GMT</pubDate><content:encoded><![CDATA[<p>JavaScript在过去几年里发生了很大的变化。这里有12个新功能，您可以学习使用它们！</p>

<p><img src="http://css88.b0.upaiyun.com/css88/2016/10/es6-core-features-overview-large.png" alt=""></p>

<h2 id="javascript">JavaScript历史</h2>

<p>新增加的语言称为ECMAScript 6。它也称为ES6或ES2015 +。</p>

<p>自从 1995年提出的JavaScript构想以来，发展进展非常缓慢。每隔几年新增一次。1997年以来 ECMAScript 一直作为JavaScript实现的基础，引导JavaScript 发展。它已经发布了好几个版本，如ES3，ES5，ES6等。</p>

<blockquote>
  <p>ECMAScript与JavaScript的关系：</p>
  
  <p>ECMA-262标准的描述如下：“ ECMAScript 可以为不同种类的宿主环境提供核心的脚本编程能力，因此核心的脚本语言时与任何特定的宿主环境分开进行规定的。”简单地说，ECMAScript描述了以下内容：语法、类型、语句、关键字、保留字、运算符、对象等。</p>
  
  <p>ECMAScript是JavaScript的一个重要标准，但它并不是JavaScript唯一的部分，当然，也不是唯一被标准化的部分。比如在WEB前端开发中，Web浏览器对于ECMAScript来说是一个宿主环境，但它并不是唯一的宿主环境。事实上，还有不计其数的其他各种环境(例如目前很火的Node.js
  )。一个完整的JavaScript实现是由以下3个不同部分组成的：核心(ECMAScript)、文档对象模型(DOM)、浏览器对象模型(BOM)。</p>
  
  <p>正如你所看到的，ES3，ES5和ES6之间分别存在10年和6年的时间间隔。目前ECMAScript发展的新模式是每年进行少量变更。而不是像ES6一样做大量的更改。</p>
</blockquote>

<h2 id="">浏览器支持</h2>

<p><img src="http://css88.b0.upaiyun.com/css88/2016/10/es6-javascript-support.png" alt=""></p>

<p>所有现代浏览器和环境都已经支持ES6了！Chrome，MS Edge，Firefox，Safari，Node等等已经内置支持JavaScript ES6的大部分功能。所以，你在本教程中学到的一切，你可以立即开始使用它。</p>

<p>让我们开始使用 ECMAScript 6 吧！</p>

<h2 id="es6">核心ES6特性</h2>

<p>变量的块作用域</p>

<p>在过去声明变量使用 var，而在ES6中，声明变量还可以使用 let / const。</p>

<p>var 有什么问题？</p>

<p>var 的问题是变量会被泄漏到其他代码块，例如 for 循环或 if 代码块。  </p>

<pre><code class="language-js">ES5 代码:  
var x = 'outer';  
function test(inner) {  
  if (inner) {
    var x = 'inner'; // 作用域是整个function
    return x;
  }
  return x; //被重新定义，因为第4行声明被提升
}
test(false); // undefined  
test(true); // inner  
</code></pre>

<p>上面代码中，对于test(false) 你可能期望的是返回 outer, 但是不是, 你得到的是 undefined。</p>

<p>为什么?</p>

<p>因为即使 if 代码块没有被执行，第4行中的表达式var x也是被提升的。</p>

<blockquote>
  <p>var 变量提升</p>
  
  <p>var是函数作用域。它在整个函数中是可用的，甚至在被声明之前。
  初始化 不 提升。如果你使用var ，请总是在顶部声明你的变量。
  应用提升规则后我们可以更好地了解发生了什么：</p>
</blockquote>

<pre><code class="language-js">ES5 代码:  
var x = 'outer';  
function test(inner) {  
  var x; // 提升声明
  if (inner) {
    x = 'inner'; // 初始化不提升
    return x;
  }
  return x;
}
</code></pre>

<p>用ECMAScript 6 来拯救：</p>

<pre><code class="language-js">ES6 代码:  
let x = 'outer';  
function test(inner) {  
  if (inner) {
    let x = 'inner';
    return x;
  }
  return x; // 从第1行获得预期结果
}
test(false); // outer  
test(true); // inner  
</code></pre>

<p>从var改用 let,使代码按你设想的那样执行。 if 代码块没有被执行，变量x不会从if 代码块中被提升。</p>

<p>let 提升 和 “暂时性死区”</p>

<p>在ES6中，let将把变量提升到代码块的顶部（不是像ES5那样的函数顶部）。
但是，代码块中，在变量声明之前引用这个变量会导致一个 ReferenceError 错误。
let是块作用域。在声明之前不能使用它。 <br>
“暂时性死区”是指从代码块开始直到变量被声明的区域。</p>

<h2 id="iife">IIFE</h2>

<p>在解释LIFE之前，让我们举个例子。 看看这里：</p>

<pre><code class="language-js">ES5 代码:  
{
  var private = 1;
}
console.log(private); // 1  
</code></pre>

<p>正如你所看到的，变量private 被泄漏到了代码块外面。你需要使用IIFE（immediately-invoked function expression，即：立即调用函数表达式）来包含它：</p>

<pre><code class="language-js">ES5 代码:  
(function(){
  var private2 = 1;
})();
console.log(private2); // 未捕获 ReferenceError  
</code></pre>

<p>如果你看看jQuery / lodash或其他开源项目，您将注意到他们使用IIFE以避免污染全局环境并只是在全局定义，如 _，$ 或 jQuery 。</p>

<p>在ES6中更干净，如果我们只是现在某个代码块中使用使用某个变量，我们可以使用let，再也不需要使用IIFE了：</p>

<pre><code class="language-js">ES6 代码:  
{
  let private3 = 1;
}
console.log(private3); // 未捕获 ReferenceError  
</code></pre>

<h2 id="const">Const</h2>

<p>如果你想要一个变量一直不改变，你也可以使用 const。</p>

<p><img src="http://css88.b0.upaiyun.com/css88/2016/10/javascript-es6-const-variables-example.png" alt=""></p>

<p>底线：var 区分 let 和 const。</p>

<p>对于所有引用使用const; 避免使用var。
如果你必须重新分配引用（愚人码头注：变量需要重新赋值的），使用let而不是const。</p>

<h2 id="templateliterals">模板字面量(Template Literals)</h2>

<p>当我们有了模板字面量，我们就不需要做更多的嵌套连接。看一看：</p>

<pre><code class="language-js">ES5 代码:  
var first = 'Adrian';  
var last = 'Mejia';  
console.log('Your name is ' + first + ' ' + last + '.');  
</code></pre>

<p>现在你可以使用反引号 ( <code></code> ) 和插值字符串 ${};</p>

<pre><code class="language-js">ES6 代码:  
const first = 'Adrian';  
const last = 'Mejia';  
console.log(`Your name is ${first} ${last}.`);  
</code></pre>

<p>ES6的模板字面量没有转义、循环、条件判断等内置语法，感觉功能还很弱。</p>

<h2 id="">多行字符串</h2>

<p>我们不必在连接字符串时需要加 \n，就像这样：</p>

<pre><code class="language-js">ES5 代码:  
var template = '&lt;li *ngFor="let todo of todos" [ngClass]="{completed: todo.isDone}" &gt;\n' +  
'  &lt;div class="view"&gt;\n' +  
'    &lt;input class="toggle" type="checkbox" [checked]="todo.isDone"&gt;\n' +  
'    &lt;label&gt;&lt;/label&gt;\n' +  
'    &lt;button class="destroy"&gt;&lt;/button&gt;\n' +  
'  &lt;/div&gt;\n' +  
'  &lt;input class="edit" value=""&gt;\n' +  
'&lt;/li&gt;';  
console.log(template);  
</code></pre>

<p>在ES6中，我们可以再次使用反引号来解决这个问题：</p>

<pre><code class="language-js">ES6 代码:  
const template = `&lt;li *ngFor="let todo of todos" [ngClass]="{completed: todo.isDone}" &gt;  
  &lt;div class="view"&gt;
    &lt;input class="toggle" type="checkbox" [checked]="todo.isDone"&gt;
    &lt;label&gt;&lt;/label&gt;
    &lt;button class="destroy"&gt;&lt;/button&gt;
  &lt;/div&gt;
  &lt;input class="edit" value=""&gt;
&lt;/li&gt;`;  
console.log(template);  
</code></pre>

<p>这两段代码将等到完全相同的结果。</p>

<h2 id="">解构分配</h2>

<p>ES6解构非常有用和简洁。 按照这个例子：</p>

<p>从数组中获取元素</p>

<pre><code class="language-js">ES5 代码:  
var array = [1, 2, 3, 4];  
var first = array[0];  
var third = array[2];  
console.log(first, third); // 1 3  
</code></pre>

<p>等价于：</p>

<pre><code class="language-js">ES6 代码:  
const array = [1, 2, 3, 4];  
const [first, ,third] = array;  
console.log(first, third); // 1 3  
</code></pre>

<p>交换值</p>

<pre><code class="language-js">ES5 代码:  
var a = 1;  
var b = 2;  
var tmp = a;  
a = b;  
b = tmp;  
console.log(a, b); // 2 1  
</code></pre>

<p>等价于：</p>

<pre><code class="language-js">ES6 代码:  
let a = 1;  
let b = 2;  
[a, b] = [b, a];
console.log(a, b); // 2 1  
</code></pre>

<p>多个返回值的解构</p>

<pre><code class="language-js">ES5 代码:  
function margin() {  
  var left=1, right=2, top=3, bottom=4;
  return { left: left, right: right, top: top, bottom: bottom };
}
var data = margin();  
var left = data.left;  
var bottom = data.bottom;  
console.log(left, bottom); // 1 4  
</code></pre>

<p>在第3行，你也可以在一个数组中返回它像这样（并保存一些类型）：</p>

<pre><code class="language-js">js 代码:  
return [left, right, top, bottom];  
</code></pre>

<p>但是调用者需要顾及到返回数据的顺序。</p>

<pre><code class="language-js">js 代码:  
var left = data[0];  
var bottom = data[3];  
</code></pre>

<p>使用ES6，调用者只需要选择他们需要的数据（第6行）：</p>

<pre><code class="language-js">ES6 代码:  
function margin() {  
  const left=1, right=2, top=3, bottom=4;
  return { left, right, top, bottom };
}
const { left, bottom } = margin();  
console.log(left, bottom); // 1 4  
</code></pre>

<p>注意：第3行，我们可以看到ES6的一些其他特性。我们可以压缩{left：left}为{left}。看看它比 ES5 简洁了很多。是不是很酷？</p>

<h2 id="">参数匹配的解构</h2>

<pre><code class="language-js">ES5 代码:  
var user = {firstName: 'Adrian', lastName: 'Mejia'};  
function getFullName(user) {  
  var firstName = user.firstName;
  var lastName = user.lastName;
  return firstName + ' ' + lastName;
}
console.log(getFullName(user)); // Adrian Mejia  
</code></pre>

<p>等价于：</p>

<pre><code class="language-js">ES6 代码:  
const user = {firstName: 'Adrian', lastName: 'Mejia'};  
function getFullName({ firstName, lastName }) {  
  return `${firstName} ${lastName}`;
}
console.log(getFullName(user)); // Adrian Mejia  
</code></pre>

<h2 id="">深度匹配</h2>

<pre><code class="language-js">ES5 代码:  
function settings() {  
  return { display: { color: 'red' }, keyboard: { layout: 'querty'} };
}
var tmp = settings();  
var displayColor = tmp.display.color;  
var keyboardLayout = tmp.keyboard.layout;  
console.log(displayColor, keyboardLayout); // red querty  
</code></pre>

<p>等价于：</p>

<pre><code class="language-js">ES6 代码:  
function settings() {  
  return { display: { color: 'red' }, keyboard: { layout: 'querty'} };
}
const { display: { color: displayColor }, keyboard: { layout: keyboardLayout }} = settings();  
console.log(displayColor, keyboardLayout); // red querty  
</code></pre>

<p>这也称为对象解构。</p>

<p>正如你所看到的，解构是非常有用的，并鼓励良好的编码风格。</p>

<p>最佳实践：</p>

<p>使用数组解构来获取元素或交换变量。它可以避免创建临时引用。
对于函数多个返回值不要使用数组解构，而使用对象解构。</p>

<h2 id="">类与对象</h2>

<p>使用ECMAScript 6，我们可以从“构造函数”过渡到“类”。</p>

<p>在JavaScript中每一个对象都有一个原型，这是另一个对象。所有JavaScript对象继承了它们原型中的方法和属性。</p>

<p>在ES5中，我们面向对象编程（OOP）需要使用构造函数来创建对象，如下：</p>

<pre><code class="language-js">ES5 代码:  
var Animal = (function () {  
  function MyConstructor(name) {
    this.name = name;
  }
  MyConstructor.prototype.speak = function speak() {
    console.log(this.name + ' makes a noise.');
  };
  return MyConstructor;
})();
var animal = new Animal('animal');  
animal.speak(); // animal makes a noise.  
</code></pre>

<p>在ES6中，我们有一些语法糖。我们可以用较少的板式代码，以及class和constructor等新的关键字做同样的事情。
另外，请注意我们如何清楚地定义方法constructor.prototype.speak = function () vs speak()：</p>

<pre><code class="language-js">ES6 代码:  
class Animal {  
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(this.name + ' makes a noise.');
  }
}
const animal = new Animal('animal');  
animal.speak(); // animal makes a noise.  
</code></pre>

<p>正如你所看到的，两种样式（ES5/6）在幕后产生相同的结果，并且可以以相同的方式使用。</p>

<p>最佳实践：</p>

<p>始终使用class语法，并避免直接操作 prototype。为什么？因为它使代码更简洁和更容易理解。
避免使用空的构造函数。如果没有指定，类有一个默认构造函数。</p>

<h2 id="">继承</h2>

<p>基于前面的Animal类。假设我们想要扩展它并定义Lion类。</p>

<p>在ES5中，它更多地涉及原型继承。</p>

<pre><code class="language-js">ES5 代码:  
var Lion = (function () {  
  function MyConstructor(name){
    Animal.call(this, name);
  }

  // prototypal inheritance
  MyConstructor.prototype = Object.create(Animal.prototype);
  MyConstructor.prototype.constructor = Animal;

  MyConstructor.prototype.speak = function speak() {
    Animal.prototype.speak.call(this);
    console.log(this.name + ' roars ');
  };
  return MyConstructor;
})();
var lion = new Lion('Simba');  
lion.speak(); // Simba makes a noise.  
// Simba roars.
</code></pre>

<p>我不详细描述所有细节，但请注意：</p>

<ul>
<li>第3行，我们用参数显式调用Animal构造函数。</li>
<li>第7-8行，我们将Lion原型分配给Animal原型。</li>
<li>第11行，我们从父类Animal中调用speak方法。</li>
<li>在ES6中，我们有2个新的关键字extends和super。</li>
</ul>

<pre><code class="language-js">ES6 代码:  
class Lion extends Animal {  
  speak() {
    super.speak();
    console.log(this.name + ' roars ');
  }
}
const lion = new Lion('Simba');  
lion.speak(); // Simba makes a noise.  
// Simba roars.
</code></pre>

<p>看看ES6的代码比ES5看起来清晰了很多，并且他们做的事情完全一样。</p>

<p>最佳实践：</p>

<p>使用extends内置继承方式来实现继承。</p>

<h2 id="promises">原生的 Promises</h2>

<p>从回调地狱 到 promises</p>

<pre><code class="language-js">ES5 代码:  
function printAfterTimeout(string, timeout, done){  
  setTimeout(function(){
    done(string);
  }, timeout);
}
printAfterTimeout('Hello ', 2e3, function(result){  
  console.log(result);
  // nested callback
  printAfterTimeout(result + 'Reader', 2e3, function(result){
    console.log(result);
  });
});
</code></pre>

<p>我们有一个函数接收一个回调，当done时执行。我们必须一个接一个地两度执行它。这就是为什么我们在回调中第二次调用printAfterTimeout的原因。</p>

<p>如果你需要第3或第4次回调，那么你很快就凌乱了。让我们看看我们如何使用promises：</p>

<pre><code class="language-js">ES6 代码:  
function printAfterTimeout(string, timeout){  
  return new Promise((resolve, reject) =&gt; {
    setTimeout(function(){
      resolve(string);
    }, timeout);
  });
}
printAfterTimeout('Hello ', 2e3).then((result) =&gt; {  
  console.log(result);
  return printAfterTimeout(result + 'Reader', 2e3);
}).then((result) =&gt; {
  console.log(result);
});
</code></pre>

<p>正如你说看到的，使用 promises，我们可以使用then在一个函数完成后做另一些事情。不再需要嵌套函数。</p>

<h2 id="">箭头函数</h2>

<p>ES6没有删除函数表达式，但它添加了一个新的函数表达式，称为箭头函数。</p>

<p>在ES5中，对于this我们有一些疑问：</p>

<pre><code class="language-js">ES5 代码:  
var _this = this; // 需要保持一个引用  
$('.btn').click(function(event){
  _this.sendData(); // 引用函数外层的 this
});
$('.input').on('change',function(event){
  this.sendData(); // 引用函数外层的 this
}.bind(this)); // 绑定函数外层的 this
</code></pre>

<p>你需要使用一个临时的 this ，以便在函数内部引用，或使用bind。在ES6中，可以使用箭头函数！</p>

<pre><code class="language-js">ES6 代码:  
// this 将引用外部的那个 this
$('.btn').click((event) =&gt;  this.sendData());
// 隐式返回
const ids = [291, 288, 984];  
const messages = ids.map(value =&gt; `ID is ${value}`);  
</code></pre>

<h2 id="forof">For…of</h2>

<p>从 for 到 forEach 再到 for...of:</p>

<pre><code class="language-js">ES5 代码:  
// for
var array = ['a', 'b', 'c', 'd'];  
for (var i = 0; i &lt; array.length; i++) {  
  var element = array[i];
  console.log(element);
}
// forEach
array.forEach(function (element) {  
  console.log(element);
});
</code></pre>

<p>ES6 的 for...of 同样允许我们迭代。  </p>

<pre><code class="language-js">ES6 代码:  
// for ...of
const array = ['a', 'b', 'c', 'd'];  
for (const element of array) {  
    console.log(element);
}
</code></pre>

<h2 id="">默认参数</h2>

<p>从检查变量是否被定义 到 分配一个值给默认参数。你以前做过类似的事情吗？</p>

<pre><code class="language-js">ES5 代码:  
function point(x, y, isFlag){  
  x = x || 0;
  y = y || -1;
  isFlag = isFlag || true;
  console.log(x,y, isFlag);
}
point(0, 0) // 0 -1 true  
point(0, 0, false) // 0 -1 true  
point(1) // 1 -1 true  
point() // 0 -1 true  
</code></pre>

<p>肯定这些做过吧？这是一个常见的模式来检查是变量是否赋值，否则分配一个默认值。但是，注意有一些问题：
* 第7行，我们传递0, 0，得到0, -1。
* 第8行，我们传递false，但得到true。
如果你将一个布尔值作为默认参数或将值设置为0，它就不正常工作了。你知道为什么吗？？？我将在ES6示例后面告诉你;）</p>

<p>现在，如果你用ES6，可以用更少的代码做的更好！</p>

<pre><code class="language-js">ES6 代码:  
function point(x = 0, y = -1, isFlag = true){  
  console.log(x,y, isFlag);
}
point(0, 0) // 0 0 true  
point(0, 0, false) // 0 0 false  
point(1) // 1 -1 true  
point() // 0 -1 true  
</code></pre>

<p>注意第4行和第5行， 我们得到了预期的结果。ES5的示例则没有正常工作。我们必须属性检查  undefined,因为false，null，undefined和0是假（falsy）值。我们需要更加多的代码来修复这个问题：</p>

<pre><code class="language-js">ES5 代码:  
function point(x, y, isFlag){  
  x = x || 0;
  y = typeof(y) === 'undefined' ? -1 : y;
  isFlag = typeof(isFlag) === 'undefined' ? true : isFlag;
  console.log(x,y, isFlag);
}
point(0, 0) // 0 0 true  
point(0, 0, false) // 0 0 false  
point(1) // 1 -1 true  
point() // 0 -1 true  
</code></pre>

<p>我们检查 undefined，现在它就能按预期工作了。</p>

<h2 id="rest">Rest参数（多余参数）</h2>

<p>从 arguments 到 rest参数 和 扩展运算符。</p>

<p>在ES5中，获取任意数量的参数是非常麻烦的：</p>

<pre><code class="language-js">ES5 代码:  
function printf(format) {  
  var params = [].slice.call(arguments, 1);
  console.log('params: ', params);
  console.log('format: ', format);
}
printf('%s %d %.2f', 'adrian', 321, Math.PI);  
</code></pre>

<p>我们可以使用rest运算符...做同样的事情。</p>

<pre><code class="language-js">ES6 代码:  
function printf(format, ...params) {  
  console.log('params: ', params);
  console.log('format: ', format);
}
printf('%s %d %.2f', 'adrian', 321, Math.PI);  
</code></pre>

<h2 id="">扩展运算符</h2>

<p>从apply()到扩展运算符，我们有 ... 拯救：</p>

<p>提醒：我们使用apply() 将数组转换为一个参数列表。例如，Math.max()获取参数列表，但是如果我们有一个数组，我们可以使用apply来使它工作。</p>

<p><img src="http://css88.b0.upaiyun.com/css88/2016/10/javascript-math-apply-arrays.png" alt=""></p>

<p>正如我们在前面看到的，我们可以使用apply将数组作为参数列表传递：</p>

<pre><code class="language-js">ES5 代码:  
Math.max.apply(Math, [2,100,1,6,43]) // 100  
</code></pre>

<p>在ES6中，你可以使用 扩展运算符。</p>

<pre><code class="language-js">ES6 代码:  
Math.max(...[2,100,1,6,43]) // 100  
</code></pre>

<p>另外，我们可以使用扩展运算符来 concat（合并）数组：</p>

<pre><code class="language-js">ES5 代码:  
var array1 = [2,100,1,6,43];  
var array2 = ['a', 'b', 'c', 'd'];  
var array3 = [false, true, null, undefined];  
console.log(array1.concat(array2, array3));  
</code></pre>

<p>在ES6中，可以使用扩展运算符合并数组：</p>

<pre><code class="language-js">ES6 代码:  
const array1 = [2,100,1,6,43];  
const array2 = ['a', 'b', 'c', 'd'];  
const array3 = [false, true, null, undefined];  
console.log([...array1, ...array2, ...array3]);  
</code></pre>]]></content:encoded></item><item><title><![CDATA[使用RequireJS进行模块化开发]]></title><description><![CDATA[<p>在之前的项目中一直用的是seajs，感觉seajs是挺好用的，但是有个问题就是把现有的js框架打包成seajs模块略麻烦，官方文档里面也没有对这一块作详细的介绍，虽然有spm build，但还是觉得不太方便。因此便在新的项目中用了requirejs。</p>

<p><img src="http://blog.u.qiniudn.com/uploads%2Frequirejs.png" alt="requirejs"></p>

<p>用requirejs其实还有另一个原因就是项目中用到了百度的图表库<a href="http://echarts.baidu.com/" title="echarts">echarts</a>，根据其官方文档的描述是不建议使用基于CMD规范的seajs来加载的，因为echarts是基于AMD模块化的，虽然网上有人改了可以用seajs加载，但是我最后还是选择用requirejs来加载，同时也是想尝试一下requirejs。</p>

<p><strong>自定义构建echarts</strong></p>

<p><code>echarts</code>的构建是用的<code>r.js</code>，因此我在这里先讲一下。</p>

<p>自定义构建<code>echarts</code>还必须下载<code>zrender</code>，下载完成之后，把<code>echarts</code>的目录和<code>zrender</code>目录放在同级目录下，然后进入<code>echarts</code>的<code>build</code>目录进行自定义<code>build</code>（需要node.js环境），下面是我的build命令：</p>

<pre><code class="language-bash">node build.js optimize=true exclude=force,scatter,k,radar,</code></pre>]]></description><link>http://localhost:2368/requirejs-dev/</link><guid isPermaLink="false">cbf4880a-dabe-40fe-a60d-ba7d6566e634</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Mon, 10 Oct 2016 07:54:00 GMT</pubDate><content:encoded><![CDATA[<p>在之前的项目中一直用的是seajs，感觉seajs是挺好用的，但是有个问题就是把现有的js框架打包成seajs模块略麻烦，官方文档里面也没有对这一块作详细的介绍，虽然有spm build，但还是觉得不太方便。因此便在新的项目中用了requirejs。</p>

<p><img src="http://blog.u.qiniudn.com/uploads%2Frequirejs.png" alt="requirejs"></p>

<p>用requirejs其实还有另一个原因就是项目中用到了百度的图表库<a href="http://echarts.baidu.com/" title="echarts">echarts</a>，根据其官方文档的描述是不建议使用基于CMD规范的seajs来加载的，因为echarts是基于AMD模块化的，虽然网上有人改了可以用seajs加载，但是我最后还是选择用requirejs来加载，同时也是想尝试一下requirejs。</p>

<p><strong>自定义构建echarts</strong></p>

<p><code>echarts</code>的构建是用的<code>r.js</code>，因此我在这里先讲一下。</p>

<p>自定义构建<code>echarts</code>还必须下载<code>zrender</code>，下载完成之后，把<code>echarts</code>的目录和<code>zrender</code>目录放在同级目录下，然后进入<code>echarts</code>的<code>build</code>目录进行自定义<code>build</code>（需要node.js环境），下面是我的build命令：</p>

<pre><code class="language-bash">node build.js optimize=true exclude=force,scatter,k,radar,chord,gauge,funnel,map  output=echarts1.js  
</code></pre>

<p>上面命令的意思是排除<code>exclude</code>的之后的那些模块，因为我只用到了<code>echarts</code>的折线图、柱状图和饼状图。</p>

<p>执行完成之后就可以在build目录看到刚才合并的<code>echarts1.js</code></p>

<p><strong>requirejs模块加载配置</strong></p>

<p><code>requirejs</code>引入主模块的方法是通过在script标签里面添加<code>data-main</code>属性，如我的引入代码：</p>

<pre><code class="language-html">&lt;script data-main="js/main" src="js/lib/requirejs/require.js"&gt;&lt;/script&gt;  
</code></pre>

<p><code>main.js</code>是程序的入口js文件，然后我们在<code>main.js</code>里面进行模块的加载配置：</p>

<pre><code class="language-javascript">requirejs.config({  
    //开发专用，阻止浏览器缓存
    urlArgs: "v=" + Date.now(),
    //js文件的目录，相对于引入main.js的那个文件的目录
    baseUrl: 'js',
    //对于默认不兼容AMD规范的模块通过shim来配置
    //deps数组，表明该模块的依赖性，
    //exports值，表明这个模块外部调用时的名称
    //下面代码里面包含了如何加载库和插件
    shim: {
        'backbone': {
               deps: ['underscore', 'jquery'],
            exports: 'Backbone'
        },
        'underscore': {
            exports: '_'
        },
        'backbone.localStorage': {
              deps: ['backbone'],
              exports: 'Backbone'
        },
        'bootstrap.modal': {
            deps: ['jquery'],
            exports: 'jQuery.fn.modal'
        }
    },
    //模块的加载路径（不要加.js后缀，因为默认就是加载js，加了会报错）
    //路径是相对于上面的baseUrl
    paths: {
        jquery: 'lib/jquery/jquery-1.11.1.min',
        underscore: 'lib/underscore/underscore-min',
        ...
        text: 'lib/requirejs/plugins/text',
        echarts:'lib/echarts/echarts',
        'echarts/chart/bar' : 'lib/echarts/echarts',
        config: 'modules/common/config'
    }   
});

//下面开始加载执行
require(['backbone', 'modules/app'], function (Backbone, AppRouter) {  
    new AppRouter();
    Backbone.history.start();
});
</code></pre>

<p><strong>requirejs模块定义与加载</strong></p>

<p><code>requirejs</code>定义一个模块相当简单，下面是一个简单的例子:</p>

<pre><code class="language-javascript">define(['backbone'], function(Backbone){  
    var AppRouter = Backbone.Router.extend({
        ...
    });

    //导出对象
    return AppRouter;
});
</code></pre>

<p>我们也可以动态加载模块：</p>

<pre><code class="language-javascript">define(['backbone'], function(Backbone){  
    var AppRouter = Backbone.Router.extend({
        ...
        index： function(){
            require(['echarts', 'echarts/chart/bar'], function(ec){
                ...
            });
        }
    });

    //导出对象
    return AppRouter;
});
</code></pre>

<p>如果你已经用习惯了<code>seajs</code>的模块加载方法的话，你也可以像<code>seajs</code>里面那样去加载模块：</p>

<pre><code class="language-javascript">define(function (require) {  
    var $ = require('jquery');

    return function () {
        ...
    };
});
</code></pre>

<p>或者<code>CommonJS</code>的方式也ok:</p>

<pre><code class="language-javascript">define(function(require, exports, module) {  
    ...
});
</code></pre>

<p><code>requirejs</code>提供一个加载文本的插件<code>text.js</code>，细心的话你可能已经看到我在<code>requirejs.config</code>里面已经配置了，使用也很简单：</p>

<pre><code class="language-javascript">// 注意这里自定义模块的加载路径
// 可以写相对路径，那就是相对于当前js文件的路径
// 也可以写绝对路径，就是相对于baseUrl的路径
define(['backbone','text!../tmpl/index.html'], function(Backbone, html){

});
</code></pre>

<p><strong>requirejs构建工具r.js</strong></p>

<p>当项目上线的时候，我们可能需要对模块代码进行压缩合并的操作，这时我们就会用到<code>requirejs</code>的构建工具<code>r.js</code>。首先我们在项目根目录创建一个<code>build</code>的文件夹和<code>dist</code>的文件夹，分别用来存放模块合并相关配置和合并后的代码的文件目录，在<code>build</code>目录里面存放<code>r.js</code>，并新建一个压缩合并的配置文件<code>config.js</code>,下面是<code>config.js</code>的配置示例：</p>

<pre><code class="language-javascript">//config.js
{
    //requirejs.cofig文件的路径,它会自动读取main.js里面的配置信息
    mainConfigFile : "../js/main.js",
    baseUrl: '../js',
    name: "main",
    //输出文件的路径和名称
    out: "../dist/js/main.js",
    //默认情况写r.js会把相关的依赖文件拷贝到输出目录里面去
    //设置为true之后r.js就不会进行这一操作
    removeCombined: true,
    //findNestedDependencies设置为true表示将所有相关的依赖模块也合并进来，默认为false只会对main.js进行压缩合并的操作
    findNestedDependencies: true
}
</code></pre>

<p>然后在命令行执行：</p>

<pre><code class="language-bash">node r.js -o config.js  
</code></pre>

<p>执行完成之后便会在<code>dist/js/</code>目录下面生成一个合并后的<code>main.js</code></p>

<p>你会发现这个<code>main.js</code>可能会非常大，而在实际项目中，像通用的一些jquery、backbone等有时候我们可能没有必要把它压缩进来，我们只需要压缩自己写的一些代码，于是我们再次开始配置我们的<code>config.js</code>：</p>

<pre><code class="language-javascript">{
    mainConfigFile : "../js/main.js",
    baseUrl: "../js",
    removeCombined: true,
    findNestedDependencies: true,
    dir: "../dist/js",
    modules: [{
        name: "main",
        exclude: [
            "backbone",
            "underscore",
            "jquery",
            "text",
            ...
        ]
    }]
}
</code></pre>

<p>再次运行压缩合并命令将会发现在<code>exclude</code>数组里面的项不会被合并。</p>

<p>然而我觉得更好的做法是把通用的一些库，如jquery,bacnbone等合并到一个文件里面，我们自己的代码合并到了一个文件，因此，我们重新进行配置。</p>

<p>首先我们新建一个js文件，这个js文件啥也不用做，就是为了引用所有通用的库，这样方便我们进行排除，如下：</p>

<pre><code class="language-javascript">//libs.js

define([  
    "jquery",
    "underscore",
    "backbone",
    ...
    "text"
], function() {});
</code></pre>

<p>然后我们的<code>config.js</code>变成了这样：</p>

<pre><code class="language-javascript">{
    mainConfigFile : "../js/main.js",
    baseUrl: "../js",
    removeCombined: true,
    findNestedDependencies: true,
    dir: "../dist/js",
    modules: [
        {
            name: "main",
            exclude: [
                "libs"
            ]
        },
           {
               name: "libs"
           }
    ]
}
</code></pre>

<p>现在，我们的<code>build</code>操作终于完美了。</p>

<p>但是，如果我们的js直接通过cdn引用的呢？如果我们直接运行上面的压缩配置，<code>r.js</code>将会报错。因此，对于从cdn引入的js，我们作如下配置：</p>

<pre><code class="language-javascript">requirejs.config({  
    paths: {
        //如果cdn挂点，通过本地加载jquery
        jquery: ['http://cdn.staticfile.org/jquery/1.11.1/jquery.min.js', 'lib/jquery/jquery-1.11.1.min'],
        underscore: 'lib/underscore/underscore-min',
        ...
        text: 'lib/requirejs/plugins/text',
        echarts:'lib/echarts/echarts',
        'echarts/chart/bar' : 'lib/echarts/echarts',
        config: 'modules/common/config'
    }  
});

//修改config.js
{
    mainConfigFile : "../js/main.js",
    baseUrl: "../js",
    removeCombined: true,
    findNestedDependencies: true,
    dir: "../dist/js",
    modules: [
        {
            name: "main",
            exclude: [
                "libs"
            ]
        },
           {
               name: "libs"
           }
    ],
    paths: {
        jquery: "empty:"
    }
}
</code></pre>

<p>我们再次运行合并的操作<code>node r.js -o config.js</code>会发现此时<code>r.js</code>没有把<code>jquery</code>合并进来，因为它是通过cdn加载的。</p>

<p><strong>css的压缩合并配置</strong></p>

<p>虽然我的项目中没有用到，但在这里还是说一下吧。</p>

<p>项目中可能引用了多个css文件，如：</p>

<pre><code class="language-html">&lt;link rel="stylesheet" type="text/css" href="css/bootstrap.css"&gt;  
&lt;link rel="stylesheet" type="text/css" href="css/style.css"&gt;  
</code></pre>

<p>如果我们只想引用一个css文件，我们可以这样：</p>

<pre><code class="language-css">@import url('/css/bootstrap.css');
/* style.css content here…. */
</code></pre>

<p>然后在压缩合并的时候进行配置：</p>

<pre><code class="language-javascript">//config.js
{
    mainConfigFile : "../js/main.js",
    appDir: "../",
    baseUrl: "js",
    removeCombined: true,
    findNestedDependencies: true,
    dir: "../dist",
    optimizeCss: "standard",
    modules: [
        {
            name: "main",
            exclude: [
                "libs"
            ]
        },
           {
               name: "libs"
           }
    ],
    paths: {
        jquery: "empty:"
    }，
    //匹配到的文件或者目录不会被拷贝到dist目录
    fileExclusionRegExp: /(^\.|build|dist|sass|config.rb)/,
    generateSourceMaps: true
}
</code></pre>

<blockquote>
  <p><code>appDir</code>：项目根目录</p>
  
  <p><code>optimizeCss</code> ：css压缩规则，有四种，分别是：<code>none</code> 、<code>standard</code> 、<code>standard.keeplines</code>、<code>standard.keepComments</code>、<code>standard.keepComments.keeplines</code>。具体意思我就不一一解释了。</p>
  
  <p><code>generateSourceMaps</code>：生成map文件，把压缩过的js与未压缩的作映射</p>
</blockquote>]]></content:encoded></item><item><title><![CDATA[RequireJS入门(三)]]></title><description><![CDATA[<p>前面两篇讲述了r.js如何通过命令行把所有的模块压缩为一个js文件或把所有的css压缩为一个css文件。其中包括一些压缩配置参数的使用。</p>

<p>但以上两种方式有几个问题</p>

<ul>
<li>通过命令手动配置压缩选项显得很呆板</li>
<li>都仅合并为一个文件</li>
</ul>

<p>对于最后只生成一个文件的库来说，这种方式并无不妥。比如jQuery，它的工程中小文件有20多个，打包后只有一个jquery-1.x.x.js。对于多数实际应用项目来说，可能打包后需要生成多个js文件。有些是页面打开时就要用到的，有些是用户点击或输入时按需加载的。</p>

<p>r.js有另外一种方式来合并压缩，即通过一个配置文件（如build.js）。配置文件内部采用前端工程师非常熟悉JSON格式。这样当项目开发目录固定后，配置文件也相应固定。通过配置文件就很好的隔离了开发环境及上线环境。</p>

<p>这次我们创建的目录中包含所有前端资源，js，css，图片。</p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012060811392032.png" alt=""></p>

<p>其中有两个页面page1.html，page2.html。这两个页面分别使用page1.js和page2.js。</p>

<p>page1.js依赖于event和selector，page2.js依赖于event、selector和jQuery。jQuery是非本地的，没有合并前我们直接访问这两个页面，那么单个的js文件会依次下载。</p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012060811401231.png" alt=""></p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012060811402732.png" alt=""></p>

<p>现在使用r.js来合并压缩，使每个页面除下载require.js外只下载各自合并的大文件page1.</p>]]></description><link>http://localhost:2368/requirejs-3/</link><guid isPermaLink="false">fcd61022-0403-4b78-8f11-a1e3e9eb5a84</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Thu, 06 Oct 2016 13:54:00 GMT</pubDate><content:encoded><![CDATA[<p>前面两篇讲述了r.js如何通过命令行把所有的模块压缩为一个js文件或把所有的css压缩为一个css文件。其中包括一些压缩配置参数的使用。</p>

<p>但以上两种方式有几个问题</p>

<ul>
<li>通过命令手动配置压缩选项显得很呆板</li>
<li>都仅合并为一个文件</li>
</ul>

<p>对于最后只生成一个文件的库来说，这种方式并无不妥。比如jQuery，它的工程中小文件有20多个，打包后只有一个jquery-1.x.x.js。对于多数实际应用项目来说，可能打包后需要生成多个js文件。有些是页面打开时就要用到的，有些是用户点击或输入时按需加载的。</p>

<p>r.js有另外一种方式来合并压缩，即通过一个配置文件（如build.js）。配置文件内部采用前端工程师非常熟悉JSON格式。这样当项目开发目录固定后，配置文件也相应固定。通过配置文件就很好的隔离了开发环境及上线环境。</p>

<p>这次我们创建的目录中包含所有前端资源，js，css，图片。</p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012060811392032.png" alt=""></p>

<p>其中有两个页面page1.html，page2.html。这两个页面分别使用page1.js和page2.js。</p>

<p>page1.js依赖于event和selector，page2.js依赖于event、selector和jQuery。jQuery是非本地的，没有合并前我们直接访问这两个页面，那么单个的js文件会依次下载。</p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012060811401231.png" alt=""></p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012060811402732.png" alt=""></p>

<p>现在使用r.js来合并压缩，使每个页面除下载require.js外只下载各自合并的大文件page1.js和page2.js。</p>

<h2 id="buildjs">build.js如下</h2>

<pre><code class="language-js">({
    appDir: "./",
    baseUrl: "js",
    dir: "../r6-built",
    paths: {
        jquery: 'empty:'
    },
    modules: [
        {
            name: "page1"
        },
        {
            name: "page2"
        }
    ]
})
</code></pre>

<h2 id="">进入命令行输入如下命令</h2>

<pre><code class="language-js">node r.js -o build.js  
</code></pre>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012060811423490.png" alt=""></p>

<p>会发现在和r6同级的目录生成了r6-built目录</p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012060811435458.png" alt=""></p>

<p>该目录包含于r6一样的层级结构，这时访问该目录中的page1.html，page2.html。</p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012060811442195.png" alt=""></p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012060811443268.png" alt=""></p>

<p>这时的page1.js和page2.js就是其它模块文件的合并。另外在r6-built中其它的模块文件也被压缩了。
在build.js中可以配置很多其它参数，可以在这个示例文件中找到更多配置选项。这里不一一列举。</p>

<h2 id="">总结</h2>

<p>通过配置文件方式可以实现更加强大，灵活的合并工作。可以生成多个合并文件，包括不同页面的js、css。</p>]]></content:encoded></item><item><title><![CDATA[Gulp入门指南]]></title><description><![CDATA[<p>是时候抛弃繁重的Grunt了。Gulp是一个直观的、配置的、基于流的任务发布系统，而且它更高效。</p>

<p><img src="http://p1.bpimg.com/567571/0440708ae3690092.jpg" alt=""></p>

<p>为什么我会感兴趣呢？好问题。Gulp通过配置写代码不仅使得它编写任务简单，而且更加方便阅读和维护。</p>

<p>Gulp运用node.js的流，这使得它构建任务很快，因为没有磁盘文件的读写操作，如果你想了解更多关于流的知识，你可以看看<a href="https://github.com/substack/stream-handbook">这个</a>。Gulp允许你输入源文件，然后在一系列的管道插件中处理，最后输出，不像Grunt你需要为每个插件配置输入和输出。下面就让我们通过一个sass编译的例子来看看Gulp和Grunt的差异吧。</p>

<p><strong>Grunt:</strong></p>

<pre><code class="language-javascript">sass: {  
  dist: {
    options: {
      style: 'expanded'
    },
    files: {
      'dist/assets/css/main.css': 'src/styles/main.scss',
    }
  }
},

autoprefixer: {  
  dist: {
    options: {
      browsers: [
        'last 2 version', 'safari 5', 'ie 8', 'ie 9',</code></pre>]]></description><link>http://localhost:2368/gulp-basic/</link><guid isPermaLink="false">5c6bc378-5a59-4204-94a6-b6081bc532f2</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Wed, 05 Oct 2016 05:24:00 GMT</pubDate><content:encoded><![CDATA[<p>是时候抛弃繁重的Grunt了。Gulp是一个直观的、配置的、基于流的任务发布系统，而且它更高效。</p>

<p><img src="http://p1.bpimg.com/567571/0440708ae3690092.jpg" alt=""></p>

<p>为什么我会感兴趣呢？好问题。Gulp通过配置写代码不仅使得它编写任务简单，而且更加方便阅读和维护。</p>

<p>Gulp运用node.js的流，这使得它构建任务很快，因为没有磁盘文件的读写操作，如果你想了解更多关于流的知识，你可以看看<a href="https://github.com/substack/stream-handbook">这个</a>。Gulp允许你输入源文件，然后在一系列的管道插件中处理，最后输出，不像Grunt你需要为每个插件配置输入和输出。下面就让我们通过一个sass编译的例子来看看Gulp和Grunt的差异吧。</p>

<p><strong>Grunt:</strong></p>

<pre><code class="language-javascript">sass: {  
  dist: {
    options: {
      style: 'expanded'
    },
    files: {
      'dist/assets/css/main.css': 'src/styles/main.scss',
    }
  }
},

autoprefixer: {  
  dist: {
    options: {
      browsers: [
        'last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'
      ]
    },
    src: 'dist/assets/css/main.css',
    dest: 'dist/assets/css/main.css'
  }
},

grunt.registerTask('styles', ['sass', 'autoprefixer']);  
</code></pre>

<p>Grunt要求每个插件配置要相互独立、要分别为每个插件配置输入源和输出路径。如，我们在sass插件里面配置了一个输入文件，然后保存输出。接着我们需要配置Autoprefixer的输入为Sass的输出，然后再输出了一个文件。让我们来看看Gulp是怎么做的：</p>

<p><strong>Gulp:</strong></p>

<pre><code class="language-javascript">gulp.task('sass', function() {  
  return gulp.src('src/styles/main.scss')
    .pipe(sass({ style: 'compressed' }))
    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))
    .pipe(gulp.dest('dist/assets/css'))
});
</code></pre>

<p>在Gulp中我们只配置一次输入文件，然后依次通过Sass插件处理，再传给<code>Autoprefixer</code>插件处理，然后我们得到输出文件。整个过程没有读取和写入不必要的文件，效率大大提高。</p>

<p>因此，你感兴趣了么？让我们从安装Gulp，创建基本的任务配置文件<code>gulpfile</code>开始吧。</p>

<p><strong>安装gulp</strong></p>

<p>在我们开始配置任务之前，我们先要安装gulp:</p>

<pre><code class="language-bash">npm install gulp -g  
</code></pre>

<p>这样gulp就以全局的方式安装了，你可以在任何node命令行里面调用<code>gulp CLI</code>。然后我们需要在本地的某个项目里面使用<code>gulp</code>。使用<code>cd</code>命令进入到项目目录，运行下面的命令（先确保项目目录存在<code>package.json</code>文件）：</p>

<pre><code class="language-bash">npm install gulp --save-dev  
</code></pre>

<p>这会把gulp安装到本地项目，并且把依赖的包写入到<code>package.json</code>文件的<code>devDependencies</code>里面</p>

<p><strong>安装gulp插件</strong></p>

<p>我们将会安装下列插件来开始我们的任务：</p>

<ul>
<li>Sass 编译 (<a href="https://github.com/sindresorhus/gulp-ruby-sass">gulp-ruby-sass</a>)</li>
<li>添加浏览器前缀Autoprefixer(<a href="https://github.com/Metrime/gulp-autoprefixer">gulp-autoprefixer</a>)</li>
<li>CSS压缩（<a href="https://github.com/jonathanepollack/gulp-minify-css">gulp-minify-css</a>）</li>
<li>JS语法检查 (<a href="https://github.com/wearefractal/gulp-jshint">gulp-jshint</a>)</li>
<li>文件合并 (<a href="https://github.com/wearefractal/gulp-concat">gulp-concat</a>)</li>
<li>JS压Uglify (<a href="https://github.com/terinjokes/gulp-uglify">gulp-uglify</a>)</li>
<li>图片压缩(<a href="https://github.com/sindresorhus/gulp-imagemin">gulp-imagemin</a>)</li>
<li>LiveReload (<a href="https://github.com/vohof/gulp-livereload">gulp-livereload</a>)</li>
<li>图片缓存，只压缩修改过的图片(<a href="https://github.com/jgable/gulp-cache/">gulp-cache</a>)</li>
<li>修改提醒(<a href="https://github.com/mikaelbr/gulp-notify">gulp-notify</a>)</li>
<li>文件清理 (<a href="https://www.npmjs.org/package/del">del</a>)</li>
</ul>

<p>运行下面的命令安装这些插件：</p>

<pre><code class="language-bash">npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev  
</code></pre>

<p>这将会安装所有的依赖插件，并写入到package.json的devDependencies里面。所有的gulp插件列表可以<a href="http://gratimax.net/search-gulp-plugins/">在这里</a>看到。</p>

<p><strong>加载插件</strong></p>

<p>我们需要创建一个<code>gulpfile.js</code>，然后使用这些插件：</p>

<pre><code class="language-javascript">var gulp = require('gulp'),  
    sass = require('gulp-ruby-sass'),
    autoprefixer = require('gulp-autoprefixer'),
    minifycss = require('gulp-minify-css'),
    jshint = require('gulp-jshint'),
    uglify = require('gulp-uglify'),
    imagemin = require('gulp-imagemin'),
    rename = require('gulp-rename'),
    concat = require('gulp-concat'),
    notify = require('gulp-notify'),
    cache = require('gulp-cache'),
    livereload = require('gulp-livereload'),
    del = require('del');
</code></pre>

<p>我们也可以像grunt那样自动加载插件：<a href="https://github.com/jackfranklin/gulp-load-plugins">auto load</a></p>

<p><strong>创建任务</strong></p>

<p><em>编译sass、加前缀、压缩</em></p>

<pre><code class="language-javascript">gulp.task('styles', function() {  
  return gulp.src('src/styles/main.scss')
    .pipe(sass({ style: 'expanded' }))
    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))
    .pipe(gulp.dest('dist/assets/css'))
    .pipe(rename({suffix: '.min'}))
    .pipe(minifycss())
    .pipe(gulp.dest('dist/assets/css'))
    .pipe(notify({ message: '样式任务完成' }));
});
</code></pre>

<blockquote>
  <p>sass({ style: 'expanded' }：编译后保留原格式</p>
</blockquote>

<pre><code class="language-javascript">gulp.task('styles', function() { ... )};  
</code></pre>

<p><code>gulp.task</code>API是用来创建任务的。然后通过命令<code>gulp styles</code>运行这个任务。</p>

<pre><code class="language-javascript">return gulp.src('src/styles/main.scss')  
</code></pre>

<p><code>gulp.src</code>API用来配置输入的源文件。也可以用模式匹配，如<code>/**/*.scss</code>匹配所有文件夹下面后缀为<code>.scss</code>的文件作为输入。通过返回流使得它是异步的，确保在提醒任务完成的时候任务是完成了的。</p>

<pre><code class="language-javascript">.pipe(sass({ style: 'expanded' }))
</code></pre>

<p>通过<code>.pipe()</code>把源文件流入一个插件的管道中。然后我们可以去插件的官网看看这个插件的详细用法。</p>

<pre><code class="language-javascript">.pipe(gulp.dest('dist/assets/css'));
</code></pre>

<p><code>gulp.dest</code>API是用来告知输出文件的路径的。一个任务可以有多个输出，如一个用来输出原来的版本（即源文件），一个输出处理后的版本（即输出文件）。你可以在上面的<code>styles</code>任务中看到。</p>

<p>建议去看<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md">gulp api文档</a>，这样会更加清楚。</p>

<p><strong>js语法检查、合并和压缩任务</strong></p>

<pre><code class="language-javascript">gulp.task('scripts', function() {  
  return gulp.src('src/scripts/**/*.js')
    .pipe(jshint('.jshintrc'))
    .pipe(jshint.reporter('default'))
    .pipe(concat('main.js'))
    .pipe(gulp.dest('dist/assets/js'))
    .pipe(rename({suffix: '.min'}))
    .pipe(uglify())
    .pipe(gulp.dest('dist/assets/js'))
    .pipe(notify({ message: 'Scripts task complete' }));
});
</code></pre>

<p>这里用的<code>JSHin</code>t插件，我们使用了默认的<code>JSHint Reporter</code>，可能适用于大多数人，想了解更多可以去<a href="http://www.jshint.com/docs/reporters/">jshint官网</a>看</p>

<p><strong>图片压缩任务</strong></p>

<pre><code class="language-javascript">gulp.task('images', function() {  
  return gulp.src('src/images/**/*')
    .pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))
    .pipe(gulp.dest('dist/assets/img'))
    .pipe(notify({ message: 'Images task complete' }));
});
</code></pre>

<p>这里我们只用了<code>imagemin</code>插件，但是可以做的更好，我们可以缓存修改过的图片，或者只对修改过的图片进行再次的压缩操作，因此我们可以使用<a href="https://github.com/jgable/gulp-cache">gulp-cahce</a>插件，因此我们需要将这行代码：</p>

<pre><code class="language-javascript">.pipe(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))
</code></pre>

<p>改成：レ`人</p>

<p><pre><code class="language-javascript">gulp.task('styles', function() {  
  return gulp.src('src/styles/main.scss')
    .pipe(sass({ style: 'expanded' }))
    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))
    .pipe(gulp.dest('dist/assets/css'))
    .pipe(rename({suffix: '.min'}))
    .pipe(minifycss())
    .pipe(gulp.dest('dist/assets/css'))
    .pipe(notify({ message: '样式任务完成' }));
});
</code></pre></p>

<p>此时，只有新的图片或者改变过的图片才会被压缩。</p>

<p><strong>文件清理</strong></p>

<p>在再次发布之前，我们最好把目标文件的文件先清理掉，然后重新构建：</p>

<p><pre><code class="language-javascript">gulp.task('styles', function() { ... )};  
</code></pre></p>

<p><strong>默认任务</strong></p>

<p>我们可以通过<code>$ gulp</code>启动默认任务，然后在默认任务中调用其他任务：</p>

<p><code>gulp.task</code></p>

<p>看到<code>gulp.task</code>里面的数组了吧？这里定义了任务的依赖，也就是说<code>default</code>任务依赖<code>clean</code>任务。在这个例子中，执行<code>gulp.start</code>之前会先运行<code>clean</code>任务。Gulp里面的任务同时进行，没有明确的顺序哪个先完成，所以我们要确保<code>clean</code>任务执行完之后再执行<code>gulp.start</code>里面的任务。</p>

<blockquote>
  <p>虽然不建议在执行依赖任务数组的时候使用<code>gulp.start</code>，但是在这里我们没有办法确保<code>clean</code>任务执行完毕后再执行其它任务，因此这里使用<code>gulp.start</code>貌似是最好的选择。</p>
</blockquote>

<p><strong>Watch任务</strong></p>

<p>当文件发生变化的时候，我们可能需要重新执行任务，因此我们需要配置一个监听文件变化的任务：</p>

<p><code>gulp styles</code></p>

<p>我们通过<code>gulp.watch</code>API来监听文件的变化，然后执行相关的依赖任务。现在我们可以执行<code>$ gulp watch</code>命令来执行我们的<code>watch</code>任务，监听<code>.scss</code>、<code>.js</code>或者图片文件的变化执行相应的任务。</p>

<p><strong>LiveReload任务</strong></p>

<p>当我们代码修改的时候，Gulp也可以主动帮我们刷新页面，此时我们需要配置<code>LiveReload</code>服务，并修改我们的<code>watch</code>任务：</p>

<p><pre><code class="language-javascript">return gulp.src('src/styles/main.scss')  
</code></pre></p>

<p>要让这个任务生效，我们还需要安装并开启浏览器LiveReload插件，我们也可以<a href="http://feedback.livereload.com/knowledgebase/articles/86180-how-do-i-add-the-script-tag-manually-">手动添加代码片段</a>。</p>

<p><strong>整合这些任务</strong></p>

<p>把上面的这些任务综合起来，就构成了一个完整的<code>gulpfile</code>:</p>

<pre><code class="language-javascript">// gulpfile.js
// Load plugins
var gulp = require('gulp'),  
    sass = require('gulp-ruby-sass'),
    autoprefixer = require('gulp-autoprefixer'),
    minifycss = require('gulp-minify-css'),
    jshint = require('gulp-jshint'),
    uglify = require('gulp-uglify'),
    imagemin = require('gulp-imagemin'),
    rename = require('gulp-rename'),
    concat = require('gulp-concat'),
    notify = require('gulp-notify'),
    cache = require('gulp-cache'),
    livereload = require('gulp-livereload'),
    del = require('del');

// Styles
gulp.task('styles', function() {  
  return gulp.src('src/styles/main.scss')
    .pipe(sass({ style: 'expanded', }))
    .pipe(autoprefixer('last 2 version', 'safari 5', 'ie 8', 'ie 9', 'opera 12.1', 'ios 6', 'android 4'))
    .pipe(gulp.dest('dist/styles'))
    .pipe(rename({ suffix: '.min' }))
    .pipe(minifycss())
    .pipe(gulp.dest('dist/styles'))
    .pipe(notify({ message: 'Styles task complete' }));
});

// Scripts
gulp.task('scripts', function() {  
  return gulp.src('src/scripts/**/*.js')
    .pipe(jshint('.jshintrc'))
    .pipe(jshint.reporter('default'))
    .pipe(concat('main.js'))
    .pipe(gulp.dest('dist/scripts'))
    .pipe(rename({ suffix: '.min' }))
    .pipe(uglify())
    .pipe(gulp.dest('dist/scripts'))
    .pipe(notify({ message: 'Scripts task complete' }));
});

// Images
gulp.task('images', function() {  
  return gulp.src('src/images/**/*')
    .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true })))
    .pipe(gulp.dest('dist/images'))
    .pipe(notify({ message: 'Images task complete' }));
});

// Clean
gulp.task('clean', function(cb) {  
    del(['dist/assets/css', 'dist/assets/js', 'dist/assets/img'], cb)
});

// Default task
gulp.task('default', ['clean'], function() {  
    gulp.start('styles', 'scripts', 'images');
});

// Watch
gulp.task('watch', function() {

  // Watch .scss files
  gulp.watch('src/styles/**/*.scss', ['styles']);

  // Watch .js files
  gulp.watch('src/scripts/**/*.js', ['scripts']);

  // Watch image files
  gulp.watch('src/images/**/*', ['images']);

  // Create LiveReload server
  livereload.listen();

  // Watch any files in dist/, reload on change
  gulp.watch(['dist/**']).on('change', livereload.changed);

});
</code></pre>

<p>如有任何问题，可以在下面评论。:)</p>]]></content:encoded></item><item><title><![CDATA[BrowserSync自动刷新,释放你的F5.]]></title><description><![CDATA[想象一下这个场景：你开着两个显示器，一边是写代码，另一边是浏览器里的你正在开发的Web。此时桌上还放着你的手机，手机里也是这个开发中的应用。然后，你新写了一小段代码，按下了<code>Ctrl+S</code>保存。紧接着，你的手机和另一个显示器里的应用，就变成了更新后的效果。你可以马上检查效果是否和你预想的一致，甚至都不需要动一下鼠标。
<!-- more -->  

<p>想起来还不错？嗯，这只是简单地省略掉那个开发过程中会按好多遍的F5刷新。</p>

<p>LiveReload有所不足的地方是，需要搭配浏览器插件。但是，插件是取决于浏览器的，Chrome和Firefox都有可用插件，但IE和手机上的浏览器，就不能这样了，这时候只能手工向页面里添加一段<code>&lt;script&gt;</code>代码，而且还要记得结束后再手工移除。</p>

<p>BrowserSync的用法则不需要浏览器插件，也不用手工添加代码。一句控制台的命令之后，无论是在手机里还是电脑，无论用多少个浏览器，都可以拥有自动刷新的功能。</p>

<p><img src="http://i1.piimg.com/567571/c60e6937130d255d.jpg" alt=""></p>

<h1 id="browsersync">BrowserSync安装和使用</h1>

<ul>
<li>1.下载并安装Node.js：</li>
</ul>

<p><a href="https://nodejs.org/en/download">https://nodejs.org/en/download</a></p>

<ul>
<li>2.通过npm安装BrowserSync：</li></ul>]]></description><link>http://localhost:2368/browsersync-no-f5/</link><guid isPermaLink="false">fd3cd88b-2e2f-4018-9f80-639ee31d0c11</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Tue, 04 Oct 2016 04:04:00 GMT</pubDate><content:encoded><![CDATA[想象一下这个场景：你开着两个显示器，一边是写代码，另一边是浏览器里的你正在开发的Web。此时桌上还放着你的手机，手机里也是这个开发中的应用。然后，你新写了一小段代码，按下了<code>Ctrl+S</code>保存。紧接着，你的手机和另一个显示器里的应用，就变成了更新后的效果。你可以马上检查效果是否和你预想的一致，甚至都不需要动一下鼠标。
<!-- more -->  

<p>想起来还不错？嗯，这只是简单地省略掉那个开发过程中会按好多遍的F5刷新。</p>

<p>LiveReload有所不足的地方是，需要搭配浏览器插件。但是，插件是取决于浏览器的，Chrome和Firefox都有可用插件，但IE和手机上的浏览器，就不能这样了，这时候只能手工向页面里添加一段<code>&lt;script&gt;</code>代码，而且还要记得结束后再手工移除。</p>

<p>BrowserSync的用法则不需要浏览器插件，也不用手工添加代码。一句控制台的命令之后，无论是在手机里还是电脑，无论用多少个浏览器，都可以拥有自动刷新的功能。</p>

<p><img src="http://i1.piimg.com/567571/c60e6937130d255d.jpg" alt=""></p>

<h1 id="browsersync">BrowserSync安装和使用</h1>

<ul>
<li>1.下载并安装Node.js：</li>
</ul>

<p><a href="https://nodejs.org/en/download">https://nodejs.org/en/download</a></p>

<ul>
<li>2.通过npm安装BrowserSync：</li>
</ul>

<p><code>npm install -g browser-sync</code></p>

<ul>
<li>3.安装后，就可以开始使用了。打开控制台进入项目所在的目录，然后输入命令(此命令用于纯静态站点)：
--files 路径是相对于运行该命令的项目（目录）</li>
</ul>

<p><code>browser-sync start --server --files "*.css, *.html"</code></p>

<p>后面的*.css, *.html，是指监听目录中的后缀名为.css和.html的文件。</p>

<h2 id="">如果你的文件层级比较深，您可以考虑使用 **（任意目录匹配），来监听目录下的任意文件。</h2>

<p><code>browser-sync start --server --files "**"</code></p>

<h2 id="phphttplocalhost8080">如果是动态站点，则使用代理模式。例如PHP站点，已经建立了一个本地服务器如<code>http://localhost:8080</code></h2>

<p>此时会是这样的命令：</p>

<p><code>browser-sync start --proxy "localhost:8080" --files "*.css"</code></p>

<p>BrowserSync会提供一个新地址（如未被占用的话，<code>http://localhost:3000</code>）用于访问。</p>

<p>好了，为什么BrowserSync不需要浏览器插件？因为它使用了服务器的形式（直接或代理）来处理项目文件。默认情况下，访问它的服务器上的网页，可以看到这样的提示签：</p>

<p><img src="http://i1.piimg.com/567571/48b052b246d65304.png" alt=""></p>

<p>这说明当前浏览的网页已连接到BrowserSync。查看一下源码，会发现它们都被添加了与BrowserSync有关的一段<code>&lt;script&gt;</code>代码，就像LiveReload浏览器插件做的那样。这些代码会在浏览器和BrowserSync的服务器之间建立web socket连接，一旦有监听的文件发生变化，BrowserSync会通知浏览器。
如果监听的文件是CSS，BrowserSync不会刷新整页，而是直接重新请求这个css文件，并更新到当前页中，如图：</p>

<p><img src="http://i1.piimg.com/567571/a193de06ae37289b.gif" alt=""></p>]]></content:encoded></item><item><title><![CDATA[RequireJS入门(二)]]></title><description><![CDATA[<p>上一篇是把整个jQuery库作为一个模块。这篇来写一个自己的模块：选择器。
为演示方便这里仅实现常用的三种选择器id，className，attribute。RequireJS使用define来定义模块。</p>

<p>新建目录结构如下</p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012052309380326.png" alt=""></p>

<p>这次新建了一个子目录js，把main.js和selctor.js放入其中，require.js仍然和index.html在同一级目录。</p>

<h2 id="html">HTML 如下</h2>

<pre><code class="language-html">&lt;!doctype html&gt;  
&lt;html&gt;  
    &lt;head&gt;
        &lt;title&gt;requirejs入门（二）&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;style type="text/css"&gt;
            .wrapper {
                width: 200px;
                height:</code></pre>]]></description><link>http://localhost:2368/requirejs-2/</link><guid isPermaLink="false">3780c6fe-48a9-4f66-b69a-1f3b2f0622b1</guid><dc:creator><![CDATA[江矿宝宝.]]></dc:creator><pubDate>Tue, 04 Oct 2016 02:54:00 GMT</pubDate><content:encoded><![CDATA[<p>上一篇是把整个jQuery库作为一个模块。这篇来写一个自己的模块：选择器。
为演示方便这里仅实现常用的三种选择器id，className，attribute。RequireJS使用define来定义模块。</p>

<p>新建目录结构如下</p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012052309380326.png" alt=""></p>

<p>这次新建了一个子目录js，把main.js和selctor.js放入其中，require.js仍然和index.html在同一级目录。</p>

<h2 id="html">HTML 如下</h2>

<pre><code class="language-html">&lt;!doctype html&gt;  
&lt;html&gt;  
    &lt;head&gt;
        &lt;title&gt;requirejs入门（二）&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;style type="text/css"&gt;
            .wrapper {
                width: 200px;
                height: 200px;
                background: gray;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="wrapper"&gt;&lt;/div&gt;
        &lt;script data-main="js/main" src="require.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;  
</code></pre>

<p>这次把script标签放到了div的后面，因为要用选择器去获取页面dom元素，而这要等到dom ready后。</p>

<p>因为把main.js放到js目录中，这里data-main的值须改为“js/main”。</p>

<h2 id="selectorjs">selector.js 如下</h2>

<pre><code class="language-js">define(function() {

    function query(selector,context) {
        var s = selector,
            doc = document,
            regId = /^#[\w\-]+/,
            regCls = /^([\w\-]+)?\.([\w\-]+)/,
            regTag = /^([\w\*]+)$/,
            regNodeAttr = /^([\w\-]+)?\[([\w]+)(=(\w+))?\]/;

        var context =
                context == undefined ?
                document :
                typeof context == 'string' ?
                doc.getElementById(context.substr(1,context.length)) :
                context;

        if(regId.test(s)) {
            return doc.getElementById(s.substr(1,s.length));
        }
    }

    return query;
});
</code></pre>

<p>define的参数为一个匿名函数，该匿名函数执行后返回query，query为函数类型。query就是选择器的实现函数。</p>

<h2 id="mainjs">main.js 如下</h2>

<pre><code class="language-js">require.config({  
    baseUrl: 'js'
});

require(['selector'], function(query) {  
    var els = query('.wrapper');
    console.log(els)
});
</code></pre>

<p>require.config方法执行配置了baseUrl为“js”，baseUrl指的模块文件的根目录，可以是绝对路径或相对路径。这里用的是相对路径。相对路径指引入require.js的页面为参考点，这里是index.html。</p>

<p>把目录r2放到apache或其它web服务器上，访问index.html。</p>

<h2 id="">网络请求如下</h2>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012052309381828.png" alt=""></p>

<p>main.js和selector.js都请求下来了。</p>

<p>selector.js下载后使用query获取页面class为“.wrapper”的元素，控制台输出了该元素。如下</p>

<p><img src="http://pic002.cnblogs.com/images/2012/114013/2012052309390448.png" alt=""></p>

<h2 id="">总结</h2>

<ul>
<li>使用baseUrl来配置模块根目录，baseUrl可以是绝对路径也可以是相对路径</li>
<li>使用define定义一个函数类型模块，RequireJS的模块可以是JS对象，函数或其它任何类型（CommonJS/SeaJS则只能是JS对象）</li>
</ul>]]></content:encoded></item></channel></rss>